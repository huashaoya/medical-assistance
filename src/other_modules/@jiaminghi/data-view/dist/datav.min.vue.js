!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t(require('vue')) : typeof define === 'function' && define.amd ? define(['vue'], t) : t((e = e || self).Vue) }(this, function (e) { 'use strict'; function t (e, t) { return arguments.length === 1 ? parseInt(Math.random() * e + 1, 10) : parseInt(Math.random() * (t - e + 1) + e, 10) } function n (e, t) { const n = Math.abs(e[0] - t[0]); const r = Math.abs(e[1] - t[1]); return Math.sqrt(n * n + r * r) }e = e && e.hasOwnProperty('default') ? e.default : e; const r = { data: () => ({ dom: '', width: 0, height: 0, debounceInitWHFun: '', domObserver: '' }), methods: { async autoResizeMixinInit () { const { initWH: e, getDebounceInitWHFun: t, bindDomResizeCallback: n, afterAutoResizeMixinInit: r } = this; await e(!1), t(), n(), typeof r === 'function' && r() }, initWH (e = !0) { const { $nextTick: t, $refs: n, ref: r, onResize: i } = this; return new Promise(o => { t(t => { const a = this.dom = n[r]; this.width = a.clientWidth, this.height = a.clientHeight, typeof i === 'function' && e && i(), o() }) }) }, getDebounceInitWHFun () { const { initWH: e } = this; this.debounceInitWHFun = (function (e, t) { let n; return function () { clearTimeout(n); const [r, i] = [this, arguments]; n = setTimeout(() => { t.apply(r, i) }, e) } }(100, e)) }, bindDomResizeCallback () { const { dom: e, debounceInitWHFun: t } = this; this.domObserver = (function (e, t) { const n = new (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver)(t); return n.observe(e, { attributes: !0, attributeFilter: ['style'], attributeOldValue: !0 }), n }(e, t)), window.addEventListener('resize', t) }, unbindDomResizeCallback () { let { domObserver: e, debounceInitWHFun: t } = this; e.disconnect(), e.takeRecords(), e = null, window.removeEventListener('resize', t) } }, mounted () { const { autoResizeMixinInit: e } = this; e() }, beforeDestroy () { const { unbindDomResizeCallback: e } = this; e() } }; const i = { name: 'DvFullScreenContainer', mixins: [r], data: () => ({ ref: 'full-screen-container', allWidth: 0, scale: 0, datavRoot: '', ready: !1 }), methods: { afterAutoResizeMixinInit () { const { initConfig: e, setAppScale: t } = this; e(), t(), this.ready = !0 }, initConfig () { const { dom: e } = this; const { width: t, height: n } = screen; this.allWidth = t, e.style.width = `${t}px`, e.style.height = `${n}px` }, setAppScale () { const { allWidth: e, dom: t } = this; const n = document.body.clientWidth; t.style.transform = `scale(${n / e})` }, onResize () { const { setAppScale: e } = this; e() } } }; let o; const a = function (e, t, n, r, i, o, a, s, l, d) { typeof a !== 'boolean' && (l = s, s = a, a = !1); let c; const u = typeof n === 'function' ? n.options : n; if (e && e.render && (u.render = e.render, u.staticRenderFns = e.staticRenderFns, u._compiled = !0, i && (u.functional = !0)), r && (u._scopeId = r), o ? (c = function (e) { (e = e || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || typeof __VUE_SSR_CONTEXT__ === 'undefined' || (e = __VUE_SSR_CONTEXT__), t && t.call(this, l(e)), e && e._registeredComponents && e._registeredComponents.add(o) }, u._ssrRegister = c) : t && (c = a ? function () { t.call(this, d(this.$root.$options.shadowRoot)) } : function (e) { t.call(this, s(e)) }), c) if (u.functional) { const f = u.render; u.render = function (e, t) { return c.call(t), f(e, t) } } else { const h = u.beforeCreate; u.beforeCreate = h ? [].concat(h, c) : [c] } return n }; const s = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase()); const l = {}; const d = function (e) { return function (e, t) { return (function (e, t) { const n = s ? t.media || 'default' : e; const r = l[n] || (l[n] = { ids: new Set(), styles: [] }); if (!r.ids.has(e)) { r.ids.add(e); let i = t.source; if (t.map && (i += '\n/*# sourceURL=' + t.map.sources[0] + ' */', i += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(t.map)))) + ' */'), r.element || (r.element = document.createElement('style'), r.element.type = 'text/css', t.media && r.element.setAttribute('media', t.media), void 0 === o && (o = document.head || document.getElementsByTagName('head')[0]), o.appendChild(r.element)), 'styleSheet' in r.element)r.styles.push(i), r.element.styleSheet.cssText = r.styles.filter(Boolean).join('\n'); else { const a = r.ids.size - 1; const d = document.createTextNode(i); const c = r.element.childNodes; c[a] && r.element.removeChild(c[a]), c.length ? r.element.insertBefore(d, c[a]) : r.element.appendChild(d) } } }(e, t)) } }; const c = i; const u = function () { const e = this.$createElement; return (this._self._c || e)('div', { ref: this.ref, attrs: { id: 'dv-full-screen-container' } }, [this.ready ? [this._t('default')] : this._e()], 2) }; u._withStripped = !0; const f = a({ render: u, staticRenderFns: [] }, function (e) { e && e('data-v-2da16e2c_0', { source: '#dv-full-screen-container {\n  position: fixed;\n  top: 0px;\n  left: 0px;\n  overflow: hidden;\n  transform-origin: left top;\n  z-index: 999;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,eAAe;EACf,QAAQ;EACR,SAAS;EACT,gBAAgB;EAChB,0BAA0B;EAC1B,YAAY;AACd', file: 'main.vue', sourcesContent: ['#dv-full-screen-container {\n  position: fixed;\n  top: 0px;\n  left: 0px;\n  overflow: hidden;\n  transform-origin: left top;\n  z-index: 999;\n}\n'] }, media: void 0 }) }, c, void 0, !1, void 0, d, void 0); function h (e) { e.component(f.name, f) } const p = { name: 'DvLoading' }; const g = function () { const e = this.$createElement; const t = this._self._c || e; return t('div', { staticClass: 'dv-loading' }, [t('svg', { attrs: { width: '50px', height: '50px' } }, [t('circle', { attrs: { cx: '25', cy: '25', r: '20', fill: 'transparent', 'stroke-width': '3', 'stroke-dasharray': '31.415, 31.415', stroke: '#02bcfe', 'stroke-linecap': 'round' } }, [t('animateTransform', { attrs: { attributeName: 'transform', type: 'rotate', values: '0, 25 25;360, 25 25', dur: '1.5s', repeatCount: 'indefinite' } }), this._v(' '), t('animate', { attrs: { attributeName: 'stroke', values: '#02bcfe;#3be6cb;#02bcfe', dur: '3s', repeatCount: 'indefinite' } })], 1), this._v(' '), t('circle', { attrs: { cx: '25', cy: '25', r: '10', fill: 'transparent', 'stroke-width': '3', 'stroke-dasharray': '15.7, 15.7', stroke: '#3be6cb', 'stroke-linecap': 'round' } }, [t('animateTransform', { attrs: { attributeName: 'transform', type: 'rotate', values: '360, 25 25;0, 25 25', dur: '1.5s', repeatCount: 'indefinite' } }), this._v(' '), t('animate', { attrs: { attributeName: 'stroke', values: '#3be6cb;#02bcfe;#3be6cb', dur: '3s', repeatCount: 'indefinite' } })], 1)]), this._v(' '), t('div', { staticClass: 'loading-tip' }, [this._t('default')], 2)]) }; g._withStripped = !0; const v = a({ render: g, staticRenderFns: [] }, function (e) { e && e('data-v-c8b3d976_0', { source: '.dv-loading {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n}\n.dv-loading .loading-tip {\n  font-size: 15px;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,WAAW;EACX,YAAY;EACZ,aAAa;EACb,sBAAsB;EACtB,uBAAuB;EACvB,mBAAmB;AACrB;AACA;EACE,eAAe;AACjB', file: 'main.vue', sourcesContent: ['.dv-loading {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n}\n.dv-loading .loading-tip {\n  font-size: 15px;\n}\n'] }, media: void 0 }) }, p, void 0, !1, void 0, d, void 0); function m (e) { e.component(v.name, v) } function A (e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e } function C (e, t) { return e(t = { exports: {} }, t.exports), t.exports } const b = C(function (e) { e.exports = function (e) { return e && e.__esModule ? e : { default: e } } }); A(b); const y = function (e) { if (Array.isArray(e)) { for (var t = 0, n = new Array(e.length); t < e.length; t++)n[t] = e[t]; return n } }; const x = function (e) { if (Symbol.iterator in Object(e) || Object.prototype.toString.call(e) === '[object Arguments]') return Array.from(e) }; const w = function () { throw new TypeError('Invalid attempt to spread non-iterable instance') }; const E = function (e) { return y(e) || x(e) || w() }; const k = C(function (e) { function t (e) { return (t = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e })(e) } function n (r) { return typeof Symbol === 'function' && t(Symbol.iterator) === 'symbol' ? e.exports = n = function (e) { return t(e) } : e.exports = n = function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : t(e) }, n(r) }e.exports = n }); const B = function (e) { if (Array.isArray(e)) return e }; const P = function (e, t) { if (Symbol.iterator in Object(e) || Object.prototype.toString.call(e) === '[object Arguments]') { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !t || n.length !== t); r = !0); } catch (e) { i = !0, o = e } finally { try { r || s.return == null || s.return() } finally { if (i) throw o } } return n } }; const _ = function () { throw new TypeError('Invalid attempt to destructure non-iterable instance') }; const S = function (e, t) { return B(e) || P(e, t) || _() }; const O = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.deepClone = f, t.eliminateBlur = h, t.checkPointIsInCircle = p, t.getTwoPointDistance = g, t.checkPointIsInPolygon = v, t.checkPointIsInSector = m, t.checkPointIsNearPolyline = C, t.checkPointIsInRect = function (e, t, n, i, o) { const a = (0, r.default)(e, 2); const s = a[0]; const l = a[1]; return !(s < t) && (!(l < n) && (!(s > t + i) && !(l > n + o))) }, t.getRotatePointPos = y, t.getScalePointPos = x, t.getTranslatePointPos = w, t.getDistanceBetweenPointAndLine = B, t.getCircleRadianPoint = P, t.getRegularPolygonPoints = _, t.default = void 0; const n = b(E); var r = b(S); const i = b(k); const o = Math.abs; const a = Math.sqrt; const s = Math.sin; const l = Math.cos; const d = Math.max; const c = Math.min; const u = Math.PI; function f (e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (!e) return e; const n = JSON.parse; const r = JSON.stringify; if (!t) return n(r(e)); const o = e instanceof Array ? [] : {}; if (e && (0, i.default)(e) === 'object') for (const a in e)e.hasOwnProperty(a) && (e[a] && (0, i.default)(e[a]) === 'object' ? o[a] = f(e[a], !0) : o[a] = e[a]); return o } function h (e) { return e.map(function (e) { const t = (0, r.default)(e, 2); const n = t[0]; const i = t[1]; return [parseInt(n) + 0.5, parseInt(i) + 0.5] }) } function p (e, t, n, r) { return g(e, [t, n]) <= r } function g (e, t) { const n = (0, r.default)(e, 2); const i = n[0]; const s = n[1]; const l = (0, r.default)(t, 2); const d = l[0]; const c = l[1]; const u = o(i - d); const f = o(s - c); return a(u * u + f * f) } function v (e, t) { for (var n = 0, i = (0, r.default)(e, 2), o = i[0], a = i[1], s = t.length, l = 1, u = t[0]; l <= s; l++) { const f = t[l % s]; if (o > c(u[0], f[0]) && o <= d(u[0], f[0]) && a <= d(u[1], f[1]) && u[0] !== f[0]) { const h = (o - u[0]) * (f[1] - u[1]) / (f[0] - u[0]) + u[1]; (u[1] === f[1] || a <= h) && n++ }u = f } return n % 2 == 1 } function m (e, t, n, i, o, a, s) { if (!e) return !1; if (g(e, [t, n]) > i) return !1; if (!s) { const l = f([a, o]); const d = (0, r.default)(l, 2); o = d[0], a = d[1] } const c = o > a; if (c) { const h = [a, o]; o = h[0], a = h[1] } const p = a - o; if (p >= 2 * u) return !0; const v = (0, r.default)(e, 2); const m = v[0]; const C = v[1]; const b = P(t, n, i, o); const y = (0, r.default)(b, 2); const x = y[0]; const w = y[1]; const E = P(t, n, i, a); const k = (0, r.default)(E, 2); const B = [m - t, C - n]; let _ = [x - t, w - n]; let S = [k[0] - t, k[1] - n]; const O = p > u; if (O) { const I = f([S, _]); const W = (0, r.default)(I, 2); _ = W[0], S = W[1] } let L = A(_, B) && !A(S, B); return O && (L = !L), c && (L = !L), L } function A (e, t) { const n = (0, r.default)(e, 2); const i = n[0]; const o = n[1]; const a = (0, r.default)(t, 2); return -o * a[0] + i * a[1] > 0 } function C (e, t, i) { const o = i / 2; const a = t.map(function (e) { const t = (0, r.default)(e, 2); return [t[0], t[1] - o] }); const s = t.map(function (e) { const t = (0, r.default)(e, 2); return [t[0], t[1] + o] }); return v(e, [].concat((0, n.default)(a), (0, n.default)(s.reverse()))) } function y () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const t = arguments.length > 1 ? arguments[1] : void 0; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [0, 0]; if (!t) return !1; if (e % 360 == 0) return t; const i = (0, r.default)(t, 2); const o = i[0]; const a = i[1]; const d = (0, r.default)(n, 2); const c = d[0]; const f = d[1]; return [(o - c) * l(e *= u / 180) - (a - f) * s(e) + c, (o - c) * s(e) + (a - f) * l(e) + f] } function x () { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [1, 1]; const t = arguments.length > 1 ? arguments[1] : void 0; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [0, 0]; if (!t) return !1; if (e === 1) return t; const i = (0, r.default)(t, 2); const o = i[0]; const a = i[1]; const s = (0, r.default)(n, 2); const l = s[0]; const d = s[1]; const c = (0, r.default)(e, 2); return [(o - l) * c[0] + l, (a - d) * c[1] + d] } function w (e, t) { if (!e || !t) return !1; const n = (0, r.default)(t, 2); const i = n[0]; const o = n[1]; const a = (0, r.default)(e, 2); return [i + a[0], o + a[1]] } function B (e, t, n) { if (!e || !t || !n) return !1; const i = (0, r.default)(e, 2); const s = i[0]; const l = i[1]; const d = (0, r.default)(t, 2); const c = d[0]; const u = d[1]; const f = (0, r.default)(n, 2); const h = f[0]; const p = f[1]; const g = p - u; const v = c - h; return o(g * s + v * l + (u * (h - c) - c * (p - u))) / a(g * g + v * v) } function P (e, t, n, r) { return [e + l(r) * n, t + s(r) * n] } function _ (e, t, n, r) { const i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : -0.5 * u; const o = 2 * u / r; return new Array(r).fill('').map(function (e, t) { return t * o + i }).map(function (r) { return P(e, t, n, r) }) } const O = { deepClone: f, eliminateBlur: h, checkPointIsInCircle: p, checkPointIsInPolygon: v, checkPointIsInSector: m, checkPointIsNearPolyline: C, getTwoPointDistance: g, getRotatePointPos: y, getScalePointPos: x, getTranslatePointPos: w, getCircleRadianPoint: P, getRegularPolygonPoints: _, getDistanceBetweenPointAndLine: B }; t.default = O }); A(O); const I = O.deepClone; const W = (O.eliminateBlur, O.checkPointIsInCircle, O.getTwoPointDistance, O.checkPointIsInPolygon, O.checkPointIsInSector, O.checkPointIsNearPolyline, O.checkPointIsInRect, O.getRotatePointPos, O.getScalePointPos, O.getTranslatePointPos, O.getDistanceBetweenPointAndLine, O.getCircleRadianPoint, O.getRegularPolygonPoints, C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.filterNonNumber = i, t.deepMerge = o, t.mulAdd = a, t.mergeSameStackData = function (e, t) { const r = e.stack; if (!r) return (0, n.default)(e.data); const i = t.filter(function (e) { return e.stack === r }); const o = i.findIndex(function (t) { return t.data === e.data }); const s = i.splice(0, o + 1).map(function (e) { return e.data }); const l = s[0].length; return new Array(l).fill(0).map(function (e, t) { return a(s.map(function (e) { return e[t] })) }) }, t.getTwoPointDistance = s, t.getLinearGradientColor = function (e, t, r, i) { if (!(e && t && r && i.length)) return; let o = i; typeof o === 'string' && (o = [i, i]); const a = e.createLinearGradient.apply(e, (0, n.default)(t).concat((0, n.default)(r))); const s = 1 / (o.length - 1); return o.forEach(function (e, t) { return a.addColorStop(s * t, e) }), a }, t.getPolylineLength = function (e) { return a(new Array(e.length - 1).fill(0).map(function (t, n) { return [e[n], e[n + 1]] }).map(function (e) { return s.apply(void 0, (0, n.default)(e)) })) }, t.getPointToLineDistance = function (e, t, n) { const r = s(e, t); const i = s(e, n); const o = s(t, n); return 0.5 * Math.sqrt((r + i + o) * (r + i - o) * (r + o - i) * (i + o - r)) / o }, t.initNeedSeries = function (e, t, n) { return (e = (e = e.filter(function (e) { return e.type === n })).map(function (e) { return o((0, O.deepClone)(t, !0), e) })).filter(function (e) { return e.show }) }, t.radianToAngle = function (e) { return e / Math.PI * 180 }; var n = b(E); const r = b(k); function i (e) { return e.filter(function (e) { return typeof e === 'number' }) } function o (e, t) { for (const n in t)e[n] = e[n] && (0, r.default)(e[n]) === 'object' ? o(e[n], t[n]) : e[n] = t[n]; return e } function a (e) { return (e = i(e)).reduce(function (e, t) { return e + t }, 0) } function s (e, t) { const n = Math.abs(e[0] - t[0]); const r = Math.abs(e[1] - t[1]); return Math.sqrt(n * n + r * r) } })); A(W); W.filterNonNumber; const L = W.deepMerge; const j = (W.mulAdd, W.mergeSameStackData, W.getTwoPointDistance, W.getLinearGradientColor, W.getPolylineLength); W.getPointToLineDistance, W.initNeedSeries, W.radianToAngle; const M = { name: 'DvBorderBox1', props: { color: { type: Array, default: () => [] } }, data: () => ({ border: ['left-top', 'right-top', 'left-bottom', 'right-bottom'], defaultColor: ['#4fd2dd', '#235fa7'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const F = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { staticClass: 'dv-border-box-1' }, [e._l(e.border, function (t) { return n('svg', { key: t, class: t + ' border', attrs: { width: '150px', height: '150px' } }, [n('polygon', { attrs: { fill: e.mergedColor[0], points: '6,66 6,18 12,12 18,12 24,6 27,6 30,9 36,9 39,6 84,6 81,9 75,9 73.2,7 40.8,7 37.8,10.2 24,10.2 12,21 12,24 9,27 9,51 7.8,54 7.8,63' } }, [n('animate', { attrs: { attributeName: 'fill', values: e.mergedColor[0] + ';' + e.mergedColor[1] + ';' + e.mergedColor[0], dur: '0.5s', begin: '0s', repeatCount: 'indefinite' } })]), e._v(' '), n('polygon', { attrs: { fill: e.mergedColor[1], points: '27.599999999999998,4.8 38.4,4.8 35.4,7.8 30.599999999999998,7.8' } }, [n('animate', { attrs: { attributeName: 'fill', values: e.mergedColor[1] + ';' + e.mergedColor[0] + ';' + e.mergedColor[1], dur: '0.5s', begin: '0s', repeatCount: 'indefinite' } })]), e._v(' '), n('polygon', { attrs: { fill: e.mergedColor[0], points: '9,54 9,63 7.199999999999999,66 7.199999999999999,75 7.8,78 7.8,110 8.4,110 8.4,66 9.6,66 9.6,54' } }, [n('animate', { attrs: { attributeName: 'fill', values: e.mergedColor[0] + ';' + e.mergedColor[1] + ';transparent', dur: '1s', begin: '0s', repeatCount: 'indefinite' } })])]) }), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)], 2) }; F._withStripped = !0; const R = a({ render: F, staticRenderFns: [] }, function (e) { e && e('data-v-5211ec6c_0', { source: '.dv-border-box-1 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-1 .border {\n  position: absolute;\n  display: block;\n}\n.dv-border-box-1 .right-top {\n  right: 0px;\n  transform: rotateY(180deg);\n}\n.dv-border-box-1 .left-bottom {\n  bottom: 0px;\n  transform: rotateX(180deg);\n}\n.dv-border-box-1 .right-bottom {\n  right: 0px;\n  bottom: 0px;\n  transform: rotateX(180deg) rotateY(180deg);\n}\n.dv-border-box-1 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,cAAc;AAChB;AACA;EACE,UAAU;EACV,0BAA0B;AAC5B;AACA;EACE,WAAW;EACX,0BAA0B;AAC5B;AACA;EACE,UAAU;EACV,WAAW;EACX,0CAA0C;AAC5C;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-1 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-1 .border {\n  position: absolute;\n  display: block;\n}\n.dv-border-box-1 .right-top {\n  right: 0px;\n  transform: rotateY(180deg);\n}\n.dv-border-box-1 .left-bottom {\n  bottom: 0px;\n  transform: rotateX(180deg);\n}\n.dv-border-box-1 .right-bottom {\n  right: 0px;\n  bottom: 0px;\n  transform: rotateX(180deg) rotateY(180deg);\n}\n.dv-border-box-1 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, M, void 0, !1, void 0, d, void 0); function D (e) { e.component(R.name, R) } const G = { name: 'DvBorderBox2', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'border-box-2', defaultColor: ['#fff', 'rgba(255, 255, 255, 0.6)'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const z = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-2' }, [n('svg', { staticClass: 'dv-border-svg-container', attrs: { width: e.width, height: e.height } }, [n('polyline', { attrs: { stroke: e.mergedColor[0], points: '2, 2 ' + (e.width - 2) + ' ,2 ' + (e.width - 2) + ', ' + (e.height - 2) + ' 2, ' + (e.height - 2) + ' 2, 2' } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[1], points: '6, 6 ' + (e.width - 6) + ', 6 ' + (e.width - 6) + ', ' + (e.height - 6) + ' 6, ' + (e.height - 6) + ' 6, 6' } }), e._v(' '), n('circle', { attrs: { fill: e.mergedColor[0], cx: '11', cy: '11', r: '1' } }), e._v(' '), n('circle', { attrs: { fill: e.mergedColor[0], cx: e.width - 11, cy: '11', r: '1' } }), e._v(' '), n('circle', { attrs: { fill: e.mergedColor[0], cx: e.width - 11, cy: e.height - 11, r: '1' } }), e._v(' '), n('circle', { attrs: { fill: e.mergedColor[0], cx: '11', cy: e.height - 11, r: '1' } })]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; z._withStripped = !0; const T = a({ render: z, staticRenderFns: [] }, function (e) { e && e('data-v-7910df23_0', { source: '.dv-border-box-2 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-2 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-2 .dv-border-svg-container polyline {\n  fill: none;\n  stroke-width: 1;\n}\n.dv-border-box-2 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,QAAQ;EACR,SAAS;AACX;AACA;EACE,UAAU;EACV,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-2 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-2 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-2 .dv-border-svg-container polyline {\n  fill: none;\n  stroke-width: 1;\n}\n.dv-border-box-2 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, G, void 0, !1, void 0, d, void 0); function Y (e) { e.component(T.name, T) } const N = { name: 'DvBorderBox3', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'border-box-3', defaultColor: ['#2862b7', '#2862b7'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const $ = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-3' }, [n('svg', { staticClass: 'dv-border-svg-container', attrs: { width: e.width, height: e.height } }, [n('polyline', { staticClass: 'dv-bb3-line1', attrs: { stroke: e.mergedColor[0], points: '4, 4 ' + (e.width - 22) + ' ,4 ' + (e.width - 22) + ', ' + (e.height - 22) + ' 4, ' + (e.height - 22) + ' 4, 4' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb3-line2', attrs: { stroke: e.mergedColor[1], points: '10, 10 ' + (e.width - 16) + ', 10 ' + (e.width - 16) + ', ' + (e.height - 16) + ' 10, ' + (e.height - 16) + ' 10, 10' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb3-line2', attrs: { stroke: e.mergedColor[1], points: '16, 16 ' + (e.width - 10) + ', 16 ' + (e.width - 10) + ', ' + (e.height - 10) + ' 16, ' + (e.height - 10) + ' 16, 16' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb3-line2', attrs: { stroke: e.mergedColor[1], points: '22, 22 ' + (e.width - 4) + ', 22 ' + (e.width - 4) + ', ' + (e.height - 4) + ' 22, ' + (e.height - 4) + ' 22, 22' } })]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; $._withStripped = !0; const X = a({ render: $, staticRenderFns: [] }, function (e) { e && e('data-v-cb0f1cee_0', { source: '.dv-border-box-3 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-3 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-3 .dv-border-svg-container polyline {\n  fill: none;\n}\n.dv-border-box-3 .dv-bb3-line1 {\n  stroke-width: 3;\n}\n.dv-border-box-3 .dv-bb3-line2 {\n  stroke-width: 1;\n}\n.dv-border-box-3 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,QAAQ;EACR,SAAS;AACX;AACA;EACE,UAAU;AACZ;AACA;EACE,eAAe;AACjB;AACA;EACE,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-3 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-3 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-3 .dv-border-svg-container polyline {\n  fill: none;\n}\n.dv-border-box-3 .dv-bb3-line1 {\n  stroke-width: 3;\n}\n.dv-border-box-3 .dv-bb3-line2 {\n  stroke-width: 1;\n}\n.dv-border-box-3 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, N, void 0, !1, void 0, d, void 0); function Q (e) { e.component(X.name, X) } const H = { name: 'DvBorderBox4', mixins: [r], props: { color: { type: Array, default: () => [] }, reverse: { type: Boolean, default: !1 } }, data: () => ({ ref: 'border-box-4', defaultColor: ['red', 'rgba(0,0,255,0.8)'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const U = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-4' }, [n('svg', { class: 'dv-border-svg-container ' + (e.reverse && 'dv-reverse'), attrs: { width: e.width, height: e.height } }, [n('polyline', { staticClass: 'dv-bb4-line-1', attrs: { stroke: e.mergedColor[0], points: '145, ' + (e.height - 5) + ' 40, ' + (e.height - 5) + ' 10, ' + (e.height - 35) + '\n        10, 40 40, 5 150, 5 170, 20 ' + (e.width - 15) + ', 20' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb4-line-2', attrs: { stroke: e.mergedColor[1], points: '245, ' + (e.height - 1) + ' 36, ' + (e.height - 1) + ' 14, ' + (e.height - 23) + '\n        14, ' + (e.height - 100) } }), e._v(' '), n('polyline', { staticClass: 'dv-bb4-line-3', attrs: { stroke: e.mergedColor[0], points: '7, ' + (e.height - 40) + ' 7, ' + (e.height - 75) } }), e._v(' '), n('polyline', { staticClass: 'dv-bb4-line-4', attrs: { stroke: e.mergedColor[0], points: '28, 24 13, 41 13, 64' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb4-line-5', attrs: { stroke: e.mergedColor[0], points: '5, 45 5, 140' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb4-line-6', attrs: { stroke: e.mergedColor[1], points: '14, 75 14, 180' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb4-line-7', attrs: { stroke: e.mergedColor[1], points: '55, 11 147, 11 167, 26 250, 26' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb4-line-8', attrs: { stroke: e.mergedColor[1], points: '158, 5 173, 16' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb4-line-9', attrs: { stroke: e.mergedColor[0], points: '200, 17 ' + (e.width - 10) + ', 17' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb4-line-10', attrs: { stroke: e.mergedColor[1], points: '385, 17 ' + (e.width - 10) + ', 17' } })]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; U._withStripped = !0; const V = a({ render: U, staticRenderFns: [] }, function (e) { e && e('data-v-33ca6448_0', { source: '.dv-border-box-4 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-4 .dv-reverse {\n  transform: rotate(180deg);\n}\n.dv-border-box-4 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-4 .dv-border-svg-container polyline {\n  fill: none;\n}\n.dv-border-box-4 .sw1 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .sw3 {\n  stroke-width: 3px;\n  stroke-linecap: round;\n}\n.dv-border-box-4 .dv-bb4-line-1 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .dv-bb4-line-2 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .dv-bb4-line-3 {\n  stroke-width: 3px;\n  stroke-linecap: round;\n}\n.dv-border-box-4 .dv-bb4-line-4 {\n  stroke-width: 3px;\n  stroke-linecap: round;\n}\n.dv-border-box-4 .dv-bb4-line-5 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .dv-bb4-line-6 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .dv-bb4-line-7 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .dv-bb4-line-8 {\n  stroke-width: 3px;\n  stroke-linecap: round;\n}\n.dv-border-box-4 .dv-bb4-line-9 {\n  stroke-width: 3px;\n  stroke-linecap: round;\n  stroke-dasharray: 100 250;\n}\n.dv-border-box-4 .dv-bb4-line-10 {\n  stroke-width: 1;\n  stroke-dasharray: 80 270;\n}\n.dv-border-box-4 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,QAAQ;EACR,SAAS;AACX;AACA;EACE,UAAU;AACZ;AACA;EACE,eAAe;AACjB;AACA;EACE,iBAAiB;EACjB,qBAAqB;AACvB;AACA;EACE,eAAe;AACjB;AACA;EACE,eAAe;AACjB;AACA;EACE,iBAAiB;EACjB,qBAAqB;AACvB;AACA;EACE,iBAAiB;EACjB,qBAAqB;AACvB;AACA;EACE,eAAe;AACjB;AACA;EACE,eAAe;AACjB;AACA;EACE,eAAe;AACjB;AACA;EACE,iBAAiB;EACjB,qBAAqB;AACvB;AACA;EACE,iBAAiB;EACjB,qBAAqB;EACrB,yBAAyB;AAC3B;AACA;EACE,eAAe;EACf,wBAAwB;AAC1B;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-4 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-4 .dv-reverse {\n  transform: rotate(180deg);\n}\n.dv-border-box-4 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-4 .dv-border-svg-container polyline {\n  fill: none;\n}\n.dv-border-box-4 .sw1 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .sw3 {\n  stroke-width: 3px;\n  stroke-linecap: round;\n}\n.dv-border-box-4 .dv-bb4-line-1 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .dv-bb4-line-2 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .dv-bb4-line-3 {\n  stroke-width: 3px;\n  stroke-linecap: round;\n}\n.dv-border-box-4 .dv-bb4-line-4 {\n  stroke-width: 3px;\n  stroke-linecap: round;\n}\n.dv-border-box-4 .dv-bb4-line-5 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .dv-bb4-line-6 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .dv-bb4-line-7 {\n  stroke-width: 1;\n}\n.dv-border-box-4 .dv-bb4-line-8 {\n  stroke-width: 3px;\n  stroke-linecap: round;\n}\n.dv-border-box-4 .dv-bb4-line-9 {\n  stroke-width: 3px;\n  stroke-linecap: round;\n  stroke-dasharray: 100 250;\n}\n.dv-border-box-4 .dv-bb4-line-10 {\n  stroke-width: 1;\n  stroke-dasharray: 80 270;\n}\n.dv-border-box-4 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, H, void 0, !1, void 0, d, void 0); function q (e) { e.component(V.name, V) } const Z = { name: 'DvBorderBox5', mixins: [r], props: { color: { type: Array, default: () => [] }, reverse: { type: Boolean, default: !1 } }, data: () => ({ ref: 'border-box-5', defaultColor: ['rgba(255, 255, 255, 0.35)', 'rgba(255, 255, 255, 0.20)'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const K = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-5' }, [n('svg', { class: 'dv-svg-container  ' + (e.reverse && 'dv-reverse'), attrs: { width: e.width, height: e.height } }, [n('polyline', { staticClass: 'dv-bb5-line-1', attrs: { stroke: e.mergedColor[0], points: '8, 5 ' + (e.width - 5) + ', 5 ' + (e.width - 5) + ', ' + (e.height - 100) + '\n        ' + (e.width - 100) + ', ' + (e.height - 5) + ' 8, ' + (e.height - 5) + ' 8, 5' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb5-line-2', attrs: { stroke: e.mergedColor[1], points: '3, 5 ' + (e.width - 20) + ', 5 ' + (e.width - 20) + ', ' + (e.height - 60) + '\n        ' + (e.width - 74) + ', ' + (e.height - 5) + ' 3, ' + (e.height - 5) + ' 3, 5' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb5-line-3', attrs: { stroke: e.mergedColor[1], points: '50, 13 ' + (e.width - 35) + ', 13' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb5-line-4', attrs: { stroke: e.mergedColor[1], points: '15, 20 ' + (e.width - 35) + ', 20' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb5-line-5', attrs: { stroke: e.mergedColor[1], points: '15, ' + (e.height - 20) + ' ' + (e.width - 110) + ', ' + (e.height - 20) } }), e._v(' '), n('polyline', { staticClass: 'dv-bb5-line-6', attrs: { stroke: e.mergedColor[1], points: '15, ' + (e.height - 13) + ' ' + (e.width - 110) + ', ' + (e.height - 13) } })]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; K._withStripped = !0; const J = a({ render: K, staticRenderFns: [] }, function (e) { e && e('data-v-811b04b4_0', { source: '.dv-border-box-5 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-5 .dv-reverse {\n  transform: rotate(180deg);\n}\n.dv-border-box-5 .dv-svg-container {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-5 .dv-svg-container polyline {\n  fill: none;\n}\n.dv-border-box-5 .dv-bb5-line-1,\n.dv-border-box-5 .dv-bb5-line-2 {\n  stroke-width: 1;\n}\n.dv-border-box-5 .dv-bb5-line-3,\n.dv-border-box-5 .dv-bb5-line-6 {\n  stroke-width: 5;\n}\n.dv-border-box-5 .dv-bb5-line-4,\n.dv-border-box-5 .dv-bb5-line-5 {\n  stroke-width: 2;\n}\n.dv-border-box-5 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,WAAW;EACX,YAAY;AACd;AACA;EACE,UAAU;AACZ;AACA;;EAEE,eAAe;AACjB;AACA;;EAEE,eAAe;AACjB;AACA;;EAEE,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-5 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-5 .dv-reverse {\n  transform: rotate(180deg);\n}\n.dv-border-box-5 .dv-svg-container {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-5 .dv-svg-container polyline {\n  fill: none;\n}\n.dv-border-box-5 .dv-bb5-line-1,\n.dv-border-box-5 .dv-bb5-line-2 {\n  stroke-width: 1;\n}\n.dv-border-box-5 .dv-bb5-line-3,\n.dv-border-box-5 .dv-bb5-line-6 {\n  stroke-width: 5;\n}\n.dv-border-box-5 .dv-bb5-line-4,\n.dv-border-box-5 .dv-bb5-line-5 {\n  stroke-width: 2;\n}\n.dv-border-box-5 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, Z, void 0, !1, void 0, d, void 0); function ee (e) { e.component(J.name, J) } const te = { name: 'DvBorderBox6', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'border-box-6', defaultColor: ['rgba(255, 255, 255, 0.35)', 'gray'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const ne = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-6' }, [n('svg', { staticClass: 'dv-svg-container', attrs: { width: e.width, height: e.height } }, [n('circle', { attrs: { fill: e.mergedColor[1], cx: '5', cy: '5', r: '2' } }), e._v(' '), n('circle', { attrs: { fill: e.mergedColor[1], cx: e.width - 5, cy: '5', r: '2' } }), e._v(' '), n('circle', { attrs: { fill: e.mergedColor[1], cx: e.width - 5, cy: e.height - 5, r: '2' } }), e._v(' '), n('circle', { attrs: { fill: e.mergedColor[1], cx: '5', cy: e.height - 5, r: '2' } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: '10, 4 ' + (e.width - 10) + ', 4' } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: '10, ' + (e.height - 4) + ' ' + (e.width - 10) + ', ' + (e.height - 4) } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: '5, 70 5, ' + (e.height - 70) } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: e.width - 5 + ', 70 ' + (e.width - 5) + ', ' + (e.height - 70) } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: '3, 10, 3, 50' } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: '7, 30 7, 80' } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: e.width - 3 + ', 10 ' + (e.width - 3) + ', 50' } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: e.width - 7 + ', 30 ' + (e.width - 7) + ', 80' } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: '3, ' + (e.height - 10) + ' 3, ' + (e.height - 50) } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: '7, ' + (e.height - 30) + ' 7, ' + (e.height - 80) } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: e.width - 3 + ', ' + (e.height - 10) + ' ' + (e.width - 3) + ', ' + (e.height - 50) } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], points: e.width - 7 + ', ' + (e.height - 30) + ' ' + (e.width - 7) + ', ' + (e.height - 80) } })]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; ne._withStripped = !0; const re = a({ render: ne, staticRenderFns: [] }, function (e) { e && e('data-v-1d73ce5d_0', { source: '.dv-border-box-6 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-6 .dv-svg-container {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-6 .dv-svg-container polyline {\n  fill: none;\n  stroke-width: 1;\n}\n.dv-border-box-6 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,WAAW;EACX,YAAY;AACd;AACA;EACE,UAAU;EACV,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-6 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-6 .dv-svg-container {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-6 .dv-svg-container polyline {\n  fill: none;\n  stroke-width: 1;\n}\n.dv-border-box-6 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, te, void 0, !1, void 0, d, void 0); function ie (e) { e.component(re.name, re) } const oe = { name: 'DvBorderBox7', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'border-box-7', defaultColor: ['rgba(128,128,128,0.3)', 'rgba(128,128,128,0.5)'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const ae = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-7', style: 'box-shadow: inset 0 0 40px ' + e.mergedColor[0] + '; border: 1px solid ' + e.mergedColor[0] }, [n('svg', { staticClass: 'dv-svg-container', attrs: { width: e.width, height: e.height } }, [n('polyline', { staticClass: 'dv-bb7-line-width-2', attrs: { stroke: e.mergedColor[0], points: '0, 25 0, 0 25, 0' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb7-line-width-2', attrs: { stroke: e.mergedColor[0], points: e.width - 25 + ', 0 ' + e.width + ', 0 ' + e.width + ', 25' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb7-line-width-2', attrs: { stroke: e.mergedColor[0], points: e.width - 25 + ', ' + e.height + ' ' + e.width + ', ' + e.height + ' ' + e.width + ', ' + (e.height - 25) } }), e._v(' '), n('polyline', { staticClass: 'dv-bb7-line-width-2', attrs: { stroke: e.mergedColor[0], points: '0, ' + (e.height - 25) + ' 0, ' + e.height + ' 25, ' + e.height } }), e._v(' '), n('polyline', { staticClass: 'dv-bb7-line-width-5', attrs: { stroke: e.mergedColor[1], points: '0, 10 0, 0 10, 0' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb7-line-width-5', attrs: { stroke: e.mergedColor[1], points: e.width - 10 + ', 0 ' + e.width + ', 0 ' + e.width + ', 10' } }), e._v(' '), n('polyline', { staticClass: 'dv-bb7-line-width-5', attrs: { stroke: e.mergedColor[1], points: e.width - 10 + ', ' + e.height + ' ' + e.width + ', ' + e.height + ' ' + e.width + ', ' + (e.height - 10) } }), e._v(' '), n('polyline', { staticClass: 'dv-bb7-line-width-5', attrs: { stroke: e.mergedColor[1], points: '0, ' + (e.height - 10) + ' 0, ' + e.height + ' 10, ' + e.height } })]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; ae._withStripped = !0; const se = a({ render: ae, staticRenderFns: [] }, function (e) { e && e('data-v-7a4d3a16_0', { source: '.dv-border-box-7 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-7 .dv-svg-container {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-7 .dv-svg-container polyline {\n  fill: none;\n  stroke-linecap: round;\n}\n.dv-border-box-7 .dv-bb7-line-width-2 {\n  stroke-width: 2;\n}\n.dv-border-box-7 .dv-bb7-line-width-5 {\n  stroke-width: 5;\n}\n.dv-border-box-7 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,WAAW;EACX,YAAY;AACd;AACA;EACE,UAAU;EACV,qBAAqB;AACvB;AACA;EACE,eAAe;AACjB;AACA;EACE,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-7 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-7 .dv-svg-container {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-7 .dv-svg-container polyline {\n  fill: none;\n  stroke-linecap: round;\n}\n.dv-border-box-7 .dv-bb7-line-width-2 {\n  stroke-width: 2;\n}\n.dv-border-box-7 .dv-bb7-line-width-5 {\n  stroke-width: 5;\n}\n.dv-border-box-7 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, oe, void 0, !1, void 0, d, void 0); function le (e) { e.component(se.name, se) } const de = { name: 'DvBorderBox8', mixins: [r], props: { color: { type: Array, default: () => [] }, dur: { type: Number, default: 3 } }, data () { const e = Date.now(); return { ref: 'border-box-8', path: `border-box-8-path-${e}`, gradient: `border-box-8-gradient-${e}`, mask: `border-box-8-mask-${e}`, defaultColor: ['#235fa7', '#4fd2dd'], mergedColor: [] } }, computed: { length () { const { width: e, height: t } = this; return 2 * (e + t - 5) } }, watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const ce = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-8' }, [n('svg', { staticClass: 'dv-svg-container', attrs: { width: e.width, height: e.height } }, [n('defs', [n('path', { attrs: { id: e.path, d: 'M2.5, 2.5 L' + (e.width - 2.5) + ', 2.5 L' + (e.width - 2.5) + ', ' + (e.height - 2.5) + ' L2.5, ' + (e.height - 2.5) + ' L2.5, 2.5', fill: 'transparent' } }), e._v(' '), n('radialGradient', { attrs: { id: e.gradient, cx: '50%', cy: '50%', r: '50%' } }, [n('stop', { attrs: { offset: '0%', 'stop-color': '#fff', 'stop-opacity': '1' } }), e._v(' '), n('stop', { attrs: { offset: '100%', 'stop-color': '#fff', 'stop-opacity': '0' } })], 1), e._v(' '), n('mask', { attrs: { id: e.mask } }, [n('circle', { attrs: { cx: '0', cy: '0', r: '150', fill: 'url(#' + e.gradient + ')' } }, [n('animateMotion', { attrs: { dur: e.dur + 's', path: 'M2.5, 2.5 L' + (e.width - 2.5) + ', 2.5 L' + (e.width - 2.5) + ', ' + (e.height - 2.5) + ' L2.5, ' + (e.height - 2.5) + ' L2.5, 2.5', rotate: 'auto', repeatCount: 'indefinite' } })], 1)])], 1), e._v(' '), n('use', { attrs: { stroke: e.mergedColor[0], 'stroke-width': '1', 'xlink:href': '#' + e.path } }), e._v(' '), n('use', { attrs: { stroke: e.mergedColor[1], 'stroke-width': '3', 'xlink:href': '#' + e.path, mask: 'url(#' + e.mask + ')' } }, [n('animate', { attrs: { attributeName: 'stroke-dasharray', from: '0, ' + e.length, to: e.length + ', 0', dur: e.dur + 's', repeatCount: 'indefinite' } })])]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; ce._withStripped = !0; const ue = a({ render: ce, staticRenderFns: [] }, function (e) { e && e('data-v-036f23b6_0', { source: '.dv-border-box-8 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-8 svg {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0px;\n  top: 0px;\n}\n.dv-border-box-8 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,SAAS;EACT,QAAQ;AACV;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-8 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-8 svg {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0px;\n  top: 0px;\n}\n.dv-border-box-8 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, de, void 0, !1, void 0, d, void 0); function fe (e) { e.component(ue.name, ue) } const he = { name: 'DvBorderBox9', mixins: [r], props: { color: { type: Array, default: () => [] } }, data () { const e = Date.now(); return { ref: 'border-box-9', gradientId: `border-box-9-gradient-${e}`, maskId: `border-box-9-mask-${e}`, defaultColor: ['#11eefd', '#0078d2'], mergedColor: [] } }, watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const pe = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-9' }, [n('svg', { staticClass: 'dv-svg-container', attrs: { width: e.width, height: e.height } }, [n('defs', [n('linearGradient', { attrs: { id: e.gradientId, x1: '0%', y1: '0%', x2: '100%', y2: '100%' } }, [n('animate', { attrs: { attributeName: 'x1', values: '0%;100%;0%', dur: '10s', begin: '0s', repeatCount: 'indefinite' } }), e._v(' '), n('animate', { attrs: { attributeName: 'x2', values: '100%;0%;100%', dur: '10s', begin: '0s', repeatCount: 'indefinite' } }), e._v(' '), n('stop', { attrs: { offset: '0%', 'stop-color': e.mergedColor[0] } }, [n('animate', { attrs: { attributeName: 'stop-color', values: e.mergedColor[0] + ';' + e.mergedColor[1] + ';' + e.mergedColor[0], dur: '10s', begin: '0s', repeatCount: 'indefinite' } })]), e._v(' '), n('stop', { attrs: { offset: '100%', 'stop-color': e.mergedColor[1] } }, [n('animate', { attrs: { attributeName: 'stop-color', values: e.mergedColor[1] + ';' + e.mergedColor[0] + ';' + e.mergedColor[1], dur: '10s', begin: '0s', repeatCount: 'indefinite' } })])], 1), e._v(' '), n('mask', { attrs: { id: e.maskId } }, [n('polyline', { attrs: { stroke: '#fff', 'stroke-width': '3', fill: 'transparent', points: '8, ' + 0.4 * e.height + ' 8, 3, ' + (0.4 * e.width + 7) + ', 3' } }), e._v(' '), n('polyline', { attrs: { fill: '#fff', points: '8, ' + 0.15 * e.height + ' 8, 3, ' + (0.1 * e.width + 7) + ', 3\n            ' + 0.1 * e.width + ', 8 14, 8 14, ' + (0.15 * e.height - 7) + '\n          ' } }), e._v(' '), n('polyline', { attrs: { stroke: '#fff', 'stroke-width': '3', fill: 'transparent', points: 0.5 * e.width + ', 3 ' + (e.width - 3) + ', 3, ' + (e.width - 3) + ', ' + 0.25 * e.height } }), e._v(' '), n('polyline', { attrs: { fill: '#fff', points: '\n            ' + 0.52 * e.width + ', 3 ' + 0.58 * e.width + ', 3\n            ' + (0.58 * e.width - 7) + ', 9 ' + (0.52 * e.width + 7) + ', 9\n          ' } }), e._v(' '), n('polyline', { attrs: { fill: '#fff', points: '\n            ' + 0.9 * e.width + ', 3 ' + (e.width - 3) + ', 3 ' + (e.width - 3) + ', ' + 0.1 * e.height + '\n            ' + (e.width - 9) + ', ' + (0.1 * e.height - 7) + ' ' + (e.width - 9) + ', 9 ' + (0.9 * e.width + 7) + ', 9\n          ' } }), e._v(' '), n('polyline', { attrs: { stroke: '#fff', 'stroke-width': '3', fill: 'transparent', points: '8, ' + 0.5 * e.height + ' 8, ' + (e.height - 3) + ' ' + (0.3 * e.width + 7) + ', ' + (e.height - 3) } }), e._v(' '), n('polyline', { attrs: { fill: '#fff', points: '\n            8, ' + 0.55 * e.height + ' 8, ' + 0.7 * e.height + '\n            2, ' + (0.7 * e.height - 7) + ' 2, ' + (0.55 * e.height + 7) + '\n          ' } }), e._v(' '), n('polyline', { attrs: { stroke: '#fff', 'stroke-width': '3', fill: 'transparent', points: 0.35 * e.width + ', ' + (e.height - 3) + ' ' + (e.width - 3) + ', ' + (e.height - 3) + ' ' + (e.width - 3) + ', ' + 0.35 * e.height } }), e._v(' '), n('polyline', { attrs: { fill: '#fff', points: '\n            ' + 0.92 * e.width + ', ' + (e.height - 3) + ' ' + (e.width - 3) + ', ' + (e.height - 3) + ' ' + (e.width - 3) + ', ' + 0.8 * e.height + '\n            ' + (e.width - 9) + ', ' + (0.8 * e.height + 7) + ' ' + (e.width - 9) + ', ' + (e.height - 9) + ' ' + (0.92 * e.width + 7) + ', ' + (e.height - 9) + '\n          ' } })])], 1), e._v(' '), n('rect', { attrs: { x: '0', y: '0', width: e.width, height: e.height, fill: 'url(#' + e.gradientId + ')', mask: 'url(#' + e.maskId + ')' } })]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; pe._withStripped = !0; const ge = a({ render: pe, staticRenderFns: [] }, function (e) { e && e('data-v-56fea000_0', { source: '.dv-border-box-9 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-9 svg {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0px;\n  top: 0px;\n}\n.dv-border-box-9 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,SAAS;EACT,QAAQ;AACV;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-9 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-9 svg {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0px;\n  top: 0px;\n}\n.dv-border-box-9 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, he, void 0, !1, void 0, d, void 0); function ve (e) { e.component(ge.name, ge) } const me = { name: 'DvBorderBox10', props: { color: { type: Array, default: () => [] } }, data: () => ({ border: ['left-top', 'right-top', 'left-bottom', 'right-bottom'], defaultColor: ['#1d48c4', '#d3e1f8'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const Ae = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { staticClass: 'dv-border-box-10', style: 'box-shadow: inset 0 0 25px 3px ' + e.mergedColor[0] }, [e._l(e.border, function (t) { return n('svg', { key: t, class: t + ' border', attrs: { width: '150px', height: '150px' } }, [n('polygon', { attrs: { fill: e.mergedColor[1], points: '40, 0 5, 0 0, 5 0, 16 3, 19 3, 7 7, 3 35, 3' } })]) }), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)], 2) }; Ae._withStripped = !0; const Ce = a({ render: Ae, staticRenderFns: [] }, function (e) { e && e('data-v-88eb07d6_0', { source: '.dv-border-box-10 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  border-radius: 6px;\n}\n.dv-border-box-10 .border {\n  position: absolute;\n  display: block;\n}\n.dv-border-box-10 .right-top {\n  right: 0px;\n  transform: rotateY(180deg);\n}\n.dv-border-box-10 .left-bottom {\n  bottom: 0px;\n  transform: rotateX(180deg);\n}\n.dv-border-box-10 .right-bottom {\n  right: 0px;\n  bottom: 0px;\n  transform: rotateX(180deg) rotateY(180deg);\n}\n.dv-border-box-10 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,kBAAkB;AACpB;AACA;EACE,kBAAkB;EAClB,cAAc;AAChB;AACA;EACE,UAAU;EACV,0BAA0B;AAC5B;AACA;EACE,WAAW;EACX,0BAA0B;AAC5B;AACA;EACE,UAAU;EACV,WAAW;EACX,0CAA0C;AAC5C;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-10 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  border-radius: 6px;\n}\n.dv-border-box-10 .border {\n  position: absolute;\n  display: block;\n}\n.dv-border-box-10 .right-top {\n  right: 0px;\n  transform: rotateY(180deg);\n}\n.dv-border-box-10 .left-bottom {\n  bottom: 0px;\n  transform: rotateX(180deg);\n}\n.dv-border-box-10 .right-bottom {\n  right: 0px;\n  bottom: 0px;\n  transform: rotateX(180deg) rotateY(180deg);\n}\n.dv-border-box-10 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, me, void 0, !1, void 0, d, void 0); function be (e) { e.component(Ce.name, Ce) } const ye = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.default = void 0; const n = new Map([['transparent', 'rgba(0,0,0,0)'], ['black', '#000000'], ['silver', '#C0C0C0'], ['gray', '#808080'], ['white', '#FFFFFF'], ['maroon', '#800000'], ['red', '#FF0000'], ['purple', '#800080'], ['fuchsia', '#FF00FF'], ['green', '#008000'], ['lime', '#00FF00'], ['olive', '#808000'], ['yellow', '#FFFF00'], ['navy', '#000080'], ['blue', '#0000FF'], ['teal', '#008080'], ['aqua', '#00FFFF'], ['aliceblue', '#f0f8ff'], ['antiquewhite', '#faebd7'], ['aquamarine', '#7fffd4'], ['azure', '#f0ffff'], ['beige', '#f5f5dc'], ['bisque', '#ffe4c4'], ['blanchedalmond', '#ffebcd'], ['blueviolet', '#8a2be2'], ['brown', '#a52a2a'], ['burlywood', '#deb887'], ['cadetblue', '#5f9ea0'], ['chartreuse', '#7fff00'], ['chocolate', '#d2691e'], ['coral', '#ff7f50'], ['cornflowerblue', '#6495ed'], ['cornsilk', '#fff8dc'], ['crimson', '#dc143c'], ['cyan', '#00ffff'], ['darkblue', '#00008b'], ['darkcyan', '#008b8b'], ['darkgoldenrod', '#b8860b'], ['darkgray', '#a9a9a9'], ['darkgreen', '#006400'], ['darkgrey', '#a9a9a9'], ['darkkhaki', '#bdb76b'], ['darkmagenta', '#8b008b'], ['darkolivegreen', '#556b2f'], ['darkorange', '#ff8c00'], ['darkorchid', '#9932cc'], ['darkred', '#8b0000'], ['darksalmon', '#e9967a'], ['darkseagreen', '#8fbc8f'], ['darkslateblue', '#483d8b'], ['darkslategray', '#2f4f4f'], ['darkslategrey', '#2f4f4f'], ['darkturquoise', '#00ced1'], ['darkviolet', '#9400d3'], ['deeppink', '#ff1493'], ['deepskyblue', '#00bfff'], ['dimgray', '#696969'], ['dimgrey', '#696969'], ['dodgerblue', '#1e90ff'], ['firebrick', '#b22222'], ['floralwhite', '#fffaf0'], ['forestgreen', '#228b22'], ['gainsboro', '#dcdcdc'], ['ghostwhite', '#f8f8ff'], ['gold', '#ffd700'], ['goldenrod', '#daa520'], ['greenyellow', '#adff2f'], ['grey', '#808080'], ['honeydew', '#f0fff0'], ['hotpink', '#ff69b4'], ['indianred', '#cd5c5c'], ['indigo', '#4b0082'], ['ivory', '#fffff0'], ['khaki', '#f0e68c'], ['lavender', '#e6e6fa'], ['lavenderblush', '#fff0f5'], ['lawngreen', '#7cfc00'], ['lemonchiffon', '#fffacd'], ['lightblue', '#add8e6'], ['lightcoral', '#f08080'], ['lightcyan', '#e0ffff'], ['lightgoldenrodyellow', '#fafad2'], ['lightgray', '#d3d3d3'], ['lightgreen', '#90ee90'], ['lightgrey', '#d3d3d3'], ['lightpink', '#ffb6c1'], ['lightsalmon', '#ffa07a'], ['lightseagreen', '#20b2aa'], ['lightskyblue', '#87cefa'], ['lightslategray', '#778899'], ['lightslategrey', '#778899'], ['lightsteelblue', '#b0c4de'], ['lightyellow', '#ffffe0'], ['limegreen', '#32cd32'], ['linen', '#faf0e6'], ['magenta', '#ff00ff'], ['mediumaquamarine', '#66cdaa'], ['mediumblue', '#0000cd'], ['mediumorchid', '#ba55d3'], ['mediumpurple', '#9370db'], ['mediumseagreen', '#3cb371'], ['mediumslateblue', '#7b68ee'], ['mediumspringgreen', '#00fa9a'], ['mediumturquoise', '#48d1cc'], ['mediumvioletred', '#c71585'], ['midnightblue', '#191970'], ['mintcream', '#f5fffa'], ['mistyrose', '#ffe4e1'], ['moccasin', '#ffe4b5'], ['navajowhite', '#ffdead'], ['oldlace', '#fdf5e6'], ['olivedrab', '#6b8e23'], ['orange', '#ffa500'], ['orangered', '#ff4500'], ['orchid', '#da70d6'], ['palegoldenrod', '#eee8aa'], ['palegreen', '#98fb98'], ['paleturquoise', '#afeeee'], ['palevioletred', '#db7093'], ['papayawhip', '#ffefd5'], ['peachpuff', '#ffdab9'], ['peru', '#cd853f'], ['pink', '#ffc0cb'], ['plum', '#dda0dd'], ['powderblue', '#b0e0e6'], ['rosybrown', '#bc8f8f'], ['royalblue', '#4169e1'], ['saddlebrown', '#8b4513'], ['salmon', '#fa8072'], ['sandybrown', '#f4a460'], ['seagreen', '#2e8b57'], ['seashell', '#fff5ee'], ['sienna', '#a0522d'], ['skyblue', '#87ceeb'], ['slateblue', '#6a5acd'], ['slategray', '#708090'], ['slategrey', '#708090'], ['snow', '#fffafa'], ['springgreen', '#00ff7f'], ['steelblue', '#4682b4'], ['tan', '#d2b48c'], ['thistle', '#d8bfd8'], ['tomato', '#ff6347'], ['turquoise', '#40e0d0'], ['violet', '#ee82ee'], ['wheat', '#f5deb3'], ['whitesmoke', '#f5f5f5'], ['yellowgreen', '#9acd32']]); t.default = n }); A(ye); const xe = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.getRgbValue = l, t.getRgbaValue = d, t.getOpacity = c, t.toRgb = u, t.toHex = f, t.getColorFromRgbValue = h, t.darken = p, t.lighten = g, t.fade = v, t.default = void 0; const n = b(E); const r = b(ye); const i = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/; const o = /^(rgb|rgba|RGB|RGBA)/; const a = /^(rgba|RGBA)/; function s (e) { const t = i.test(e); const n = o.test(e); return t || n ? e : (e = (function (e) { if (!e) return console.error('getColorByKeywords: Missing parameters!'), !1; return !!r.default.has(e) && r.default.get(e) }(e))) || (console.error('Color: Invalid color!'), !1) } function l (e) { if (!e) return console.error('getRgbValue: Missing parameters!'), !1; if (!(e = s(e))) return !1; const t = i.test(e); const n = o.test(e); const r = e.toLowerCase(); return t ? (function (e) { (e = e.replace('#', '')).length === 3 && (e = Array.from(e).map(function (e) { return e + e }).join('')); return e = e.split(''), new Array(3).fill(0).map(function (t, n) { return parseInt('0x'.concat(e[2 * n]).concat(e[2 * n + 1])) }) }(r)) : n ? (function (e) { return e.replace(/rgb\(|rgba\(|\)/g, '').split(',').slice(0, 3).map(function (e) { return parseInt(e) }) }(r)) : void 0 } function d (e) { if (!e) return console.error('getRgbaValue: Missing parameters!'), !1; const t = l(e); return !!t && (t.push(c(e)), t) } function c (e) { return e ? !!(e = s(e)) && (a.test(e) ? (e = e.toLowerCase(), Number(e.split(',').slice(-1)[0].replace(/[)|\s]/g, ''))) : 1) : (console.error('getOpacity: Missing parameters!'), !1) } function u (e, t) { if (!e) return console.error('toRgb: Missing parameters!'), !1; const n = l(e); return !!n && (typeof t === 'number' ? 'rgba(' + n.join(',') + ','.concat(t, ')') : 'rgb(' + n.join(',') + ')') } function f (e) { return e ? i.test(e) ? e : !!(e = l(e)) && '#' + e.map(function (e) { return Number(e).toString(16) }).map(function (e) { return e === '0' ? '00' : e }).join('') : (console.error('toHex: Missing parameters!'), !1) } function h (e) { if (!e) return console.error('getColorFromRgbValue: Missing parameters!'), !1; const t = e.length; if (t !== 3 && t !== 4) return console.error('getColorFromRgbValue: Value is illegal!'), !1; let n = t === 3 ? 'rgb(' : 'rgba('; return n += e.join(',') + ')' } function p (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; if (!e) return console.error('darken: Missing parameters!'), !1; let n = d(e); return !!n && h(n = n.map(function (e, n) { return n === 3 ? e : e - Math.ceil(2.55 * t) }).map(function (e) { return e < 0 ? 0 : e })) } function g (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; if (!e) return console.error('lighten: Missing parameters!'), !1; let n = d(e); return !!n && h(n = n.map(function (e, n) { return n === 3 ? e : e + Math.ceil(2.55 * t) }).map(function (e) { return e > 255 ? 255 : e })) } function v (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100; if (!e) return console.error('fade: Missing parameters!'), !1; const r = l(e); return !!r && h([].concat((0, n.default)(r), [t / 100])) } const m = { fade: v, toHex: f, toRgb: u, darken: p, lighten: g, getOpacity: c, getRgbValue: l, getRgbaValue: d, getColorFromRgbValue: h }; t.default = m }); A(xe); xe.getRgbValue, xe.getRgbaValue, xe.getOpacity, xe.toRgb, xe.toHex, xe.getColorFromRgbValue, xe.darken, xe.lighten; const we = xe.fade; const Ee = { name: 'DvBorderBox11', mixins: [r], props: { color: { type: Array, default: () => [] }, titleWidth: { type: Number, default: 250 }, title: { type: String, default: '' } }, data: () => ({ ref: 'border-box-11', filterId: `border-box-11-filterId-${Date.now()}`, defaultColor: ['#8aaafb', '#1f33a2'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) }, fade: we }, mounted () { const { mergeColor: e } = this; e() } }; const ke = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-11' }, [n('svg', { staticClass: 'dv-border-svg-container', attrs: { width: e.width, height: e.height } }, [n('defs', [n('filter', { attrs: { id: e.filterId, height: '150%', width: '150%', x: '-25%', y: '-25%' } }, [n('feMorphology', { attrs: { operator: 'dilate', radius: '2', in: 'SourceAlpha', result: 'thicken' } }), e._v(' '), n('feGaussianBlur', { attrs: { in: 'thicken', stdDeviation: '3', result: 'blurred' } }), e._v(' '), n('feFlood', { attrs: { 'flood-color': e.mergedColor[1], result: 'glowColor' } }), e._v(' '), n('feComposite', { attrs: { in: 'glowColor', in2: 'blurred', operator: 'in', result: 'softGlowColored' } }), e._v(' '), n('feMerge', [n('feMergeNode', { attrs: { in: 'softGlowColored' } }), e._v(' '), n('feMergeNode', { attrs: { in: 'SourceGraphic' } })], 1)], 1)]), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], filter: 'url(#' + e.filterId + ')', points: '\n        ' + (e.width - e.titleWidth) / 2 + ', 30\n        20, 30 7, 50 7, ' + (50 + (e.height - 167) / 2) + '\n        13, ' + (55 + (e.height - 167) / 2) + ' 13, ' + (135 + (e.height - 167) / 2) + '\n        7, ' + (140 + (e.height - 167) / 2) + ' 7, ' + (e.height - 27) + '\n        20, ' + (e.height - 7) + ' ' + (e.width - 20) + ', ' + (e.height - 7) + ' ' + (e.width - 7) + ', ' + (e.height - 27) + '\n        ' + (e.width - 7) + ', ' + (140 + (e.height - 167) / 2) + ' ' + (e.width - 13) + ', ' + (135 + (e.height - 167) / 2) + '\n        ' + (e.width - 13) + ', ' + (55 + (e.height - 167) / 2) + ' ' + (e.width - 7) + ', ' + (50 + (e.height - 167) / 2) + '\n        ' + (e.width - 7) + ', 50 ' + (e.width - 20) + ', 30 ' + (e.width + e.titleWidth) / 2 + ', 30\n        ' + ((e.width + e.titleWidth) / 2 - 20) + ', 7 ' + ((e.width - e.titleWidth) / 2 + 20) + ', 7\n        ' + (e.width - e.titleWidth) / 2 + ', 30 ' + ((e.width - e.titleWidth) / 2 + 20) + ', 52\n        ' + ((e.width + e.titleWidth) / 2 - 20) + ', 52 ' + (e.width + e.titleWidth) / 2 + ', 30\n      ' } }), e._v(' '), n('polygon', { attrs: { stroke: e.mergedColor[0], fill: 'transparent', points: '\n        ' + ((e.width + e.titleWidth) / 2 - 5) + ', 30 ' + ((e.width + e.titleWidth) / 2 - 21) + ', 11\n        ' + ((e.width + e.titleWidth) / 2 - 27) + ', 11 ' + ((e.width + e.titleWidth) / 2 - 8) + ', 34\n      ' } }), e._v(' '), n('polygon', { attrs: { stroke: e.mergedColor[0], fill: 'transparent', points: '\n        ' + ((e.width - e.titleWidth) / 2 + 5) + ', 30 ' + ((e.width - e.titleWidth) / 2 + 22) + ', 49\n        ' + ((e.width - e.titleWidth) / 2 + 28) + ', 49 ' + ((e.width - e.titleWidth) / 2 + 8) + ', 26\n      ' } }), e._v(' '), n('polygon', { attrs: { stroke: e.mergedColor[0], fill: e.fade(e.mergedColor[1] || e.defaultColor[1], 30), filter: 'url(#' + e.filterId + ')', points: '\n        ' + ((e.width + e.titleWidth) / 2 - 11) + ', 37 ' + ((e.width + e.titleWidth) / 2 - 32) + ', 11\n        ' + ((e.width - e.titleWidth) / 2 + 23) + ', 11 ' + ((e.width - e.titleWidth) / 2 + 11) + ', 23\n        ' + ((e.width - e.titleWidth) / 2 + 33) + ', 49 ' + ((e.width + e.titleWidth) / 2 - 22) + ', 49\n      ' } }), e._v(' '), n('polygon', { attrs: { filter: 'url(#' + e.filterId + ')', fill: e.mergedColor[0], opacity: '1', points: '\n        ' + ((e.width - e.titleWidth) / 2 - 10) + ', 37 ' + ((e.width - e.titleWidth) / 2 - 31) + ', 37\n        ' + ((e.width - e.titleWidth) / 2 - 25) + ', 46 ' + ((e.width - e.titleWidth) / 2 - 4) + ', 46\n      ' } }, [n('animate', { attrs: { attributeName: 'opacity', values: '1;0.7;1', dur: '2s', begin: '0s', repeatCount: 'indefinite' } })]), e._v(' '), n('polygon', { attrs: { filter: 'url(#' + e.filterId + ')', fill: e.mergedColor[0], opacity: '0.7', points: '\n        ' + ((e.width - e.titleWidth) / 2 - 40) + ', 37 ' + ((e.width - e.titleWidth) / 2 - 61) + ', 37\n        ' + ((e.width - e.titleWidth) / 2 - 55) + ', 46 ' + ((e.width - e.titleWidth) / 2 - 34) + ', 46\n      ' } }, [n('animate', { attrs: { attributeName: 'opacity', values: '0.7;0.4;0.7', dur: '2s', begin: '0s', repeatCount: 'indefinite' } })]), e._v(' '), n('polygon', { attrs: { filter: 'url(#' + e.filterId + ')', fill: e.mergedColor[0], opacity: '0.5', points: '\n        ' + ((e.width - e.titleWidth) / 2 - 70) + ', 37 ' + ((e.width - e.titleWidth) / 2 - 91) + ', 37\n        ' + ((e.width - e.titleWidth) / 2 - 85) + ', 46 ' + ((e.width - e.titleWidth) / 2 - 64) + ', 46\n      ' } }, [n('animate', { attrs: { attributeName: 'opacity', values: '0.5;0.2;0.5', dur: '2s', begin: '0s', repeatCount: 'indefinite' } })]), e._v(' '), n('polygon', { attrs: { filter: 'url(#' + e.filterId + ')', fill: e.mergedColor[0], opacity: '1', points: '\n        ' + ((e.width + e.titleWidth) / 2 + 30) + ', 37 ' + ((e.width + e.titleWidth) / 2 + 9) + ', 37\n        ' + ((e.width + e.titleWidth) / 2 + 3) + ', 46 ' + ((e.width + e.titleWidth) / 2 + 24) + ', 46\n      ' } }, [n('animate', { attrs: { attributeName: 'opacity', values: '1;0.7;1', dur: '2s', begin: '0s', repeatCount: 'indefinite' } })]), e._v(' '), n('polygon', { attrs: { filter: 'url(#' + e.filterId + ')', fill: e.mergedColor[0], opacity: '0.7', points: '\n        ' + ((e.width + e.titleWidth) / 2 + 60) + ', 37 ' + ((e.width + e.titleWidth) / 2 + 39) + ', 37\n        ' + ((e.width + e.titleWidth) / 2 + 33) + ', 46 ' + ((e.width + e.titleWidth) / 2 + 54) + ', 46\n      ' } }, [n('animate', { attrs: { attributeName: 'opacity', values: '0.7;0.4;0.7', dur: '2s', begin: '0s', repeatCount: 'indefinite' } })]), e._v(' '), n('polygon', { attrs: { filter: 'url(#' + e.filterId + ')', fill: e.mergedColor[0], opacity: '0.5', points: '\n        ' + ((e.width + e.titleWidth) / 2 + 90) + ', 37 ' + ((e.width + e.titleWidth) / 2 + 69) + ', 37\n        ' + ((e.width + e.titleWidth) / 2 + 63) + ', 46 ' + ((e.width + e.titleWidth) / 2 + 84) + ', 46\n      ' } }, [n('animate', { attrs: { attributeName: 'opacity', values: '0.5;0.2;0.5', dur: '2s', begin: '0s', repeatCount: 'indefinite' } })]), e._v(' '), n('text', { staticClass: 'dv-border-box-11-title', attrs: { x: '' + e.width / 2, y: '32', fill: '#fff', 'font-size': '18', 'text-anchor': 'middle', 'dominant-baseline': 'middle' } }, [e._v('\n      ' + e._s(e.title) + '\n    ')]), e._v(' '), n('polygon', { attrs: { fill: e.mergedColor[0], filter: 'url(#' + e.filterId + ')', points: '\n        7, ' + (53 + (e.height - 167) / 2) + ' 11, ' + (57 + (e.height - 167) / 2) + '\n        11, ' + (133 + (e.height - 167) / 2) + ' 7, ' + (137 + (e.height - 167) / 2) + '\n      ' } }), e._v(' '), n('polygon', { attrs: { fill: e.mergedColor[0], filter: 'url(#' + e.filterId + ')', points: '\n        ' + (e.width - 7) + ', ' + (53 + (e.height - 167) / 2) + ' ' + (e.width - 11) + ', ' + (57 + (e.height - 167) / 2) + '\n        ' + (e.width - 11) + ', ' + (133 + (e.height - 167) / 2) + ' ' + (e.width - 7) + ', ' + (137 + (e.height - 167) / 2) + '\n      ' } })]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; ke._withStripped = !0; const Be = a({ render: ke, staticRenderFns: [] }, function (e) { e && e('data-v-75210825_0', { source: '.dv-border-box-11 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-11 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-11 .dv-border-svg-container polyline {\n  fill: none;\n  stroke-width: 1;\n}\n.dv-border-box-11 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,QAAQ;EACR,SAAS;AACX;AACA;EACE,UAAU;EACV,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-11 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-11 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-11 .dv-border-svg-container polyline {\n  fill: none;\n  stroke-width: 1;\n}\n.dv-border-box-11 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, Ee, void 0, !1, void 0, d, void 0); function Pe (e) { e.component(Be.name, Be) } const _e = { name: 'DvBorderBox12', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'border-box-12', filterId: `borderr-box-12-filterId-${+new Date()}`, defaultColor: ['#2e6099', '#7ce7fd'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) }, fade: we }, mounted () { const { mergeColor: e } = this; e() } }; const Se = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-12' }, [n('svg', { staticClass: 'dv-border-svg-container', attrs: { width: e.width, height: e.height } }, [n('defs', [n('filter', { attrs: { id: e.filterId, height: '150%', width: '150%', x: '-25%', y: '-25%' } }, [n('feMorphology', { attrs: { operator: 'dilate', radius: '1', in: 'SourceAlpha', result: 'thicken' } }), e._v(' '), n('feGaussianBlur', { attrs: { in: 'thicken', stdDeviation: '2', result: 'blurred' } }), e._v(' '), n('feFlood', { attrs: { 'flood-color': e.fade(e.mergedColor[1] || e.defaultColor[1], 70), result: 'glowColor' } }, [n('animate', { attrs: { attributeName: 'flood-color', values: '\n              ' + e.fade(e.mergedColor[1] || e.defaultColor[1], 70) + ';\n              ' + e.fade(e.mergedColor[1] || e.defaultColor[1], 30) + ';\n              ' + e.fade(e.mergedColor[1] || e.defaultColor[1], 70) + ';\n            ', dur: '3s', begin: '0s', repeatCount: 'indefinite' } })]), e._v(' '), n('feComposite', { attrs: { in: 'glowColor', in2: 'blurred', operator: 'in', result: 'softGlowColored' } }), e._v(' '), n('feMerge', [n('feMergeNode', { attrs: { in: 'softGlowColored' } }), e._v(' '), n('feMergeNode', { attrs: { in: 'SourceGraphic' } })], 1)], 1)]), e._v(' '), e.width && e.height ? n('path', { attrs: { fill: 'transparent', 'stroke-width': '2', stroke: e.mergedColor[0], d: '\n        M15 5 L ' + (e.width - 15) + ' 5 Q ' + (e.width - 5) + ' 5, ' + (e.width - 5) + ' 15\n        L ' + (e.width - 5) + ' ' + (e.height - 15) + ' Q ' + (e.width - 5) + ' ' + (e.height - 5) + ', ' + (e.width - 15) + ' ' + (e.height - 5) + '\n        L 15, ' + (e.height - 5) + ' Q 5 ' + (e.height - 5) + ' 5 ' + (e.height - 15) + ' L 5 15\n        Q 5 5 15 5\n      ' } }) : e._e(), e._v(' '), n('path', { attrs: { 'stroke-width': '2', fill: 'transparent', 'stroke-linecap': 'round', filter: 'url(#' + e.filterId + ')', stroke: e.mergedColor[1], d: 'M 20 5 L 15 5 Q 5 5 5 15 L 5 20' } }), e._v(' '), n('path', { attrs: { 'stroke-width': '2', fill: 'transparent', 'stroke-linecap': 'round', filter: 'url(#' + e.filterId + ')', stroke: e.mergedColor[1], d: 'M ' + (e.width - 20) + ' 5 L ' + (e.width - 15) + ' 5 Q ' + (e.width - 5) + ' 5 ' + (e.width - 5) + ' 15 L ' + (e.width - 5) + ' 20' } }), e._v(' '), n('path', { attrs: { 'stroke-width': '2', fill: 'transparent', 'stroke-linecap': 'round', filter: 'url(#' + e.filterId + ')', stroke: e.mergedColor[1], d: '\n        M ' + (e.width - 20) + ' ' + (e.height - 5) + ' L ' + (e.width - 15) + ' ' + (e.height - 5) + '\n        Q ' + (e.width - 5) + ' ' + (e.height - 5) + ' ' + (e.width - 5) + ' ' + (e.height - 15) + '\n        L ' + (e.width - 5) + ' ' + (e.height - 20) + '\n      ' } }), e._v(' '), n('path', { attrs: { 'stroke-width': '2', fill: 'transparent', 'stroke-linecap': 'round', filter: 'url(#' + e.filterId + ')', stroke: e.mergedColor[1], d: '\n        M 20 ' + (e.height - 5) + ' L 15 ' + (e.height - 5) + '\n        Q 5 ' + (e.height - 5) + ' 5 ' + (e.height - 15) + '\n        L 5 ' + (e.height - 20) + '\n      ' } })]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; Se._withStripped = !0; const Oe = a({ render: Se, staticRenderFns: [] }, function (e) { e && e('data-v-e77d64a4_0', { source: '.dv-border-box-12 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-12 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-12 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,QAAQ;EACR,SAAS;AACX;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-12 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-12 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-12 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, _e, void 0, !1, void 0, d, void 0); function Ie (e) { e.component(Oe.name, Oe) } const We = { name: 'DvBorderBox13', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'border-box-13', defaultColor: ['#6586ec', '#2cf7fe'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const Le = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-border-box-13' }, [n('svg', { staticClass: 'dv-border-svg-container', attrs: { width: e.width, height: e.height } }, [n('path', { attrs: { fill: 'transparent', stroke: e.mergedColor[0], d: '\n        M 5 20 L 5 10 L 12 3  L 60 3 L 68 10\n        L ' + (e.width - 20) + ' 10 L ' + (e.width - 5) + ' 25\n        L ' + (e.width - 5) + ' ' + (e.height - 5) + ' L 20 ' + (e.height - 5) + '\n        L 5 ' + (e.height - 20) + ' L 5 20\n      ' } }), e._v(' '), n('path', { attrs: { fill: 'transparent', 'stroke-width': '3', 'stroke-linecap': 'round', 'stroke-dasharray': '10, 5', stroke: e.mergedColor[0], d: 'M 16 9 L 61 9' } }), e._v(' '), n('path', { attrs: { fill: 'transparent', stroke: e.mergedColor[1], d: 'M 5 20 L 5 10 L 12 3  L 60 3 L 68 10' } }), e._v(' '), n('path', { attrs: { fill: 'transparent', stroke: e.mergedColor[1], d: 'M ' + (e.width - 5) + ' ' + (e.height - 30) + ' L ' + (e.width - 5) + ' ' + (e.height - 5) + ' L ' + (e.width - 30) + ' ' + (e.height - 5) } })]), e._v(' '), n('div', { staticClass: 'border-box-content' }, [e._t('default')], 2)]) }; Le._withStripped = !0; const je = a({ render: Le, staticRenderFns: [] }, function (e) { e && e('data-v-29fc19bd_0', { source: '.dv-border-box-13 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-13 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-13 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,QAAQ;EACR,SAAS;AACX;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-border-box-13 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-border-box-13 .dv-border-svg-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-border-box-13 .border-box-content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, We, void 0, !1, void 0, d, void 0); function Me (e) { e.component(je.name, je) } const Fe = { name: 'DvDecoration1', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'decoration-1', svgWH: [200, 50], svgScale: [1, 1], rowNum: 4, rowPoints: 20, pointSideLength: 2.5, halfPointSideLength: 1.25, points: [], rects: [], defaultColor: ['#fff', '#0de7c2'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { afterAutoResizeMixinInit () { const { calcSVGData: e } = this; e() }, calcSVGData () { const { calcPointsPosition: e, calcRectsPosition: t, calcScale: n } = this; e(), t(), n() }, calcPointsPosition () { const { svgWH: e, rowNum: t, rowPoints: n } = this; const [r, i] = e; const o = r / (n + 1); const a = i / (t + 1); const s = new Array(t).fill(0).map((e, t) => new Array(n).fill(0).map((e, n) => [o * (n + 1), a * (t + 1)])); this.points = s.reduce((e, t) => [...e, ...t], []) }, calcRectsPosition () { const { points: e, rowPoints: t } = this; const n = e[2 * t - 1]; const r = e[2 * t - 3]; this.rects = [n, r] }, calcScale () { const { width: e, height: t, svgWH: n } = this; const [r, i] = n; this.svgScale = [e / r, t / i] }, onResize () { const { calcSVGData: e } = this; e() }, mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const Re = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-decoration-1' }, [n('svg', { style: 'transform:scale(' + e.svgScale[0] + ',' + e.svgScale[1] + ');', attrs: { width: e.svgWH[0] + 'px', height: e.svgWH[1] + 'px' } }, [e._l(e.points, function (t, r) { return [Math.random() > 0.6 ? n('rect', { key: r, attrs: { fill: e.mergedColor[0], x: t[0] - e.halfPointSideLength, y: t[1] - e.halfPointSideLength, width: e.pointSideLength, height: e.pointSideLength } }, [Math.random() > 0.6 ? n('animate', { attrs: { attributeName: 'fill', values: e.mergedColor[0] + ';transparent', dur: '1s', begin: 2 * Math.random(), repeatCount: 'indefinite' } }) : e._e()]) : e._e()] }), e._v(' '), e.rects[0] ? n('rect', { attrs: { fill: e.mergedColor[1], x: e.rects[0][0] - e.pointSideLength, y: e.rects[0][1] - e.pointSideLength, width: 2 * e.pointSideLength, height: 2 * e.pointSideLength } }, [n('animate', { attrs: { attributeName: 'width', values: '0;' + 2 * e.pointSideLength, dur: '2s', repeatCount: 'indefinite' } }), e._v(' '), n('animate', { attrs: { attributeName: 'height', values: '0;' + 2 * e.pointSideLength, dur: '2s', repeatCount: 'indefinite' } }), e._v(' '), n('animate', { attrs: { attributeName: 'x', values: e.rects[0][0] + ';' + (e.rects[0][0] - e.pointSideLength), dur: '2s', repeatCount: 'indefinite' } }), e._v(' '), n('animate', { attrs: { attributeName: 'y', values: e.rects[0][1] + ';' + (e.rects[0][1] - e.pointSideLength), dur: '2s', repeatCount: 'indefinite' } })]) : e._e(), e._v(' '), e.rects[1] ? n('rect', { attrs: { fill: e.mergedColor[1], x: e.rects[1][0] - 40, y: e.rects[1][1] - e.pointSideLength, width: 40, height: 2 * e.pointSideLength } }, [n('animate', { attrs: { attributeName: 'width', values: '0;40;0', dur: '2s', repeatCount: 'indefinite' } }), e._v(' '), n('animate', { attrs: { attributeName: 'x', values: e.rects[1][0] + ';' + (e.rects[1][0] - 40) + ';' + e.rects[1][0], dur: '2s', repeatCount: 'indefinite' } })]) : e._e()], 2)]) }; Re._withStripped = !0; const De = a({ render: Re, staticRenderFns: [] }, function (e) { e && e('data-v-69241e60_0', { source: '.dv-decoration-1 {\n  width: 100%;\n  height: 100%;\n}\n.dv-decoration-1 svg {\n  transform-origin: left top;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,0BAA0B;AAC5B', file: 'main.vue', sourcesContent: ['.dv-decoration-1 {\n  width: 100%;\n  height: 100%;\n}\n.dv-decoration-1 svg {\n  transform-origin: left top;\n}\n'] }, media: void 0 }) }, Fe, void 0, !1, void 0, d, void 0); function Ge (e) { e.component(De.name, De) } const ze = { name: 'DvDecoration2', mixins: [r], props: { color: { type: Array, default: () => [] }, reverse: { type: Boolean, default: !1 } }, data: () => ({ ref: 'decoration-2', x: 0, y: 0, w: 0, h: 0, defaultColor: ['#3faacb', '#fff'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() }, reverse () { const { calcSVGData: e } = this; e() } }, methods: { afterAutoResizeMixinInit () { const { calcSVGData: e } = this; e() }, calcSVGData () { const { reverse: e, width: t, height: n } = this; e ? (this.w = 1, this.h = n, this.x = t / 2, this.y = 0) : (this.w = t, this.h = 1, this.x = 0, this.y = n / 2) }, onResize () { const { calcSVGData: e } = this; e() }, mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const Te = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-decoration-2' }, [n('svg', { attrs: { width: e.width + 'px', height: e.height + 'px' } }, [n('rect', { attrs: { x: e.x, y: e.y, width: e.w, height: e.h, fill: e.mergedColor[0] } }, [n('animate', { attrs: { attributeName: e.reverse ? 'height' : 'width', from: '0', to: e.reverse ? e.height : e.width, dur: '6s', calcMode: 'spline', keyTimes: '0;1', keySplines: '.42,0,.58,1', repeatCount: 'indefinite' } })]), e._v(' '), n('rect', { attrs: { x: e.x, y: e.y, width: '1', height: '1', fill: e.mergedColor[1] } }, [n('animate', { attrs: { attributeName: e.reverse ? 'y' : 'x', from: '0', to: e.reverse ? e.height : e.width, dur: '6s', calcMode: 'spline', keyTimes: '0;1', keySplines: '0.42,0,0.58,1', repeatCount: 'indefinite' } })])])]) }; Te._withStripped = !0; const Ye = a({ render: Te, staticRenderFns: [] }, function (e) { e && e('data-v-a2b21eaa_0', { source: '.dv-decoration-2 {\n  display: flex;\n  width: 100%;\n  height: 100%;\n  justify-content: center;\n  align-items: center;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,aAAa;EACb,WAAW;EACX,YAAY;EACZ,uBAAuB;EACvB,mBAAmB;AACrB', file: 'main.vue', sourcesContent: ['.dv-decoration-2 {\n  display: flex;\n  width: 100%;\n  height: 100%;\n  justify-content: center;\n  align-items: center;\n}\n'] }, media: void 0 }) }, ze, void 0, !1, void 0, d, void 0); function Ne (e) { e.component(Ye.name, Ye) } const $e = { name: 'DvDecoration3', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'decoration-3', svgWH: [300, 35], svgScale: [1, 1], rowNum: 2, rowPoints: 25, pointSideLength: 7, halfPointSideLength: 3.5, points: [], defaultColor: ['#7acaec', 'transparent'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { afterAutoResizeMixinInit () { const { calcSVGData: e } = this; e() }, calcSVGData () { const { calcPointsPosition: e, calcScale: t } = this; e(), t() }, calcPointsPosition () { const { svgWH: e, rowNum: t, rowPoints: n } = this; const [r, i] = e; const o = r / (n + 1); const a = i / (t + 1); const s = new Array(t).fill(0).map((e, t) => new Array(n).fill(0).map((e, n) => [o * (n + 1), a * (t + 1)])); this.points = s.reduce((e, t) => [...e, ...t], []) }, calcScale () { const { width: e, height: t, svgWH: n } = this; const [r, i] = n; this.svgScale = [e / r, t / i] }, onResize () { const { calcSVGData: e } = this; e() }, mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const Xe = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-decoration-3' }, [n('svg', { style: 'transform:scale(' + e.svgScale[0] + ',' + e.svgScale[1] + ');', attrs: { width: e.svgWH[0] + 'px', height: e.svgWH[1] + 'px' } }, [e._l(e.points, function (t, r) { return [n('rect', { key: r, attrs: { fill: e.mergedColor[0], x: t[0] - e.halfPointSideLength, y: t[1] - e.halfPointSideLength, width: e.pointSideLength, height: e.pointSideLength } }, [Math.random() > 0.6 ? n('animate', { attrs: { attributeName: 'fill', values: '' + e.mergedColor.join(';'), dur: Math.random() + 1 + 's', begin: 2 * Math.random(), repeatCount: 'indefinite' } }) : e._e()])] })], 2)]) }; Xe._withStripped = !0; const Qe = a({ render: Xe, staticRenderFns: [] }, function (e) { e && e('data-v-2cd3ac93_0', { source: '.dv-decoration-3 {\n  width: 100%;\n  height: 100%;\n}\n.dv-decoration-3 svg {\n  transform-origin: left top;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,0BAA0B;AAC5B', file: 'main.vue', sourcesContent: ['.dv-decoration-3 {\n  width: 100%;\n  height: 100%;\n}\n.dv-decoration-3 svg {\n  transform-origin: left top;\n}\n'] }, media: void 0 }) }, $e, void 0, !1, void 0, d, void 0); function He (e) { e.component(Qe.name, Qe) } const Ue = { name: 'DvDecoration4', mixins: [r], props: { color: { type: Array, default: () => [] }, reverse: { type: Boolean, default: !1 } }, data: () => ({ ref: 'decoration-4', defaultColor: ['rgba(255, 255, 255, 0.3)', 'rgba(255, 255, 255, 0.3)'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const Ve = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-decoration-4' }, [n('div', { class: 'container ' + (e.reverse ? 'reverse' : 'normal'), style: e.reverse ? 'width:' + e.width + 'px;height:5px' : 'width:5px;height:' + e.height + 'px;' }, [n('svg', { attrs: { width: e.reverse ? e.width : 5, height: e.reverse ? 5 : e.height } }, [n('polyline', { attrs: { stroke: e.mergedColor[0], points: e.reverse ? '0, 2.5 ' + e.width + ', 2.5' : '2.5, 0 2.5, ' + e.height } }), e._v(' '), n('polyline', { staticClass: 'bold-line', attrs: { stroke: e.mergedColor[1], 'stroke-width': '3', 'stroke-dasharray': '20, 80', 'stroke-dashoffset': '-30', points: e.reverse ? '0, 2.5 ' + e.width + ', 2.5' : '2.5, 0 2.5, ' + e.height } })])])]) }; Ve._withStripped = !0; const qe = a({ render: Ve, staticRenderFns: [] }, function (e) { e && e('data-v-41fd2a74_0', { source: '.dv-decoration-4 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-decoration-4 .container {\n  display: flex;\n  overflow: hidden;\n  position: absolute;\n}\n.dv-decoration-4 .normal {\n  height: 0% !important;\n  animation: ani-height 3s ease-in-out infinite;\n  left: 50%;\n  margin-left: -2px;\n}\n.dv-decoration-4 .reverse {\n  width: 0% !important;\n  animation: ani-width 3s ease-in-out infinite;\n  top: 50%;\n  margin-top: -2px;\n}\n@keyframes ani-height {\n70% {\n    height: 100%;\n}\n100% {\n    height: 100%;\n}\n}\n@keyframes ani-width {\n70% {\n    width: 100%;\n}\n100% {\n    width: 100%;\n}\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,aAAa;EACb,gBAAgB;EAChB,kBAAkB;AACpB;AACA;EACE,qBAAqB;EACrB,6CAA6C;EAC7C,SAAS;EACT,iBAAiB;AACnB;AACA;EACE,oBAAoB;EACpB,4CAA4C;EAC5C,QAAQ;EACR,gBAAgB;AAClB;AACA;AACE;IACE,YAAY;AACd;AACA;IACE,YAAY;AACd;AACF;AACA;AACE;IACE,WAAW;AACb;AACA;IACE,WAAW;AACb;AACF', file: 'main.vue', sourcesContent: ['.dv-decoration-4 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-decoration-4 .container {\n  display: flex;\n  overflow: hidden;\n  position: absolute;\n}\n.dv-decoration-4 .normal {\n  height: 0% !important;\n  animation: ani-height 3s ease-in-out infinite;\n  left: 50%;\n  margin-left: -2px;\n}\n.dv-decoration-4 .reverse {\n  width: 0% !important;\n  animation: ani-width 3s ease-in-out infinite;\n  top: 50%;\n  margin-top: -2px;\n}\n@keyframes ani-height {\n  70% {\n    height: 100%;\n  }\n  100% {\n    height: 100%;\n  }\n}\n@keyframes ani-width {\n  70% {\n    width: 100%;\n  }\n  100% {\n    width: 100%;\n  }\n}\n'] }, media: void 0 }) }, Ue, void 0, !1, void 0, d, void 0); function Ze (e) { e.component(qe.name, qe) } const Ke = { name: 'DvDecoration5', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'decoration-5', line1Points: '', line2Points: '', line1Length: 0, line2Length: 0, defaultColor: ['#3f96a5', '#3f96a5'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { afterAutoResizeMixinInit () { const { calcSVGData: e } = this; e() }, calcSVGData () { const { width: e, height: t } = this; let n = [[0, 0.2 * t], [0.18 * e, 0.2 * t], [0.2 * e, 0.4 * t], [0.25 * e, 0.4 * t], [0.27 * e, 0.6 * t], [0.72 * e, 0.6 * t], [0.75 * e, 0.4 * t], [0.8 * e, 0.4 * t], [0.82 * e, 0.2 * t], [e, 0.2 * t]]; let r = [[0.3 * e, 0.8 * t], [0.7 * e, 0.8 * t]]; const i = j(n); const o = j(r); n = n.map(e => e.join(',')).join(' '), r = r.map(e => e.join(',')).join(' '), this.line1Points = n, this.line2Points = r, this.line1Length = i, this.line2Length = o }, onResize () { const { calcSVGData: e } = this; e() }, mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const Je = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-decoration-5' }, [n('svg', { attrs: { width: e.width, height: e.height } }, [n('polyline', { attrs: { fill: 'transparent', stroke: e.mergedColor[0], 'stroke-width': '3', points: e.line1Points } }, [n('animate', { attrs: { attributeName: 'stroke-dasharray', attributeType: 'XML', from: '0, ' + e.line1Length / 2 + ', 0, ' + e.line1Length / 2, to: '0, 0, ' + e.line1Length + ', 0', dur: '1.2s', begin: '0s', calcMode: 'spline', keyTimes: '0;1', keySplines: '0.4,1,0.49,0.98', repeatCount: 'indefinite' } })]), e._v(' '), n('polyline', { attrs: { fill: 'transparent', stroke: e.mergedColor[1], 'stroke-width': '2', points: e.line2Points } }, [n('animate', { attrs: { attributeName: 'stroke-dasharray', attributeType: 'XML', from: '0, ' + e.line2Length / 2 + ', 0, ' + e.line2Length / 2, to: '0, 0, ' + e.line2Length + ', 0', dur: '1.2s', begin: '0s', calcMode: 'spline', keyTimes: '0;1', keySplines: '.4,1,.49,.98', repeatCount: 'indefinite' } })])])]) }; Je._withStripped = !0; const et = a({ render: Je, staticRenderFns: [] }, function (e) { e && e('data-v-301d5bb4_0', { source: '.dv-decoration-5 {\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-decoration-5 {\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, Ke, void 0, !1, void 0, d, void 0); function tt (e) { e.component(et.name, et) } const nt = { name: 'DvDecoration6', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'decoration-6', svgWH: [300, 35], svgScale: [1, 1], rowNum: 1, rowPoints: 40, rectWidth: 7, halfRectWidth: 3.5, points: [], heights: [], minHeights: [], randoms: [], defaultColor: ['#7acaec', '#7acaec'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { afterAutoResizeMixinInit () { const { calcSVGData: e } = this; e() }, calcSVGData () { const { calcPointsPosition: e, calcScale: t } = this; e(), t() }, calcPointsPosition () { const { svgWH: e, rowNum: n, rowPoints: r } = this; const [i, o] = e; const a = i / (r + 1); const s = o / (n + 1); const l = new Array(n).fill(0).map((e, t) => new Array(r).fill(0).map((e, n) => [a * (n + 1), s * (t + 1)])); this.points = l.reduce((e, t) => [...e, ...t], []); const d = this.heights = new Array(n * r).fill(0).map(e => Math.random() > 0.8 ? t(0.7 * o, o) : t(0.2 * o, 0.5 * o)); this.minHeights = new Array(n * r).fill(0).map((e, t) => d[t] * Math.random()), this.randoms = new Array(n * r).fill(0).map(e => Math.random() + 1.5) }, calcScale () { const { width: e, height: t, svgWH: n } = this; const [r, i] = n; this.svgScale = [e / r, t / i] }, onResize () { const { calcSVGData: e } = this; e() }, mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const rt = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-decoration-6' }, [n('svg', { style: 'transform:scale(' + e.svgScale[0] + ',' + e.svgScale[1] + ');', attrs: { width: e.svgWH[0] + 'px', height: e.svgWH[1] + 'px' } }, [e._l(e.points, function (t, r) { return [n('rect', { key: r, attrs: { fill: e.mergedColor[Math.random() > 0.5 ? 0 : 1], x: t[0] - e.halfRectWidth, y: t[1] - e.heights[r] / 2, width: e.rectWidth, height: e.heights[r] } }, [n('animate', { attrs: { attributeName: 'y', values: t[1] - e.minHeights[r] / 2 + ';' + (t[1] - e.heights[r] / 2) + ';' + (t[1] - e.minHeights[r] / 2), dur: e.randoms[r] + 's', keyTimes: '0;0.5;1', calcMode: 'spline', keySplines: '0.42,0,0.58,1;0.42,0,0.58,1', begin: '0s', repeatCount: 'indefinite' } }), e._v(' '), n('animate', { attrs: { attributeName: 'height', values: e.minHeights[r] + ';' + e.heights[r] + ';' + e.minHeights[r], dur: e.randoms[r] + 's', keyTimes: '0;0.5;1', calcMode: 'spline', keySplines: '0.42,0,0.58,1;0.42,0,0.58,1', begin: '0s', repeatCount: 'indefinite' } })])] })], 2)]) }; rt._withStripped = !0; const it = a({ render: rt, staticRenderFns: [] }, function (e) { e && e('data-v-a29c4fc2_0', { source: '.dv-decoration-6 {\n  width: 100%;\n  height: 100%;\n}\n.dv-decoration-6 svg {\n  transform-origin: left top;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,0BAA0B;AAC5B', file: 'main.vue', sourcesContent: ['.dv-decoration-6 {\n  width: 100%;\n  height: 100%;\n}\n.dv-decoration-6 svg {\n  transform-origin: left top;\n}\n'] }, media: void 0 }) }, nt, void 0, !1, void 0, d, void 0); function ot (e) { e.component(it.name, it) } const at = { name: 'DvDecoration7', props: { color: { type: Array, default: () => [] } }, data: () => ({ defaultColor: ['#1dc1f5', '#1dc1f5'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const st = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { staticClass: 'dv-decoration-7' }, [n('svg', { attrs: { width: '21px', height: '20px' } }, [n('polyline', { attrs: { 'stroke-width': '4', fill: 'transparent', stroke: e.mergedColor[0], points: '10, 0 19, 10 10, 20' } }), e._v(' '), n('polyline', { attrs: { 'stroke-width': '2', fill: 'transparent', stroke: e.mergedColor[1], points: '2, 0 11, 10 2, 20' } })]), e._v(' '), e._t('default'), e._v(' '), n('svg', { attrs: { width: '21px', height: '20px' } }, [n('polyline', { attrs: { 'stroke-width': '4', fill: 'transparent', stroke: e.mergedColor[0], points: '11, 0 2, 10 11, 20' } }), e._v(' '), n('polyline', { attrs: { 'stroke-width': '2', fill: 'transparent', stroke: e.mergedColor[1], points: '19, 0 10, 10 19, 20' } })])], 2) }; st._withStripped = !0; const lt = a({ render: st, staticRenderFns: [] }, function (e) { e && e('data-v-b84d1f12_0', { source: '.dv-decoration-7 {\n  display: flex;\n  width: 100%;\n  height: 100%;\n  justify-content: center;\n  align-items: center;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,aAAa;EACb,WAAW;EACX,YAAY;EACZ,uBAAuB;EACvB,mBAAmB;AACrB', file: 'main.vue', sourcesContent: ['.dv-decoration-7 {\n  display: flex;\n  width: 100%;\n  height: 100%;\n  justify-content: center;\n  align-items: center;\n}\n'] }, media: void 0 }) }, at, void 0, !1, void 0, d, void 0); function dt (e) { e.component(lt.name, lt) } const ct = { name: 'DvDecoration8', mixins: [r], props: { color: { type: Array, default: () => [] }, reverse: { type: Boolean, default: !1 } }, data: () => ({ ref: 'decoration-8', defaultColor: ['#3f96a5', '#3f96a5'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { xPos (e) { const { reverse: t, width: n } = this; return t ? n - e : e }, mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const ut = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-decoration-8' }, [n('svg', { attrs: { width: e.width, height: e.height } }, [n('polyline', { attrs: { stroke: e.mergedColor[0], 'stroke-width': '2', fill: 'transparent', points: e.xPos(0) + ', 0 ' + e.xPos(30) + ', ' + e.height / 2 } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], 'stroke-width': '2', fill: 'transparent', points: e.xPos(20) + ', 0 ' + e.xPos(50) + ', ' + e.height / 2 + ' ' + e.xPos(e.width) + ', ' + e.height / 2 } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[1], fill: 'transparent', 'stroke-width': '3', points: e.xPos(0) + ', ' + (e.height - 3) + ', ' + e.xPos(200) + ', ' + (e.height - 3) } })])]) }; ut._withStripped = !0; const ft = a({ render: ut, staticRenderFns: [] }, function (e) { e && e('data-v-53cf43a5_0', { source: '.dv-decoration-8 {\n  display: flex;\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,aAAa;EACb,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-decoration-8 {\n  display: flex;\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, ct, void 0, !1, void 0, d, void 0); function ht (e) { e.component(ft.name, ft) } const pt = { name: 'DvDecoration9', mixins: [r], props: { color: { type: Array, default: () => [] }, dur: { type: Number, default: 3 } }, data: () => ({ ref: 'decoration-9', polygonId: `decoration-9-polygon-${Date.now()}`, svgWH: [100, 100], svgScale: [1, 1], defaultColor: ['rgba(3, 166, 224, 0.8)', 'rgba(3, 166, 224, 0.5)'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { afterAutoResizeMixinInit () { const { calcScale: e } = this; e() }, calcScale () { const { width: e, height: t, svgWH: n } = this; const [r, i] = n; this.svgScale = [e / r, t / i] }, onResize () { const { calcScale: e } = this; e() }, mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) }, fade: we }, mounted () { const { mergeColor: e } = this; e() } }; const gt = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-decoration-9' }, [n('svg', { style: 'transform:scale(' + e.svgScale[0] + ',' + e.svgScale[1] + ');', attrs: { width: e.svgWH[0] + 'px', height: e.svgWH[1] + 'px' } }, [n('defs', [n('polygon', { attrs: { id: e.polygonId, points: '15, 46.5, 21, 47.5, 21, 52.5, 15, 53.5' } })]), e._v(' '), n('circle', { attrs: { cx: '50', cy: '50', r: '45', fill: 'transparent', stroke: e.mergedColor[1], 'stroke-width': '10', 'stroke-dasharray': '80, 100, 30, 100' } }, [n('animateTransform', { attrs: { attributeName: 'transform', type: 'rotate', values: '0 50 50;360 50 50', dur: e.dur + 's', repeatCount: 'indefinite' } })], 1), e._v(' '), n('circle', { attrs: { cx: '50', cy: '50', r: '45', fill: 'transparent', stroke: e.mergedColor[0], 'stroke-width': '6', 'stroke-dasharray': '50, 66, 100, 66' } }, [n('animateTransform', { attrs: { attributeName: 'transform', type: 'rotate', values: '0 50 50;-360 50 50', dur: e.dur + 's', repeatCount: 'indefinite' } })], 1), e._v(' '), n('circle', { attrs: { cx: '50', cy: '50', r: '38', fill: 'transparent', stroke: e.fade(e.mergedColor[1] || e.defaultColor[1], 30), 'stroke-width': '1', 'stroke-dasharray': '5, 1' } }), e._v(' '), e._l(new Array(20).fill(0), function (t, r) { return n('use', { key: r, attrs: { 'xlink:href': '#' + e.polygonId, stroke: e.mergedColor[1], fill: Math.random() > 0.4 ? 'transparent' : e.mergedColor[0] } }, [n('animateTransform', { attrs: { attributeName: 'transform', type: 'rotate', values: '0 50 50;360 50 50', dur: e.dur + 's', begin: r * e.dur / 20 + 's', repeatCount: 'indefinite' } })], 1) }), e._v(' '), n('circle', { attrs: { cx: '50', cy: '50', r: '26', fill: 'transparent', stroke: e.fade(e.mergedColor[1] || e.defaultColor[1], 30), 'stroke-width': '1', 'stroke-dasharray': '5, 1' } })], 2), e._v(' '), e._t('default')], 2) }; gt._withStripped = !0; const vt = a({ render: gt, staticRenderFns: [] }, function (e) { e && e('data-v-06b2e4f5_0', { source: '.dv-decoration-9 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.dv-decoration-9 svg {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  transform-origin: left top;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,uBAAuB;AACzB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,0BAA0B;AAC5B', file: 'main.vue', sourcesContent: ['.dv-decoration-9 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.dv-decoration-9 svg {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  transform-origin: left top;\n}\n'] }, media: void 0 }) }, pt, void 0, !1, void 0, d, void 0); function mt (e) { e.component(vt.name, vt) } const At = { name: 'DvDecoration10', mixins: [r], props: { color: { type: Array, default: () => [] } }, data () { const e = Date.now(); return { ref: 'decoration-10', animationId1: `d10ani1${e}`, animationId2: `d10ani2${e}`, animationId3: `d10ani3${e}`, animationId4: `d10ani4${e}`, animationId5: `d10ani5${e}`, animationId6: `d10ani6${e}`, animationId7: `d10ani7${e}`, defaultColor: ['#00c2ff', 'rgba(0, 194, 255, 0.3)'], mergedColor: [] } }, watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) } }, mounted () { const { mergeColor: e } = this; e() } }; const Ct = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-decoration-10' }, [n('svg', { attrs: { width: e.width, height: e.height } }, [n('polyline', { attrs: { stroke: e.mergedColor[1], 'stroke-width': '2', points: '0, ' + e.height / 2 + ' ' + e.width + ', ' + e.height / 2 } }), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], 'stroke-width': '2', points: '5, ' + e.height / 2 + ' ' + (0.2 * e.width - 3) + ', ' + e.height / 2, 'stroke-dasharray': '0, ' + 0.2 * e.width, fill: 'freeze' } }, [n('animate', { attrs: { id: e.animationId2, attributeName: 'stroke-dasharray', values: '0, ' + 0.2 * e.width + ';' + 0.2 * e.width + ', 0;', dur: '3s', begin: e.animationId1 + '.end', fill: 'freeze' } }), e._v(' '), n('animate', { attrs: { attributeName: 'stroke-dasharray', values: 0.2 * e.width + ', 0;0, ' + 0.2 * e.width, dur: '0.01s', begin: e.animationId7 + '.end', fill: 'freeze' } })]), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], 'stroke-width': '2', points: 0.2 * e.width + 3 + ', ' + e.height / 2 + ' ' + (0.8 * e.width - 3) + ', ' + e.height / 2, 'stroke-dasharray': '0, ' + 0.6 * e.width } }, [n('animate', { attrs: { id: e.animationId4, attributeName: 'stroke-dasharray', values: '0, ' + 0.6 * e.width + ';' + 0.6 * e.width + ', 0', dur: '3s', begin: e.animationId3 + '.end + 1s', fill: 'freeze' } }), e._v(' '), n('animate', { attrs: { attributeName: 'stroke-dasharray', values: 0.6 * e.width + ', 0;0, ' + 0.6 * e.width, dur: '0.01s', begin: e.animationId7 + '.end', fill: 'freeze' } })]), e._v(' '), n('polyline', { attrs: { stroke: e.mergedColor[0], 'stroke-width': '2', points: 0.8 * e.width + 3 + ', ' + e.height / 2 + ' ' + (e.width - 5) + ', ' + e.height / 2, 'stroke-dasharray': '0, ' + 0.2 * e.width } }, [n('animate', { attrs: { id: e.animationId6, attributeName: 'stroke-dasharray', values: '0, ' + 0.2 * e.width + ';' + 0.2 * e.width + ', 0', dur: '3s', begin: e.animationId5 + '.end + 1s', fill: 'freeze' } }), e._v(' '), n('animate', { attrs: { attributeName: 'stroke-dasharray', values: 0.2 * e.width + ', 0;0, ' + 0.3 * e.width, dur: '0.01s', begin: e.animationId7 + '.end', fill: 'freeze' } })]), e._v(' '), n('circle', { attrs: { cx: '2', cy: e.height / 2, r: '2', fill: e.mergedColor[1] } }, [n('animate', { attrs: { id: e.animationId1, attributeName: 'fill', values: e.mergedColor[1] + ';' + e.mergedColor[0], begin: '0s;' + e.animationId7 + '.end', dur: '0.3s', fill: 'freeze' } })]), e._v(' '), n('circle', { attrs: { cx: 0.2 * e.width, cy: e.height / 2, r: '2', fill: e.mergedColor[1] } }, [n('animate', { attrs: { id: e.animationId3, attributeName: 'fill', values: e.mergedColor[1] + ';' + e.mergedColor[0], begin: e.animationId2 + '.end', dur: '0.3s', fill: 'freeze' } }), e._v(' '), n('animate', { attrs: { attributeName: 'fill', values: e.mergedColor[1] + ';' + e.mergedColor[1], dur: '0.01s', begin: e.animationId7 + '.end', fill: 'freeze' } })]), e._v(' '), n('circle', { attrs: { cx: 0.8 * e.width, cy: e.height / 2, r: '2', fill: e.mergedColor[1] } }, [n('animate', { attrs: { id: e.animationId5, attributeName: 'fill', values: e.mergedColor[1] + ';' + e.mergedColor[0], begin: e.animationId4 + '.end', dur: '0.3s', fill: 'freeze' } }), e._v(' '), n('animate', { attrs: { attributeName: 'fill', values: e.mergedColor[1] + ';' + e.mergedColor[1], dur: '0.01s', begin: e.animationId7 + '.end', fill: 'freeze' } })]), e._v(' '), n('circle', { attrs: { cx: e.width - 2, cy: e.height / 2, r: '2', fill: e.mergedColor[1] } }, [n('animate', { attrs: { id: e.animationId7, attributeName: 'fill', values: e.mergedColor[1] + ';' + e.mergedColor[0], begin: e.animationId6 + '.end', dur: '0.3s', fill: 'freeze' } }), e._v(' '), n('animate', { attrs: { attributeName: 'fill', values: e.mergedColor[1] + ';' + e.mergedColor[1], dur: '0.01s', begin: e.animationId7 + '.end', fill: 'freeze' } })])])]) }; Ct._withStripped = !0; const bt = a({ render: Ct, staticRenderFns: [] }, function (e) { e && e('data-v-39f9e4a4_0', { source: '.dv-decoration-10 {\n  width: 100%;\n  height: 100%;\n  display: flex;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,WAAW;EACX,YAAY;EACZ,aAAa;AACf', file: 'main.vue', sourcesContent: ['.dv-decoration-10 {\n  width: 100%;\n  height: 100%;\n  display: flex;\n}\n'] }, media: void 0 }) }, At, void 0, !1, void 0, d, void 0); function yt (e) { e.component(bt.name, bt) } const xt = { name: 'DvDecoration11', mixins: [r], props: { color: { type: Array, default: () => [] } }, data: () => ({ ref: 'decoration-11', defaultColor: ['#1a98fc', '#2cf7fe'], mergedColor: [] }), watch: { color () { const { mergeColor: e } = this; e() } }, methods: { mergeColor () { const { color: e, defaultColor: t } = this; this.mergedColor = L(I(t, !0), e || []) }, fade: we }, mounted () { const { mergeColor: e } = this; e() } }; const wt = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-decoration-11' }, [n('svg', { attrs: { width: e.width, height: e.height } }, [n('polygon', { attrs: { fill: e.fade(e.mergedColor[1] || e.defaultColor[1], 10), stroke: e.mergedColor[1], points: '20 10, 25 4, 55 4 60 10' } }), e._v(' '), n('polygon', { attrs: { fill: e.fade(e.mergedColor[1] || e.defaultColor[1], 10), stroke: e.mergedColor[1], points: '20 ' + (e.height - 10) + ', 25 ' + (e.height - 4) + ', 55 ' + (e.height - 4) + ' 60 ' + (e.height - 10) } }), e._v(' '), n('polygon', { attrs: { fill: e.fade(e.mergedColor[1] || e.defaultColor[1], 10), stroke: e.mergedColor[1], points: e.width - 20 + ' 10, ' + (e.width - 25) + ' 4, ' + (e.width - 55) + ' 4 ' + (e.width - 60) + ' 10' } }), e._v(' '), n('polygon', { attrs: { fill: e.fade(e.mergedColor[1] || e.defaultColor[1], 10), stroke: e.mergedColor[1], points: e.width - 20 + ' ' + (e.height - 10) + ', ' + (e.width - 25) + ' ' + (e.height - 4) + ', ' + (e.width - 55) + ' ' + (e.height - 4) + ' ' + (e.width - 60) + ' ' + (e.height - 10) } }), e._v(' '), n('polygon', { attrs: { fill: e.fade(e.mergedColor[0] || e.defaultColor[0], 20), stroke: e.mergedColor[0], points: '\n        20 10, 5 ' + e.height / 2 + ' 20 ' + (e.height - 10) + '\n        ' + (e.width - 20) + ' ' + (e.height - 10) + ' ' + (e.width - 5) + ' ' + e.height / 2 + ' ' + (e.width - 20) + ' 10\n      ' } }), e._v(' '), n('polyline', { attrs: { fill: 'transparent', stroke: e.fade(e.mergedColor[0] || e.defaultColor[0], 70), points: '25 18, 15 ' + e.height / 2 + ' 25 ' + (e.height - 18) } }), e._v(' '), n('polyline', { attrs: { fill: 'transparent', stroke: e.fade(e.mergedColor[0] || e.defaultColor[0], 70), points: e.width - 25 + ' 18, ' + (e.width - 15) + ' ' + e.height / 2 + ' ' + (e.width - 25) + ' ' + (e.height - 18) } })]), e._v(' '), n('div', { staticClass: 'decoration-content' }, [e._t('default')], 2)]) }; wt._withStripped = !0; const Et = a({ render: wt, staticRenderFns: [] }, function (e) { e && e('data-v-70e8e39a_0', { source: '.dv-decoration-11 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  display: flex;\n}\n.dv-decoration-11 .decoration-content {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,aAAa;AACf;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,WAAW;EACX,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,uBAAuB;AACzB', file: 'main.vue', sourcesContent: ['.dv-decoration-11 {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  display: flex;\n}\n.dv-decoration-11 .decoration-content {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n'] }, media: void 0 }) }, xt, void 0, !1, void 0, d, void 0); function kt (e) { e.component(Et.name, Et) } const Bt = function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') }; const Pt = function (e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e }; const _t = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.bezierCurveToPolyline = p, t.getBezierCurveLength = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5; if (!e) return console.error('getBezierCurveLength: Missing parameters!'), !1; if (!(e instanceof Array)) return console.error('getBezierCurveLength: Parameter bezierCurve must be an array!'), !1; if (typeof t !== 'number') return console.error('getBezierCurveLength: Parameter precision must be a number!'), !1; return u(f([d(e, t).segmentPoints])[0]) }, t.default = void 0; const n = b(S); const r = b(E); const i = Math.sqrt; const o = Math.pow; const a = Math.ceil; const s = Math.abs; const l = 50; function d (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5; const n = e.length - 1; const i = e[0]; const o = e[n][2]; const d = e.slice(1); const p = d.map(function (e, t) { const n = t === 0 ? i : d[t - 1][2]; return c.apply(void 0, [n].concat((0, r.default)(e))) }); const g = (function (e, t, n, r) { let i = 4; let o = 1; const l = function () { let l = e.reduce(function (e, t) { return e + t.length }, 0); e.forEach(function (e, t) { return e.push(n[t][2]) }); let d = f(e); let c = d.reduce(function (e, t) { return e + t.length }, 0); let p = d.map(function (e) { return u(e) }); let g = u(p); let v = g / c; if ((function (e, t) { return e.map(function (e) { return e.map(function (e) { return s(e - t) }) }).map(function (e) { return u(e) }).reduce(function (e, t) { return e + t }, 0) }(d, v)) <= r) return 'break'; l = a(v / r * l * 1.1); const m = p.map(function (e) { return a(e / g * l) }); e = h(t, m), l = e.reduce(function (e, t) { return e + t.length }, 0); const A = JSON.parse(JSON.stringify(e)); A.forEach(function (e, t) { return e.push(n[t][2]) }), c = (d = f(A)).reduce(function (e, t) { return e + t.length }, 0), p = d.map(function (e) { return u(e) }), g = u(p), v = g / c; const C = 1 / l / 10; t.forEach(function (t, n) { for (let r = m[n], o = new Array(r).fill('').map(function (e, t) { return t / m[n] }), a = 0; a < i; a++) for (let s = f([e[n]])[0].map(function (e) { return e - v }), l = 0, d = 0; d < r; d++) { if (d === 0) return; l += s[d - 1], o[d] -= C * l, o[d] > 1 && (o[d] = 1), o[d] < 0 && (o[d] = 0), e[n][d] = t(o[d]) } }), i *= 4, o++ }; do { if (l() === 'break') break } while (i <= 1025); return { segmentPoints: e = e.reduce(function (e, t) { return e.concat(t) }, []), cycles: o, rounds: i } }(h(p, new Array(n).fill(l)), p, d, t)); return g.segmentPoints.push(o), g } function c (e, t, n, r) { return function (i) { const a = 1 - i; const s = o(a, 3); const l = o(a, 2); const d = o(i, 3); const c = o(i, 2); return [e[0] * s + 3 * t[0] * i * l + 3 * n[0] * c * a + r[0] * d, e[1] * s + 3 * t[1] * i * l + 3 * n[1] * c * a + r[1] * d] } } function u (e) { return e.reduce(function (e, t) { return e + t }, 0) } function f (e) { return e.map(function (e, t) { return new Array(e.length - 1).fill(0).map(function (t, r) { return a = e[r], s = e[r + 1], l = (0, n.default)(a, 2), d = l[0], c = l[1], u = (0, n.default)(s, 2), f = u[0], h = u[1], i(o(d - f, 2) + o(c - h, 2)); let a, s, l, d, c, u, f, h }) }) } function h (e, t) { return e.map(function (e, n) { const r = 1 / t[n]; return new Array(t[n]).fill('').map(function (t, n) { return e(n * r) }) }) } function p (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5; return e ? e instanceof Array ? typeof t !== 'number' ? (console.error('bezierCurveToPolyline: Parameter precision must be a number!'), !1) : d(e, t).segmentPoints : (console.error('bezierCurveToPolyline: Parameter bezierCurve must be an array!'), !1) : (console.error('bezierCurveToPolyline: Missing parameters!'), !1) } const g = p; t.default = g }); A(_t); _t.bezierCurveToPolyline, _t.getBezierCurveLength; const St = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.default = void 0; const n = b(S); const r = b(E); function i (e, t) { const r = (0, n.default)(e, 2); const i = r[0]; const o = r[1]; const a = (0, n.default)(t, 2); const s = a[0]; const l = a[1]; return [s + (s - i), l + (l - o)] } const o = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0.25; const o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.25; if (!(e instanceof Array)) return console.error('polylineToBezierCurve: Parameter polyline must be an array!'), !1; if (e.length <= 2) return console.error('polylineToBezierCurve: Converting to a curve requires at least 3 points!'), !1; const a = e[0]; const s = e.length - 1; const l = new Array(s).fill(0).map(function (i, a) { return [].concat((0, r.default)(function (e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.25; const i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0.25; const o = e.length; if (o < 3 || t >= o) return; let a = t - 1; a < 0 && (a = n ? o + a : 0); let s = t + 1; s >= o && (s = n ? s - o : o - 1); let l = t + 2; l >= o && (l = n ? l - o : o - 1); const d = e[a]; const c = e[t]; const u = e[s]; const f = e[l]; return [[c[0] + r * (u[0] - d[0]), c[1] + r * (u[1] - d[1])], [u[0] - i * (f[0] - c[0]), u[1] - i * (f[1] - c[1])]] }(e, a, t, n, o)), [e[a + 1]]) }); return t && (function (e, t) { const n = e[0]; const r = e.slice(-1)[0]; e.push([i(r[1], r[2]), i(n[0], t), t]) }(l, a)), l.unshift(e[0]), l }; t.default = o }); A(St); const Ot = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), Object.defineProperty(t, 'bezierCurveToPolyline', { enumerable: !0, get: function () { return _t.bezierCurveToPolyline } }), Object.defineProperty(t, 'getBezierCurveLength', { enumerable: !0, get: function () { return _t.getBezierCurveLength } }), Object.defineProperty(t, 'polylineToBezierCurve', { enumerable: !0, get: function () { return n.default } }), t.default = void 0; var n = b(St); const r = { bezierCurveToPolyline: _t.bezierCurveToPolyline, getBezierCurveLength: _t.getBezierCurveLength, polylineToBezierCurve: n.default }; t.default = r }); A(Ot); const It = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.drawPolylinePath = r, t.drawBezierCurvePath = i, t.default = void 0; const n = b(E); function r (e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; if (!e || t.length < 2) return !1; r && e.beginPath(), t.forEach(function (t, r) { return t && (r === 0 ? e.moveTo.apply(e, (0, n.default)(t)) : e.lineTo.apply(e, (0, n.default)(t))) }), i && e.closePath() } function i (e, t) { const r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; const o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; if (!e || !t) return !1; i && e.beginPath(), r && e.moveTo.apply(e, (0, n.default)(r)), t.forEach(function (t) { return t && e.bezierCurveTo.apply(e, (0, n.default)(t[0]).concat((0, n.default)(t[1]), (0, n.default)(t[2]))) }), o && e.closePath() } const o = { drawPolylinePath: r, drawBezierCurvePath: i }; t.default = o }); A(It); It.drawPolylinePath, It.drawBezierCurvePath; const Wt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.extendNewGraph = function (e, t) { if (!e || !t) return void console.error('ExtendNewGraph Missing Parameters!'); if (!t.shape) return void console.error('Required attribute of shape to extendNewGraph!'); if (!t.validator) return void console.error('Required function of validator to extendNewGraph!'); if (!t.draw) return void console.error('Required function of draw to extendNewGraph!'); A.set(e, t) }, t.default = t.text = t.bezierCurve = t.smoothline = t.polyline = t.regPolygon = t.sector = t.arc = t.ring = t.rect = t.ellipse = t.circle = void 0; const n = b(E); const r = b(S); const i = b(Ot); const o = i.default.polylineToBezierCurve; const a = i.default.bezierCurveToPolyline; const s = { shape: { rx: 0, ry: 0, r: 0 }, validator: function (e) { const t = e.shape; const n = t.rx; const r = t.ry; const i = t.r; return typeof n === 'number' && typeof r === 'number' && typeof i === 'number' || (console.error('Circle shape configuration is abnormal!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; n.beginPath(); const i = r.rx; const o = r.ry; const a = r.r; n.arc(i, o, a > 0 ? a : 0.01, 0, 2 * Math.PI), n.fill(), n.stroke(), n.closePath() }, hoverCheck: function (e, t) { const n = t.shape; const r = n.rx; const i = n.ry; const o = n.r; return (0, O.checkPointIsInCircle)(e, r, i, o) }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.rx; const o = n.ry; r.graphCenter = [i, o] }, move: function (e, t) { const n = e.movementX; const r = e.movementY; const i = t.shape; this.attr('shape', { rx: i.rx + n, ry: i.ry + r }) } }; t.circle = s; const l = { shape: { rx: 0, ry: 0, hr: 0, vr: 0 }, validator: function (e) { const t = e.shape; const n = t.rx; const r = t.ry; const i = t.hr; const o = t.vr; return typeof n === 'number' && typeof r === 'number' && typeof i === 'number' && typeof o === 'number' || (console.error('Ellipse shape configuration is abnormal!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; n.beginPath(); const i = r.rx; const o = r.ry; const a = r.hr; const s = r.vr; n.ellipse(i, o, a > 0 ? a : 0.01, s > 0 ? s : 0.01, 0, 0, 2 * Math.PI), n.fill(), n.stroke(), n.closePath() }, hoverCheck: function (e, t) { const n = t.shape; const r = n.rx; const i = n.ry; const o = n.hr; const a = n.vr; const s = Math.max(o, a); const l = Math.min(o, a); const d = Math.sqrt(s * s - l * l); const c = [r - d, i]; const u = [r + d, i]; return (0, O.getTwoPointDistance)(e, c) + (0, O.getTwoPointDistance)(e, u) <= 2 * s }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.rx; const o = n.ry; r.graphCenter = [i, o] }, move: function (e, t) { const n = e.movementX; const r = e.movementY; const i = t.shape; this.attr('shape', { rx: i.rx + n, ry: i.ry + r }) } }; t.ellipse = l; const d = { shape: { x: 0, y: 0, w: 0, h: 0 }, validator: function (e) { const t = e.shape; const n = t.x; const r = t.y; const i = t.w; const o = t.h; return typeof n === 'number' && typeof r === 'number' && typeof i === 'number' && typeof o === 'number' || (console.error('Rect shape configuration is abnormal!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; n.beginPath(); const i = r.x; const o = r.y; const a = r.w; const s = r.h; n.rect(i, o, a, s), n.fill(), n.stroke(), n.closePath() }, hoverCheck: function (e, t) { const n = t.shape; const r = n.x; const i = n.y; const o = n.w; const a = n.h; return (0, O.checkPointIsInRect)(e, r, i, o, a) }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.x; const o = n.y; const a = n.w; const s = n.h; r.graphCenter = [i + a / 2, o + s / 2] }, move: function (e, t) { const n = e.movementX; const r = e.movementY; const i = t.shape; this.attr('shape', { x: i.x + n, y: i.y + r }) } }; t.rect = d; const c = { shape: { rx: 0, ry: 0, r: 0 }, validator: function (e) { const t = e.shape; const n = t.rx; const r = t.ry; const i = t.r; return typeof n === 'number' && typeof r === 'number' && typeof i === 'number' || (console.error('Ring shape configuration is abnormal!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; n.beginPath(); const i = r.rx; const o = r.ry; const a = r.r; n.arc(i, o, a > 0 ? a : 0.01, 0, 2 * Math.PI), n.stroke(), n.closePath() }, hoverCheck: function (e, t) { const n = t.shape; const r = t.style; const i = n.rx; const o = n.ry; const a = n.r; const s = r.lineWidth / 2; const l = a - s; const d = a + s; const c = (0, O.getTwoPointDistance)(e, [i, o]); return c >= l && c <= d }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.rx; const o = n.ry; r.graphCenter = [i, o] }, move: function (e, t) { const n = e.movementX; const r = e.movementY; const i = t.shape; this.attr('shape', { rx: i.rx + n, ry: i.ry + r }) } }; t.ring = c; const u = { shape: { rx: 0, ry: 0, r: 0, startAngle: 0, endAngle: 0, clockWise: !0 }, validator: function (e) { const t = e.shape; return !['rx', 'ry', 'r', 'startAngle', 'endAngle'].find(function (e) { return typeof t[e] !== 'number' }) || (console.error('Arc shape configuration is abnormal!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; n.beginPath(); const i = r.rx; const o = r.ry; const a = r.r; const s = r.startAngle; const l = r.endAngle; const d = r.clockWise; n.arc(i, o, a > 0 ? a : 0.001, s, l, !d), n.stroke(), n.closePath() }, hoverCheck: function (e, t) { const n = t.shape; const r = t.style; const i = n.rx; const o = n.ry; const a = n.r; const s = n.startAngle; const l = n.endAngle; const d = n.clockWise; const c = r.lineWidth / 2; const u = a - c; const f = a + c; return !(0, O.checkPointIsInSector)(e, i, o, u, s, l, d) && (0, O.checkPointIsInSector)(e, i, o, f, s, l, d) }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.rx; const o = n.ry; r.graphCenter = [i, o] }, move: function (e, t) { const n = e.movementX; const r = e.movementY; const i = t.shape; this.attr('shape', { rx: i.rx + n, ry: i.ry + r }) } }; t.arc = u; const f = { shape: { rx: 0, ry: 0, r: 0, startAngle: 0, endAngle: 0, clockWise: !0 }, validator: function (e) { const t = e.shape; return !['rx', 'ry', 'r', 'startAngle', 'endAngle'].find(function (e) { return typeof t[e] !== 'number' }) || (console.error('Sector shape configuration is abnormal!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; n.beginPath(); const i = r.rx; const o = r.ry; const a = r.r; const s = r.startAngle; const l = r.endAngle; const d = r.clockWise; n.arc(i, o, a > 0 ? a : 0.01, s, l, !d), n.lineTo(i, o), n.closePath(), n.stroke(), n.fill() }, hoverCheck: function (e, t) { const n = t.shape; const r = n.rx; const i = n.ry; const o = n.r; const a = n.startAngle; const s = n.endAngle; const l = n.clockWise; return (0, O.checkPointIsInSector)(e, r, i, o, a, s, l) }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.rx; const o = n.ry; r.graphCenter = [i, o] }, move: function (e, t) { const n = e.movementX; const r = e.movementY; const i = t.shape; const o = i.rx; const a = i.ry; this.attr('shape', { rx: o + n, ry: a + r }) } }; t.sector = f; const h = { shape: { rx: 0, ry: 0, r: 0, side: 0 }, validator: function (e) { const t = e.shape; const n = t.side; return ['rx', 'ry', 'r', 'side'].find(function (e) { return typeof t[e] !== 'number' }) ? (console.error('RegPolygon shape configuration is abnormal!'), !1) : !(n < 3) || (console.error('RegPolygon at least trigon!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; const i = t.cache; n.beginPath(); const o = r.rx; const a = r.ry; const s = r.r; const l = r.side; if (!i.points || i.rx !== o || i.ry !== a || i.r !== s || i.side !== l) { const d = (0, O.getRegularPolygonPoints)(o, a, s, l); Object.assign(i, { points: d, rx: o, ry: a, r: s, side: l }) } const c = i.points; (0, It.drawPolylinePath)(n, c), n.closePath(), n.stroke(), n.fill() }, hoverCheck: function (e, t) { const n = t.cache.points; return (0, O.checkPointIsInPolygon)(e, n) }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.rx; const o = n.ry; r.graphCenter = [i, o] }, move: function (e, t) { const n = e.movementX; const i = e.movementY; const o = t.shape; const a = t.cache; const s = o.rx; const l = o.ry; a.rx += n, a.ry += i, this.attr('shape', { rx: s + n, ry: l + i }), a.points = a.points.map(function (e) { const t = (0, r.default)(e, 2); const o = t[0]; const a = t[1]; return [o + n, a + i] }) } }; t.regPolygon = h; const p = { shape: { points: [], close: !1 }, validator: function (e) { return e.shape.points instanceof Array || (console.error('Polyline points should be an array!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; const i = t.style.lineWidth; n.beginPath(); let o = r.points; const a = r.close; i === 1 && (o = (0, O.eliminateBlur)(o)), (0, It.drawPolylinePath)(n, o), a ? (n.closePath(), n.fill(), n.stroke()) : n.stroke() }, hoverCheck: function (e, t) { const n = t.shape; const r = t.style; const i = n.points; const o = n.close; const a = r.lineWidth; return o ? (0, O.checkPointIsInPolygon)(e, i) : (0, O.checkPointIsNearPolyline)(e, i, a) }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.points; r.graphCenter = i[0] }, move: function (e, t) { const n = e.movementX; const i = e.movementY; const o = t.shape.points.map(function (e) { const t = (0, r.default)(e, 2); const o = t[0]; const a = t[1]; return [o + n, a + i] }); this.attr('shape', { points: o }) } }; t.polyline = p; const g = { shape: { points: [], close: !1 }, validator: function (e) { return e.shape.points instanceof Array || (console.error('Smoothline points should be an array!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; const i = t.cache; const s = r.points; const l = r.close; if (!i.points || i.points.toString() !== s.toString()) { const d = o(s, l); const c = a(d); Object.assign(i, { points: (0, O.deepClone)(s, !0), bezierCurve: d, hoverPoints: c }) } const u = i.bezierCurve; n.beginPath(), (0, It.drawBezierCurvePath)(n, u.slice(1), u[0]), l ? (n.closePath(), n.fill(), n.stroke()) : n.stroke() }, hoverCheck: function (e, t) { const n = t.cache; const r = t.shape; const i = t.style; const o = n.hoverPoints; const a = r.close; const s = i.lineWidth; return a ? (0, O.checkPointIsInPolygon)(e, o) : (0, O.checkPointIsNearPolyline)(e, o, s) }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.points; r.graphCenter = i[0] }, move: function (e, t) { const i = e.movementX; const o = e.movementY; const a = t.shape; const s = t.cache; const l = a.points.map(function (e) { const t = (0, r.default)(e, 2); const n = t[0]; const a = t[1]; return [n + i, a + o] }); s.points = l; const d = (0, r.default)(s.bezierCurve[0], 2); const c = d[0]; const u = d[1]; const f = s.bezierCurve.slice(1); s.bezierCurve = [[c + i, u + o]].concat((0, n.default)(f.map(function (e) { return e.map(function (e) { const t = (0, r.default)(e, 2); const n = t[0]; const a = t[1]; return [n + i, a + o] }) }))), s.hoverPoints = s.hoverPoints.map(function (e) { const t = (0, r.default)(e, 2); const n = t[0]; const a = t[1]; return [n + i, a + o] }), this.attr('shape', { points: l }) } }; t.smoothline = g; const v = { shape: { points: [], close: !1 }, validator: function (e) { return e.shape.points instanceof Array || (console.error('BezierCurve points should be an array!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; const i = t.cache; const o = r.points; const s = r.close; if (!i.points || i.points.toString() !== o.toString()) { const l = a(o, 20); Object.assign(i, { points: (0, O.deepClone)(o, !0), hoverPoints: l }) }n.beginPath(), (0, It.drawBezierCurvePath)(n, o.slice(1), o[0]), s ? (n.closePath(), n.fill(), n.stroke()) : n.stroke() }, hoverCheck: function (e, t) { const n = t.cache; const r = t.shape; const i = t.style; const o = n.hoverPoints; const a = r.close; const s = i.lineWidth; return a ? (0, O.checkPointIsInPolygon)(e, o) : (0, O.checkPointIsNearPolyline)(e, o, s) }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.points; r.graphCenter = i[0] }, move: function (e, t) { const i = e.movementX; const o = e.movementY; const a = t.shape; const s = t.cache; const l = a.points; const d = (0, r.default)(l[0], 2); const c = d[0]; const u = d[1]; const f = l.slice(1); const h = [[c + i, u + o]].concat((0, n.default)(f.map(function (e) { return e.map(function (e) { const t = (0, r.default)(e, 2); const n = t[0]; const a = t[1]; return [n + i, a + o] }) }))); s.points = h, s.hoverPoints = s.hoverPoints.map(function (e) { const t = (0, r.default)(e, 2); const n = t[0]; const a = t[1]; return [n + i, a + o] }), this.attr('shape', { points: h }) } }; t.bezierCurve = v; const m = { shape: { content: '', position: [], maxWidth: void 0, rowGap: 0 }, validator: function (e) { const t = e.shape; const n = t.content; const r = t.position; const i = t.rowGap; return typeof n !== 'string' ? (console.error('Text content should be a string!'), !1) : r instanceof Array ? typeof i === 'number' || (console.error('Text rowGap should be a number!'), !1) : (console.error('Text position should be an array!'), !1) }, draw: function (e, t) { const i = e.ctx; const o = t.shape; let a = o.content; let s = o.position; const l = o.maxWidth; const d = o.rowGap; const c = i.textBaseline; const u = i.font; const f = parseInt(u.replace(/\D/g, '')); const h = s; const p = (0, r.default)(h, 2); const g = p[0]; let v = p[1]; const m = (a = a.split('\n')).length; const A = f + d; const C = m * A - d; let b = 0; c === 'middle' && (b = C / 2, v += f / 2), c === 'bottom' && (b = C, v += f), s = new Array(m).fill(0).map(function (e, t) { return [g, v + t * A - b] }), i.beginPath(), a.forEach(function (e, t) { i.fillText.apply(i, [e].concat((0, n.default)(s[t]), [l])), i.strokeText.apply(i, [e].concat((0, n.default)(s[t]), [l])) }), i.closePath() }, hoverCheck: function (e, t) { t.shape, t.style; return !1 }, setGraphCenter: function (e, t) { const r = t.shape; const i = t.style; const o = r.position; i.graphCenter = (0, n.default)(o) }, move: function (e, t) { const n = e.movementX; const i = e.movementY; const o = t.shape; const a = (0, r.default)(o.position, 2); const s = a[0]; const l = a[1]; this.attr('shape', { position: [s + n, l + i] }) } }; t.text = m; var A = new Map([['circle', s], ['ellipse', l], ['rect', d], ['ring', c], ['arc', u], ['sector', f], ['regPolygon', h], ['polyline', p], ['smoothline', g], ['bezierCurve', v], ['text', m]]); const C = A; t.default = C }); A(Wt); Wt.extendNewGraph, Wt.text, Wt.bezierCurve, Wt.smoothline, Wt.polyline, Wt.regPolygon, Wt.sector, Wt.arc, Wt.ring, Wt.rect, Wt.ellipse, Wt.circle; const Lt = C(function (e) { const t = (function (e) { let t; const n = Object.prototype; const r = n.hasOwnProperty; const i = typeof Symbol === 'function' ? Symbol : {}; const o = i.iterator || '@@iterator'; const a = i.asyncIterator || '@@asyncIterator'; const s = i.toStringTag || '@@toStringTag'; function l (e, t, n, r) { const i = t && t.prototype instanceof g ? t : g; const o = Object.create(i.prototype); const a = new P(r || []); return o._invoke = (function (e, t, n) { let r = c; return function (i, o) { if (r === f) throw new Error('Generator is already running'); if (r === h) { if (i === 'throw') throw o; return S() } for (n.method = i, n.arg = o; ;) { const a = n.delegate; if (a) { const s = E(a, n); if (s) { if (s === p) continue; return s } } if (n.method === 'next')n.sent = n._sent = n.arg; else if (n.method === 'throw') { if (r === c) throw r = h, n.arg; n.dispatchException(n.arg) } else n.method === 'return' && n.abrupt('return', n.arg); r = f; const l = d(e, t, n); if (l.type === 'normal') { if (r = n.done ? h : u, l.arg === p) continue; return { value: l.arg, done: n.done } }l.type === 'throw' && (r = h, n.method = 'throw', n.arg = l.arg) } } }(e, n, a)), o } function d (e, t, n) { try { return { type: 'normal', arg: e.call(t, n) } } catch (e) { return { type: 'throw', arg: e } } }e.wrap = l; var c = 'suspendedStart'; var u = 'suspendedYield'; var f = 'executing'; var h = 'completed'; var p = {}; function g () {} function v () {} function m () {} let A = {}; A[o] = function () { return this }; const C = Object.getPrototypeOf; const b = C && C(C(_([]))); b && b !== n && r.call(b, o) && (A = b); const y = m.prototype = g.prototype = Object.create(A); function x (e) { ['next', 'throw', 'return'].forEach(function (t) { e[t] = function (e) { return this._invoke(t, e) } }) } function w (e) { let t; this._invoke = function (n, i) { function o () { return new Promise(function (t, o) { !(function t (n, i, o, a) { const s = d(e[n], e, i); if (s.type !== 'throw') { const l = s.arg; const c = l.value; return c && typeof c === 'object' && r.call(c, '__await') ? Promise.resolve(c.__await).then(function (e) { t('next', e, o, a) }, function (e) { t('throw', e, o, a) }) : Promise.resolve(c).then(function (e) { l.value = e, o(l) }, function (e) { return t('throw', e, o, a) }) }a(s.arg) }(n, i, t, o)) }) } return t = t ? t.then(o, o) : o() } } function E (e, n) { const r = e.iterator[n.method]; if (r === t) { if (n.delegate = null, n.method === 'throw') { if (e.iterator.return && (n.method = 'return', n.arg = t, E(e, n), n.method === 'throw')) return p; n.method = 'throw', n.arg = new TypeError("The iterator does not provide a 'throw' method") } return p } const i = d(r, e.iterator, n.arg); if (i.type === 'throw') return n.method = 'throw', n.arg = i.arg, n.delegate = null, p; const o = i.arg; return o ? o.done ? (n[e.resultName] = o.value, n.next = e.nextLoc, n.method !== 'return' && (n.method = 'next', n.arg = t), n.delegate = null, p) : o : (n.method = 'throw', n.arg = new TypeError('iterator result is not an object'), n.delegate = null, p) } function k (e) { const t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t) } function B (e) { const t = e.completion || {}; t.type = 'normal', delete t.arg, e.completion = t } function P (e) { this.tryEntries = [{ tryLoc: 'root' }], e.forEach(k, this), this.reset(!0) } function _ (e) { if (e) { const n = e[o]; if (n) return n.call(e); if (typeof e.next === 'function') return e; if (!isNaN(e.length)) { let i = -1; const a = function n () { for (;++i < e.length;) if (r.call(e, i)) return n.value = e[i], n.done = !1, n; return n.value = t, n.done = !0, n }; return a.next = a } } return { next: S } } function S () { return { value: t, done: !0 } } return v.prototype = y.constructor = m, m.constructor = v, m[s] = v.displayName = 'GeneratorFunction', e.isGeneratorFunction = function (e) { const t = typeof e === 'function' && e.constructor; return !!t && (t === v || (t.displayName || t.name) === 'GeneratorFunction') }, e.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, m) : (e.__proto__ = m, s in e || (e[s] = 'GeneratorFunction')), e.prototype = Object.create(y), e }, e.awrap = function (e) { return { __await: e } }, x(w.prototype), w.prototype[a] = function () { return this }, e.AsyncIterator = w, e.async = function (t, n, r, i) { const o = new w(l(t, n, r, i)); return e.isGeneratorFunction(n) ? o : o.next().then(function (e) { return e.done ? e.value : o.next() }) }, x(y), y[s] = 'Generator', y[o] = function () { return this }, y.toString = function () { return '[object Generator]' }, e.keys = function (e) { const t = []; for (const n in e)t.push(n); return t.reverse(), function n () { for (;t.length;) { const r = t.pop(); if (r in e) return n.value = r, n.done = !1, n } return n.done = !0, n } }, e.values = _, P.prototype = { constructor: P, reset: function (e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = 'next', this.arg = t, this.tryEntries.forEach(B), !e) for (const n in this)n.charAt(0) === 't' && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t) }, stop: function () { this.done = !0; const e = this.tryEntries[0].completion; if (e.type === 'throw') throw e.arg; return this.rval }, dispatchException: function (e) { if (this.done) throw e; const n = this; function i (r, i) { return s.type = 'throw', s.arg = e, n.next = r, i && (n.method = 'next', n.arg = t), !!i } for (let o = this.tryEntries.length - 1; o >= 0; --o) { const a = this.tryEntries[o]; var s = a.completion; if (a.tryLoc === 'root') return i('end'); if (a.tryLoc <= this.prev) { const l = r.call(a, 'catchLoc'); const d = r.call(a, 'finallyLoc'); if (l && d) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0); if (this.prev < a.finallyLoc) return i(a.finallyLoc) } else if (l) { if (this.prev < a.catchLoc) return i(a.catchLoc, !0) } else { if (!d) throw new Error('try statement without catch or finally'); if (this.prev < a.finallyLoc) return i(a.finallyLoc) } } } }, abrupt: function (e, t) { for (let n = this.tryEntries.length - 1; n >= 0; --n) { const i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, 'finallyLoc') && this.prev < i.finallyLoc) { var o = i; break } }o && (e === 'break' || e === 'continue') && o.tryLoc <= t && t <= o.finallyLoc && (o = null); const a = o ? o.completion : {}; return a.type = e, a.arg = t, o ? (this.method = 'next', this.next = o.finallyLoc, p) : this.complete(a) }, complete: function (e, t) { if (e.type === 'throw') throw e.arg; return e.type === 'break' || e.type === 'continue' ? this.next = e.arg : e.type === 'return' ? (this.rval = this.arg = e.arg, this.method = 'return', this.next = 'end') : e.type === 'normal' && t && (this.next = t), p }, finish: function (e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), B(n), p } }, catch: function (e) { for (let t = this.tryEntries.length - 1; t >= 0; --t) { const n = this.tryEntries[t]; if (n.tryLoc === e) { const r = n.completion; if (r.type === 'throw') { var i = r.arg; B(n) } return i } } throw new Error('illegal catch attempt') }, delegateYield: function (e, n, r) { return this.delegate = { iterator: _(e), resultName: n, nextLoc: r }, this.method === 'next' && (this.arg = t), p } }, e }(e.exports)); try { regeneratorRuntime = t } catch (e) { Function('r', 'regeneratorRuntime = r')(t) } }); function jt (e, t, n, r, i, o, a) { try { var s = e[o](a); var l = s.value } catch (e) { return void n(e) }s.done ? t(l) : Promise.resolve(l).then(r, i) } const Mt = function (e) { return function () { const t = this; const n = arguments; return new Promise(function (r, i) { const o = e.apply(t, n); function a (e) { jt(o, r, i, a, s, 'next', e) } function s (e) { jt(o, r, i, a, s, 'throw', e) }a(void 0) }) } }; const Ft = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.default = void 0; const n = b(E); const r = b(Bt); const i = function e (t) { (0, r.default)(this, e), this.colorProcessor(t); Object.assign(this, { fill: [0, 0, 0, 1], stroke: [0, 0, 0, 0], opacity: 1, lineCap: null, lineJoin: null, lineDash: null, lineDashOffset: null, shadowBlur: 0, shadowColor: [0, 0, 0, 0], shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 0, graphCenter: null, scale: null, rotate: null, translate: null, hoverCursor: 'pointer', fontStyle: 'normal', fontVarient: 'normal', fontWeight: 'normal', fontSize: 10, fontFamily: 'Arial', textAlign: 'center', textBaseline: 'middle', gradientColor: null, gradientType: 'linear', gradientParams: null, gradientWith: 'stroke', gradientStops: 'auto', colors: null }, t) }; t.default = i, i.prototype.colorProcessor = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = t ? xe.getColorFromRgbValue : xe.getRgbaValue; const r = ['fill', 'stroke', 'shadowColor']; const i = Object.keys(e); const o = i.filter(function (e) { return r.find(function (t) { return t === e }) }); o.forEach(function (t) { return e[t] = n(e[t]) }); const a = e.gradientColor; const s = e.colors; if (a && (e.gradientColor = a.map(function (e) { return n(e) })), s) { const l = Object.keys(s); l.forEach(function (e) { return s[e] = n(s[e]) }) } }, i.prototype.initStyle = function (e) { !(function (e, t) { e.save(); const r = t.graphCenter; const i = t.rotate; const o = t.scale; const a = t.translate; if (!(r instanceof Array)) return; e.translate.apply(e, (0, n.default)(r)), i && e.rotate(i * Math.PI / 180); o instanceof Array && e.scale.apply(e, (0, n.default)(o)); a && e.translate.apply(e, (0, n.default)(a)); e.translate(-r[0], -r[1]) }(e, this)), (function (e, t) { let r = t.fill; let i = t.stroke; let a = t.shadowColor; const s = t.opacity; o.forEach(function (n) { (n || typeof n === 'number') && (e[n] = t[n]) }), r = (0, n.default)(r), i = (0, n.default)(i), a = (0, n.default)(a), r[3] *= s, i[3] *= s, a[3] *= s, e.fillStyle = (0, xe.getColorFromRgbValue)(r), e.strokeStyle = (0, xe.getColorFromRgbValue)(i), e.shadowColor = (0, xe.getColorFromRgbValue)(a); let l = t.lineDash; const d = t.shadowBlur; l && (l = l.map(function (e) { return e >= 0 ? e : 0 }), e.setLineDash(l)); typeof d === 'number' && (e.shadowBlur = d > 0 ? d : 0.001); const c = t.fontStyle; const u = t.fontVarient; const f = t.fontWeight; const h = t.fontSize; const p = t.fontFamily; e.font = c + ' ' + u + ' ' + f + ' ' + h + 'px ' + p }(e, this)), (function (e, t) { if (!(function (e) { const t = e.gradientColor; const n = e.gradientParams; const r = e.gradientType; const i = e.gradientWith; const o = e.gradientStops; if (!t || !n) return !1; if (t.length === 1) return console.warn('The gradient needs to provide at least two colors'), !1; if (r !== 'linear' && r !== 'radial') return console.warn('GradientType only supports linear or radial, current value is ' + r), !1; const a = n.length; if (r === 'linear' && a !== 4 || r === 'radial' && a !== 6) return console.warn('The expected length of gradientParams is ' + (r === 'linear' ? '4' : '6')), !1; if (i !== 'fill' && i !== 'stroke') return console.warn('GradientWith only supports fill or stroke, current value is ' + i), !1; if (o !== 'auto' && !(o instanceof Array)) return console.warn("gradientStops only supports 'auto' or Number Array ([0, .5, 1]), current value is " + o), !1; return !0 }(t))) return; let r = t.gradientColor; const i = t.gradientParams; const o = t.gradientType; const a = t.gradientWith; let s = t.gradientStops; const l = t.opacity; r = (r = r.map(function (e) { const t = e[3] * l; const r = (0, n.default)(e); return r[3] = t, r })).map(function (e) { return (0, xe.getColorFromRgbValue)(e) }), s === 'auto' && (s = (function (e) { const t = 1 / (e.length - 1); return e.map(function (e, n) { return t * n }) }(r))); const d = e['create'.concat(o.slice(0, 1).toUpperCase() + o.slice(1), 'Gradient')].apply(e, (0, n.default)(i)); s.forEach(function (e, t) { return d.addColorStop(e, r[t]) }), e[''.concat(a, 'Style')] = d }(e, this)) }; var o = ['lineCap', 'lineJoin', 'lineDashOffset', 'shadowOffsetX', 'shadowOffsetY', 'lineWidth', 'textAlign', 'textBaseline']; i.prototype.restoreTransform = function (e) { e.restore() }, i.prototype.update = function (e) { this.colorProcessor(e), Object.assign(this, e) }, i.prototype.getStyle = function () { const e = (0, O.deepClone)(this, !0); return this.colorProcessor(e, !0), e } }); A(Ft); const Rt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.default = t.easeInOutBounce = t.easeOutBounce = t.easeInBounce = t.easeInOutElastic = t.easeOutElastic = t.easeInElastic = t.easeInOutBack = t.easeOutBack = t.easeInBack = t.easeInOutQuint = t.easeOutQuint = t.easeInQuint = t.easeInOutQuart = t.easeOutQuart = t.easeInQuart = t.easeInOutCubic = t.easeOutCubic = t.easeInCubic = t.easeInOutQuad = t.easeOutQuad = t.easeInQuad = t.easeInOutSine = t.easeOutSine = t.easeInSine = t.linear = void 0; const n = [[[0, 1], '', [0.33, 0.67]], [[1, 0], [0.67, 0.33]]]; t.linear = n; const r = [[[0, 1]], [[0.538, 0.564], [0.169, 0.912], [0.88, 0.196]], [[1, 0]]]; t.easeInSine = r; const i = [[[0, 1]], [[0.444, 0.448], [0.169, 0.736], [0.718, 0.16]], [[1, 0]]]; t.easeOutSine = i; const o = [[[0, 1]], [[0.5, 0.5], [0.2, 1], [0.8, 0]], [[1, 0]]]; t.easeInOutSine = o; const a = [[[0, 1]], [[0.55, 0.584], [0.231, 0.904], [0.868, 0.264]], [[1, 0]]]; t.easeInQuad = a; const s = [[[0, 1]], [[0.413, 0.428], [0.065, 0.816], [0.76, 0.04]], [[1, 0]]]; t.easeOutQuad = s; const l = [[[0, 1]], [[0.5, 0.5], [0.3, 0.9], [0.7, 0.1]], [[1, 0]]]; t.easeInOutQuad = l; const d = [[[0, 1]], [[0.679, 0.688], [0.366, 0.992], [0.992, 0.384]], [[1, 0]]]; t.easeInCubic = d; const c = [[[0, 1]], [[0.321, 0.312], [0.008, 0.616], [0.634, 0.008]], [[1, 0]]]; t.easeOutCubic = c; const u = [[[0, 1]], [[0.5, 0.5], [0.3, 1], [0.7, 0]], [[1, 0]]]; t.easeInOutCubic = u; const f = [[[0, 1]], [[0.812, 0.74], [0.611, 0.988], [1.013, 0.492]], [[1, 0]]]; t.easeInQuart = f; const h = [[[0, 1]], [[0.152, 0.244], [0.001, 0.448], [0.285, -0.02]], [[1, 0]]]; t.easeOutQuart = h; const p = [[[0, 1]], [[0.5, 0.5], [0.4, 1], [0.6, 0]], [[1, 0]]]; t.easeInOutQuart = p; const g = [[[0, 1]], [[0.857, 0.856], [0.714, 1], [1, 0.712]], [[1, 0]]]; t.easeInQuint = g; const v = [[[0, 1]], [[0.108, 0.2], [0.001, 0.4], [0.214, -0.012]], [[1, 0]]]; t.easeOutQuint = v; const m = [[[0, 1]], [[0.5, 0.5], [0.5, 1], [0.5, 0]], [[1, 0]]]; t.easeInOutQuint = m; const A = [[[0, 1]], [[0.667, 0.896], [0.38, 1.184], [0.955, 0.616]], [[1, 0]]]; t.easeInBack = A; const C = [[[0, 1]], [[0.335, 0.028], [0.061, 0.22], [0.631, -0.18]], [[1, 0]]]; t.easeOutBack = C; const b = [[[0, 1]], [[0.5, 0.5], [0.4, 1.4], [0.6, -0.4]], [[1, 0]]]; t.easeInOutBack = b; const y = [[[0, 1]], [[0.474, 0.964], [0.382, 0.988], [0.557, 0.952]], [[0.619, 1.076], [0.565, 1.088], [0.669, 1.08]], [[0.77, 0.916], [0.712, 0.924], [0.847, 0.904]], [[0.911, 1.304], [0.872, 1.316], [0.961, 1.34]], [[1, 0]]]; t.easeInElastic = y; const x = [[[0, 1]], [[0.073, -0.32], [0.034, -0.328], [0.104, -0.344]], [[0.191, 0.092], [0.11, 0.06], [0.256, 0.08]], [[0.31, -0.076], [0.26, -0.068], [0.357, -0.076]], [[0.432, 0.032], [0.362, 0.028], [0.683, -0.004]], [[1, 0]]]; t.easeOutElastic = x; const w = [[[0, 1]], [[0.21, 0.94], [0.167, 0.884], [0.252, 0.98]], [[0.299, 1.104], [0.256, 1.092], [0.347, 1.108]], [[0.5, 0.496], [0.451, 0.672], [0.548, 0.324]], [[0.696, -0.108], [0.652, -0.112], [0.741, -0.124]], [[0.805, 0.064], [0.756, 0.012], [0.866, 0.096]], [[1, 0]]]; t.easeInOutElastic = w; const E = [[[0, 1]], [[0.148, 1], [0.075, 0.868], [0.193, 0.848]], [[0.326, 1], [0.276, 0.836], [0.405, 0.712]], [[0.6, 1], [0.511, 0.708], [0.671, 0.348]], [[1, 0]]]; t.easeInBounce = E; const k = [[[0, 1]], [[0.357, 0.004], [0.27, 0.592], [0.376, 0.252]], [[0.604, -0.004], [0.548, 0.312], [0.669, 0.184]], [[0.82, 0], [0.749, 0.184], [0.905, 0.132]], [[1, 0]]]; t.easeOutBounce = k; const B = [[[0, 1]], [[0.102, 1], [0.05, 0.864], [0.117, 0.86]], [[0.216, 0.996], [0.208, 0.844], [0.227, 0.808]], [[0.347, 0.996], [0.343, 0.8], [0.48, 0.292]], [[0.635, 0.004], [0.511, 0.676], [0.656, 0.208]], [[0.787, 0], [0.76, 0.2], [0.795, 0.144]], [[0.905, -0.004], [0.899, 0.164], [0.944, 0.144]], [[1, 0]]]; t.easeInOutBounce = B; const P = new Map([['linear', n], ['easeInSine', r], ['easeOutSine', i], ['easeInOutSine', o], ['easeInQuad', a], ['easeOutQuad', s], ['easeInOutQuad', l], ['easeInCubic', d], ['easeOutCubic', c], ['easeInOutCubic', u], ['easeInQuart', f], ['easeOutQuart', h], ['easeInOutQuart', p], ['easeInQuint', g], ['easeOutQuint', v], ['easeInOutQuint', m], ['easeInBack', A], ['easeOutBack', C], ['easeInOutBack', b], ['easeInElastic', y], ['easeOutElastic', x], ['easeInOutElastic', w], ['easeInBounce', E], ['easeOutBounce', k], ['easeInOutBounce', B]]); t.default = P }); A(Rt); Rt.easeInOutBounce, Rt.easeOutBounce, Rt.easeInBounce, Rt.easeInOutElastic, Rt.easeOutElastic, Rt.easeInElastic, Rt.easeInOutBack, Rt.easeOutBack, Rt.easeInBack, Rt.easeInOutQuint, Rt.easeOutQuint, Rt.easeInQuint, Rt.easeInOutQuart, Rt.easeOutQuart, Rt.easeInQuart, Rt.easeInOutCubic, Rt.easeOutCubic, Rt.easeInCubic, Rt.easeInOutQuad, Rt.easeOutQuad, Rt.easeInQuad, Rt.easeInOutSine, Rt.easeOutSine, Rt.easeInSine, Rt.linear; const Dt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.transition = a, t.injectNewCurve = function (e, t) { if (!e || !t) return void console.error('InjectNewCurve Missing Parameters!'); i.default.set(e, t) }, t.default = void 0; const n = b(S); const r = b(k); var i = b(Rt); const o = 'linear'; function a (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; const d = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 30; const c = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; if (!s.apply(void 0, arguments)) return !1; try { const u = (function (e, t) { const r = 1 / (t - 1); return new Array(t).fill(0).map(function (e, t) { return t * r }).map(function (t) { return (function (e, t) { const r = (function (e, t) { const n = e.length - 1; let r = ''; let i = ''; e.findIndex(function (o, a) { if (a !== n) { r = o, i = e[a + 1]; const s = r[0][0]; const l = i[0][0]; return t >= s && t < l } }); const o = r[0]; const a = r[2] || r[0]; const s = i[1] || i[0]; const l = i[0]; return [o, a, s, l] }(e, t)); const i = (function (e, t) { const n = e[0][0]; const r = e[3][0]; return (t - n) / (r - n) }(r, t)); return (function (e, t) { const r = (0, n.default)(e, 4); const i = (0, n.default)(r[0], 2)[1]; const o = (0, n.default)(r[1], 2)[1]; const a = (0, n.default)(r[2], 2)[1]; const s = (0, n.default)(r[3], 2)[1]; const l = Math.pow; const d = 1 - t; const c = i * l(d, 3); const u = 3 * o * t * l(d, 2); const f = 3 * a * l(t, 2) * d; const h = s * l(t, 3); return 1 - (c + u + f + h) }(r, i)) }(e, t)) }) }((function (e) { let t = ''; t = i.default.has(e) ? i.default.get(e) : e instanceof Array ? e : i.default.get(o); return t }(e)), d)); return c && typeof a !== 'number' ? (function e (t, n, i) { const o = l(t, n, i); const a = function (a) { const s = t[a]; const l = n[a]; if ((0, r.default)(l) !== 'object') return 'continue'; const d = e(s, l, i); o.forEach(function (e, t) { return e[a] = d[t] }) }; for (const s in n)a(s); return o }(t, a, u)) : l(t, a, u) } catch (e) { return console.warn('Transition parameter may be abnormal!'), [a] } } function s (e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 30; if (!e || !1 === t || !1 === n || !o) return console.error('transition: Missing Parameters!'), !1; if ((0, r.default)(t) !== (0, r.default)(n)) return console.error('transition: Inconsistent Status Types!'), !1; const a = (0, r.default)(n); return a !== 'string' && a !== 'boolean' && e.length ? (i.default.has(e) || e instanceof Array || console.warn('transition: Transition curve not found, default curve will be used!'), !0) : (console.error('transition: Unsupported Data Type of State!'), !1) } function l (e, t, n) { let r = 'object'; return typeof e === 'number' && (r = 'number'), e instanceof Array && (r = 'array'), r === 'number' ? (function (e, t, n) { const r = t - e; return n.map(function (t) { return e + r * t }) }(e, t, n)) : r === 'array' ? d(e, t, n) : r === 'object' ? (function (e, t, n) { const r = Object.keys(t); const i = r.map(function (t) { return e[t] }); const o = r.map(function (e) { return t[e] }); return d(i, o, n).map(function (e) { const t = {}; return e.forEach(function (e, n) { return t[r[n]] = e }), t }) }(e, t, n)) : n.map(function (e) { return t }) } function d (e, t, n) { const r = t.map(function (t, n) { return typeof t === 'number' && t - e[n] }); return n.map(function (n) { return r.map(function (r, i) { return !1 === r ? t[i] : e[i] + r * n }) }) } const c = a; t.default = c }); A(Dt); Dt.transition, Dt.injectNewCurve; const Gt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.default = void 0; const n = b(Lt); const r = b(Mt); const i = b(k); const o = b(E); const a = b(Bt); const s = b(Ft); const l = b(Dt); const d = function e (t, n) { (0, a.default)(this, e); const r = { visible: !0, drag: !1, hover: !1, index: 1, animationDelay: 0, animationFrame: 30, animationCurve: 'linear', animationPause: !1, hoverRect: null, mouseEnter: null, mouseOuter: null, click: null }; (n = (0, O.deepClone)(n, !0)).shape || (n.shape = {}), n.style || (n.style = {}); const i = Object.assign({}, t.shape, n.shape); Object.assign(r, n, { status: 'static', animationRoot: [], animationKeys: [], animationFrameState: [], cache: {} }), Object.assign(this, t, r), this.shape = i, this.style = new s.default(n.style), this.addedProcessor() }; function c (e) { return new Promise(function (t) { setTimeout(t, e) }) }t.default = d, d.prototype.addedProcessor = function () { typeof this.setGraphCenter === 'function' && this.setGraphCenter(null, this), typeof this.added === 'function' && this.added(this) }, d.prototype.drawProcessor = function (e, t) { const n = e.ctx; t.style.initStyle(n), typeof this.beforeDraw === 'function' && this.beforeDraw(this, e), t.draw(e, t), typeof this.drawed === 'function' && this.drawed(this, e), t.style.restoreTransform(n) }, d.prototype.hoverCheckProcessor = function (e, t) { const n = t.hoverRect; const r = t.style; const i = t.hoverCheck; const a = r.graphCenter; const s = r.rotate; const l = r.scale; const d = r.translate; return a && (s && (e = (0, O.getRotatePointPos)(-s, e, a)), l && (e = (0, O.getScalePointPos)(l.map(function (e) { return 1 / e }), e, a)), d && (e = (0, O.getTranslatePointPos)(d.map(function (e) { return -1 * e }), e))), n ? O.checkPointIsInRect.apply(void 0, [e].concat((0, o.default)(n))) : i(e, this) }, d.prototype.moveProcessor = function (e) { this.move(e, this), typeof this.beforeMove === 'function' && this.beforeMove(e, this), typeof this.setGraphCenter === 'function' && this.setGraphCenter(e, this), typeof this.moved === 'function' && this.moved(e, this) }, d.prototype.attr = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0; if (!e || void 0 === t) return !1; const n = (0, i.default)(this[e]) === 'object'; n && (t = (0, O.deepClone)(t, !0)); const r = this.render; e === 'style' ? this.style.update(t) : n ? Object.assign(this[e], t) : this[e] = t, e === 'index' && r.sortGraphsByIndex(), r.drawAllGraph() }, d.prototype.animation = (function () { const e = (0, r.default)(n.default.mark(function e (t, i) { let o; let a; let s; let d; let u; let f; let h; let p; let g; const v = arguments; return n.default.wrap(function (e) { for (;;) switch (e.prev = e.next) { case 0:if (o = v.length > 2 && void 0 !== v[2] && v[2], t === 'shape' || t === 'style') { e.next = 4; break } return console.error('Only supported shape and style animation!'), e.abrupt('return'); case 4:if (i = (0, O.deepClone)(i, !0), t === 'style' && this.style.colorProcessor(i), a = this[t], s = Object.keys(i), d = {}, s.forEach(function (e) { return d[e] = a[e] }), u = this.animationFrame, f = this.animationCurve, h = this.animationDelay, p = (0, l.default)(f, d, i, u, !0), this.animationRoot.push(a), this.animationKeys.push(s), this.animationFrameState.push(p), !o) { e.next = 17; break } return e.abrupt('return'); case 17:if (!(h > 0)) { e.next = 20; break } return e.next = 20, c(h); case 20:return g = this.render, e.abrupt('return', new Promise(function () { const e = (0, r.default)(n.default.mark(function e (t) { return n.default.wrap(function (e) { for (;;) switch (e.prev = e.next) { case 0:return e.next = 2, g.launchAnimation(); case 2:t(); case 3:case 'end':return e.stop() } }, e) })); return function (t) { return e.apply(this, arguments) } }())); case 22:case 'end':return e.stop() } }, e, this) })); return function (t, n) { return e.apply(this, arguments) } }()), d.prototype.turnNextAnimationFrame = function (e) { const t = this.animationDelay; const n = this.animationRoot; const r = this.animationKeys; const i = this.animationFrameState; this.animationPause || Date.now() - e < t || (n.forEach(function (e, t) { r[t].forEach(function (n) { e[n] = i[t][0][n] }) }), i.forEach(function (e, t) { e.shift(); const i = e.length === 0; i && (n[t] = null), i && (r[t] = null) }), this.animationFrameState = i.filter(function (e) { return e.length }), this.animationRoot = n.filter(function (e) { return e }), this.animationKeys = r.filter(function (e) { return e })) }, d.prototype.animationEnd = function () { const e = this.animationFrameState; const t = this.animationKeys; const n = this.animationRoot; const r = this.render; return n.forEach(function (n, r) { const i = t[r]; const o = e[r].pop(); i.forEach(function (e) { return n[e] = o[e] }) }), this.animationFrameState = [], this.animationKeys = [], this.animationRoot = [], r.drawAllGraph() }, d.prototype.pauseAnimation = function () { this.attr('animationPause', !0) }, d.prototype.playAnimation = function () { const e = this.render; return this.attr('animationPause', !1), new Promise(function () { const t = (0, r.default)(n.default.mark(function t (r) { return n.default.wrap(function (t) { for (;;) switch (t.prev = t.next) { case 0:return t.next = 2, e.launchAnimation(); case 2:r(); case 3:case 'end':return t.stop() } }, t) })); return function (e) { return t.apply(this, arguments) } }()) }, d.prototype.delProcessor = function (e) { const t = this; const n = e.graphs; const r = n.findIndex(function (e) { return e === t }); r !== -1 && (typeof this.beforeDelete === 'function' && this.beforeDelete(this), n.splice(r, 1, null), typeof this.deleted === 'function' && this.deleted(this)) } }); A(Gt); const zt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.default = void 0; const n = b(Pt); const r = b(E); const i = b(Bt); const o = b(xe); const a = b(Ot); const s = b(Wt); const l = b(Gt); function d (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } const c = function e (t) { if ((0, i.default)(this, e), t) { const n = t.getContext('2d'); const r = t.clientWidth; const s = t.clientHeight; const l = [r, s]; t.setAttribute('width', r), t.setAttribute('height', s), this.ctx = n, this.area = l, this.animationStatus = !1, this.graphs = [], this.color = o.default, this.bezierCurve = a.default, t.addEventListener('mousedown', f.bind(this)), t.addEventListener('mousemove', h.bind(this)), t.addEventListener('mouseup', p.bind(this)) } else console.error('CRender Missing parameters!') }; function u (e, t) { const n = this.graphs; !(function (e) { return e.find(function (e) { return !e.animationPause && e.animationFrameState.length }) }(n)) ? e() : (n.forEach(function (e) { return e.turnNextAnimationFrame(t) }), this.drawAllGraph(), requestAnimationFrame(u.bind(this, e, t))) } function f (e) { const t = this.graphs.find(function (e) { return e.status === 'hover' }); t && (t.status = 'active') } function h (e) { const t = [e.offsetX, e.offsetY]; const n = this.graphs; const r = n.find(function (e) { return e.status === 'active' || e.status === 'drag' }); if (r) { if (!r.drag) return; return typeof r.move !== 'function' ? void console.error('No move method is provided, cannot be dragged!') : (r.moveProcessor(e), void (r.status = 'drag')) } const i = n.find(function (e) { return e.status === 'hover' }); const o = n.filter(function (e) { return e.hover && (typeof e.hoverCheck === 'function' || e.hoverRect) }).find(function (e) { return e.hoverCheckProcessor(t, e) }); document.body.style.cursor = o ? o.style.hoverCursor : 'default'; let a = !1; let s = !1; if (i && (a = typeof i.mouseOuter === 'function'), o && (s = typeof o.mouseEnter === 'function'), o || i) { if (!o && i) return a && i.mouseOuter(e, i), void (i.status = 'static'); if (!o || o !== i) return o && !i ? (s && o.mouseEnter(e, o), void (o.status = 'hover')) : void (o && i && o !== i && (a && i.mouseOuter(e, i), i.status = 'static', s && o.mouseEnter(e, o), o.status = 'hover')) } } function p (e) { const t = this.graphs; const n = t.find(function (e) { return e.status === 'active' }); const r = t.find(function (e) { return e.status === 'drag' }); n && typeof n.click === 'function' && n.click(e, n), t.forEach(function (e) { return e && (e.status = 'static') }), n && (n.status = 'hover'), r && (r.status = 'hover') }t.default = c, c.prototype.clearArea = function () { let e; const t = this.area; (e = this.ctx).clearRect.apply(e, [0, 0].concat((0, r.default)(t))) }, c.prototype.add = function () { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.name; if (t) { const n = s.default.get(t); if (n) { const r = new l.default(n, e); if (r.validator(r)) return r.render = this, this.graphs.push(r), this.sortGraphsByIndex(), this.drawAllGraph(), r } else console.warn('No corresponding graph configuration found!') } else console.error('add Missing parameters!') }, c.prototype.sortGraphsByIndex = function () { this.graphs.sort(function (e, t) { return e.index > t.index ? 1 : e.index === t.index ? 0 : e.index < t.index ? -1 : void 0 }) }, c.prototype.delGraph = function (e) { typeof e.delProcessor === 'function' && (e.delProcessor(this), this.graphs = this.graphs.filter(function (e) { return e }), this.drawAllGraph()) }, c.prototype.delAllGraph = function () { const e = this; this.graphs.forEach(function (t) { return t.delProcessor(e) }), this.graphs = this.graphs.filter(function (e) { return e }), this.drawAllGraph() }, c.prototype.drawAllGraph = function () { const e = this; this.clearArea(), this.graphs.filter(function (e) { return e && e.visible }).forEach(function (t) { return t.drawProcessor(e, t) }) }, c.prototype.launchAnimation = function () { const e = this; if (!this.animationStatus) return this.animationStatus = !0, new Promise(function (t) { u.call(e, function () { e.animationStatus = !1, t() }, Date.now()) }) }, c.prototype.clone = function (e) { const t = e.style.getStyle(); let r = (function (e) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; t % 2 ? d(r, !0).forEach(function (t) { (0, n.default)(e, t, r[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : d(r).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t)) }) } return e }({}, e, { style: t })); return delete r.render, r = (0, O.deepClone)(r, !0), this.add(r) } }); A(zt); const Tt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), Object.defineProperty(t, 'CRender', { enumerable: !0, get: function () { return n.default } }), Object.defineProperty(t, 'extendNewGraph', { enumerable: !0, get: function () { return Wt.extendNewGraph } }), t.default = void 0; var n = b(zt); const r = n.default; t.default = r }); const Yt = A(Tt); const Nt = b(E); const $t = { shape: { rx: 0, ry: 0, ir: 0, or: 0, startAngle: 0, endAngle: 0, clockWise: !0 }, validator: function (e) { const t = e.shape; return !['rx', 'ry', 'ir', 'or', 'startAngle', 'endAngle'].find(function (e) { return typeof t[e] !== 'number' }) || (console.error('Pie shape configuration is abnormal!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; n.beginPath(); let i = r.rx; let o = r.ry; const a = r.ir; const s = r.or; const l = r.startAngle; const d = r.endAngle; const c = r.clockWise; i = parseInt(i) + 0.5, o = parseInt(o) + 0.5, n.arc(i, o, a > 0 ? a : 0, l, d, !c); const u = (0, O.getCircleRadianPoint)(i, o, s, d).map(function (e) { return parseInt(e) + 0.5 }); const f = (0, O.getCircleRadianPoint)(i, o, a, l).map(function (e) { return parseInt(e) + 0.5 }); n.lineTo.apply(n, (0, Nt.default)(u)), n.arc(i, o, s > 0 ? s : 0, d, l, c), n.lineTo.apply(n, (0, Nt.default)(f)), n.closePath(), n.stroke(), n.fill() } }; const Xt = { shape: { rx: 0, ry: 0, r: 0, startAngle: 0, endAngle: 0, gradientStartAngle: null, gradientEndAngle: null }, validator: function (e) { const t = e.shape; return !['rx', 'ry', 'r', 'startAngle', 'endAngle'].find(function (e) { return typeof t[e] !== 'number' }) || (console.error('AgArc shape configuration is abnormal!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; let i = t.style.gradient; (i = i.map(function (e) { return (0, xe.getColorFromRgbValue)(e) })).length === 1 && (i = [i[0], i[0]]); const o = i.length - 1; let a = r.gradientStartAngle; let s = r.gradientEndAngle; const l = r.startAngle; const d = r.endAngle; const c = r.r; const u = r.rx; const f = r.ry; a === null && (a = l), s === null && (s = d); let h = (s - a) / o; h === 2 * Math.PI && (h = 2 * Math.PI - 0.001); for (let p = 0; p < o; p++) { n.beginPath(); const g = (0, O.getCircleRadianPoint)(u, f, c, l + h * p); const v = (0, O.getCircleRadianPoint)(u, f, c, l + h * (p + 1)); const m = (0, W.getLinearGradientColor)(n, g, v, [i[p], i[p + 1]]); const A = l + h * p; let C = l + h * (p + 1); let b = !1; if (C > d && (C = d, b = !0), n.arc(u, f, c, A, C), n.strokeStyle = m, n.stroke(), b) break } } }; const Qt = { shape: { number: [], content: '', position: [0, 0], toFixed: 0 }, validator: function (e) { const t = e.shape; const n = t.number; const r = t.content; const i = t.position; return n instanceof Array && typeof r === 'string' && i instanceof Array || (console.error('NumberText shape configuration is abnormal!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; n.beginPath(); const i = r.number; const o = r.content; const a = r.position; const s = r.toFixed; const l = o.split('{nt}'); const d = l.length - 1; let c = ''; l.forEach(function (e, t) { let n = i[t]; t === d && (n = ''), typeof n === 'number' && (n = n.toFixed(s)), c += e + (n || '') }), n.closePath(), n.strokeText.apply(n, [c].concat((0, Nt.default)(a))), n.fillText.apply(n, [c].concat((0, Nt.default)(a))) } }; const Ht = { shape: { x: 0, y: 0, w: 0, h: 0 }, validator: function (e) { const t = e.shape; const n = t.x; const r = t.y; const i = t.w; const o = t.h; return typeof n === 'number' && typeof r === 'number' && typeof i === 'number' && typeof o === 'number' || (console.error('lineIcon shape configuration is abnormal!'), !1) }, draw: function (e, t) { const n = e.ctx; const r = t.shape; n.beginPath(); const i = r.x; const o = r.y; const a = r.w; const s = r.h / 2; n.strokeStyle = n.fillStyle, n.moveTo(i, o + s), n.lineTo(i + a, o + s), n.lineWidth = 1, n.stroke(), n.beginPath(); let l = s - 10; l <= 0 && (l = 3), n.arc(i + a / 2, o + s, l, 0, 2 * Math.PI), n.lineWidth = 5, n.stroke(), n.fillStyle = '#fff', n.fill() }, hoverCheck: function (e, t) { const n = t.shape; const r = n.x; const i = n.y; const o = n.w; const a = n.h; return (0, O.checkPointIsInRect)(e, r, i, o, a) }, setGraphCenter: function (e, t) { const n = t.shape; const r = t.style; const i = n.x; const o = n.y; const a = n.w; const s = n.h; r.graphCenter = [i + a / 2, o + s / 2] } }; (0, Tt.extendNewGraph)('pie', $t), (0, Tt.extendNewGraph)('agArc', Xt), (0, Tt.extendNewGraph)('numberText', Qt), (0, Tt.extendNewGraph)('lineIcon', Ht); const Ut = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.colorConfig = void 0; t.colorConfig = ['#37a2da', '#32c5e9', '#67e0e3', '#9fe6b8', '#ffdb5c', '#ff9f7f', '#fb7293', '#e062ae', '#e690d1', '#e7bcf3', '#9d96f5', '#8378ea', '#96bfff'] }); A(Ut); Ut.colorConfig; const Vt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.gridConfig = void 0; t.gridConfig = { left: '10%', right: '10%', top: 60, bottom: 60, style: { fill: 'rgba(0, 0, 0, 0)' }, rLevel: -30, animationCurve: 'easeOutCubic', animationFrame: 30 } }); A(Vt); Vt.gridConfig; const qt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.yAxisConfig = t.xAxisConfig = void 0; t.xAxisConfig = { name: '', show: !0, position: 'bottom', nameGap: 15, nameLocation: 'end', nameTextStyle: { fill: '#333', fontSize: 10 }, min: '20%', max: '20%', interval: null, minInterval: null, maxInterval: null, boundaryGap: null, splitNumber: 5, axisLine: { show: !0, style: { stroke: '#333', lineWidth: 1 } }, axisTick: { show: !0, style: { stroke: '#333', lineWidth: 1 } }, axisLabel: { show: !0, formatter: null, style: { fill: '#333', fontSize: 10, rotate: 0 } }, splitLine: { show: !1, style: { stroke: '#d4d4d4', lineWidth: 1 } }, rLevel: -20, animationCurve: 'easeOutCubic', animationFrame: 50 }; t.yAxisConfig = { name: '', show: !0, position: 'left', nameGap: 15, nameLocation: 'end', nameTextStyle: { fill: '#333', fontSize: 10 }, min: '20%', max: '20%', interval: null, minInterval: null, maxInterval: null, boundaryGap: null, splitNumber: 5, axisLine: { show: !0, style: { stroke: '#333', lineWidth: 1 } }, axisTick: { show: !0, style: { stroke: '#333', lineWidth: 1 } }, axisLabel: { show: !0, formatter: null, style: { fill: '#333', fontSize: 10, rotate: 0 } }, splitLine: { show: !0, style: { stroke: '#d4d4d4', lineWidth: 1 } }, rLevel: -20, animationCurve: 'easeOutCubic', animationFrame: 50 } }); A(qt); qt.yAxisConfig, qt.xAxisConfig; const Zt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.titleConfig = void 0; t.titleConfig = { show: !0, text: '', offset: [0, -20], style: { fill: '#333', fontSize: 17, fontWeight: 'bold', textAlign: 'center', textBaseline: 'bottom' }, rLevel: 20, animationCurve: 'easeOutCubic', animationFrame: 50 } }); A(Zt); Zt.titleConfig; const Kt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.lineConfig = void 0; t.lineConfig = { show: !0, name: '', stack: '', smooth: !1, xAxisIndex: 0, yAxisIndex: 0, data: [], lineStyle: { lineWidth: 1 }, linePoint: { show: !0, radius: 2, style: { fill: '#fff', lineWidth: 1 } }, lineArea: { show: !1, gradient: [], style: { opacity: 0.5 } }, label: { show: !1, position: 'top', offset: [0, -10], formatter: null, style: { fontSize: 10 } }, rLevel: 10, animationCurve: 'easeOutCubic', animationFrame: 50 } }); A(Kt); Kt.lineConfig; const Jt = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.barConfig = void 0; t.barConfig = { show: !0, name: '', stack: '', shapeType: 'normal', echelonOffset: 10, barWidth: 'auto', barGap: '30%', barCategoryGap: '20%', xAxisIndex: 0, yAxisIndex: 0, data: [], backgroundBar: { show: !1, width: 'auto', style: { fill: 'rgba(200, 200, 200, .4)' } }, label: { show: !1, position: 'top', offset: [0, -10], formatter: null, style: { fontSize: 10 } }, gradient: { color: [], local: !0 }, barStyle: {}, rLevel: 0, animationCurve: 'easeOutCubic', animationFrame: 50 } }); A(Jt); Jt.barConfig; const en = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.pieConfig = void 0; const n = { show: !0, name: '', radius: '50%', center: ['50%', '50%'], startAngle: -Math.PI / 2, roseType: !1, roseSort: !0, roseIncrement: 'auto', data: [], insideLabel: { show: !1, formatter: '{percent}%', style: { fontSize: 10, fill: '#fff', textAlign: 'center', textBaseline: 'middle' } }, outsideLabel: { show: !0, formatter: '{name}', style: { fontSize: 11 }, labelLineBendGap: '20%', labelLineEndLength: 50, labelLineStyle: { lineWidth: 1 } }, pieStyle: {}, percentToFixed: 0, rLevel: 10, animationDelayGap: 60, animationCurve: 'easeOutCubic', startAnimationCurve: 'easeOutBack', animationFrame: 50 }; t.pieConfig = n }); A(en); en.pieConfig; const tn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.radarAxisConfig = void 0; const n = { show: !0, center: ['50%', '50%'], radius: '65%', startAngle: -Math.PI / 2, splitNum: 5, polygon: !1, axisLabel: { show: !0, labelGap: 15, color: [], style: { fill: '#333' } }, axisLine: { show: !0, color: [], style: { stroke: '#999', lineWidth: 1 } }, splitLine: { show: !0, color: [], style: { stroke: '#d4d4d4', lineWidth: 1 } }, splitArea: { show: !1, color: ['#f5f5f5', '#e6e6e6'], style: {} }, rLevel: -10, animationCurve: 'easeOutCubic', animationFrane: 50 }; t.radarAxisConfig = n }); A(tn); tn.radarAxisConfig; const nn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.radarConfig = void 0; t.radarConfig = { show: !0, name: '', data: [], radarStyle: { lineWidth: 1 }, point: { show: !0, radius: 2, style: { fill: '#fff' } }, label: { show: !0, offset: [0, 0], labelGap: 5, formatter: null, style: { fontSize: 10 } }, rLevel: 10, animationCurve: 'easeOutCubic', animationFrane: 50 } }); A(nn); nn.radarConfig; const rn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.gaugeConfig = void 0; const n = { show: !0, name: '', radius: '60%', center: ['50%', '50%'], startAngle: -Math.PI / 4 * 5, endAngle: Math.PI / 4, min: 0, max: 100, splitNum: 5, arcLineWidth: 15, data: [], dataItemStyle: {}, axisTick: { show: !0, tickLength: 6, style: { stroke: '#999', lineWidth: 1 } }, axisLabel: { show: !0, data: [], formatter: null, labelGap: 5, style: {} }, pointer: { show: !0, valueIndex: 0, style: { scale: [1, 1], fill: '#fb7293' } }, details: { show: !1, formatter: null, offset: [0, 0], valueToFixed: 0, position: 'center', style: { fontSize: 20, fontWeight: 'bold', textAlign: 'center', textBaseline: 'middle' } }, backgroundArc: { show: !0, style: { stroke: '#e0e0e0' } }, rLevel: 10, animationCurve: 'easeOutCubic', animationFrame: 50 }; t.gaugeConfig = n }); A(rn); rn.gaugeConfig; const on = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.legendConfig = void 0; t.legendConfig = { show: !0, orient: 'horizontal', left: 'auto', right: 'auto', top: 'auto', bottom: 'auto', itemGap: 10, iconWidth: 25, iconHeight: 10, selectAble: !0, data: [], textStyle: { fontFamily: 'Arial', fontSize: 13, fill: '#000' }, iconStyle: {}, textUnselectedStyle: { fontFamily: 'Arial', fontSize: 13, fill: '#999' }, iconUnselectedStyle: { fill: '#999' }, rLevel: 20, animationCurve: 'easeOutCubic', animationFrame: 50 } }); A(on); on.legendConfig; const an = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.changeDefaultConfig = function (e, t) { if (!n[''.concat(e, 'Config')]) return void console.warn('Change default config Error - Invalid key!'); (0, W.deepMerge)(n[''.concat(e, 'Config')], t) }, Object.defineProperty(t, 'colorConfig', { enumerable: !0, get: function () { return Ut.colorConfig } }), Object.defineProperty(t, 'gridConfig', { enumerable: !0, get: function () { return Vt.gridConfig } }), Object.defineProperty(t, 'xAxisConfig', { enumerable: !0, get: function () { return qt.xAxisConfig } }), Object.defineProperty(t, 'yAxisConfig', { enumerable: !0, get: function () { return qt.yAxisConfig } }), Object.defineProperty(t, 'titleConfig', { enumerable: !0, get: function () { return Zt.titleConfig } }), Object.defineProperty(t, 'lineConfig', { enumerable: !0, get: function () { return Kt.lineConfig } }), Object.defineProperty(t, 'barConfig', { enumerable: !0, get: function () { return Jt.barConfig } }), Object.defineProperty(t, 'pieConfig', { enumerable: !0, get: function () { return en.pieConfig } }), Object.defineProperty(t, 'radarAxisConfig', { enumerable: !0, get: function () { return tn.radarAxisConfig } }), Object.defineProperty(t, 'radarConfig', { enumerable: !0, get: function () { return nn.radarConfig } }), Object.defineProperty(t, 'gaugeConfig', { enumerable: !0, get: function () { return rn.gaugeConfig } }), Object.defineProperty(t, 'legendConfig', { enumerable: !0, get: function () { return on.legendConfig } }), t.keys = void 0; var n = { colorConfig: Ut.colorConfig, gridConfig: Vt.gridConfig, xAxisConfig: qt.xAxisConfig, yAxisConfig: qt.yAxisConfig, titleConfig: Zt.titleConfig, lineConfig: Kt.lineConfig, barConfig: Jt.barConfig, pieConfig: en.pieConfig, radarAxisConfig: tn.radarAxisConfig, radarConfig: nn.radarConfig, gaugeConfig: rn.gaugeConfig, legendConfig: on.legendConfig }; t.keys = ['color', 'title', 'legend', 'xAxis', 'yAxis', 'grid', 'radarAxis', 'line', 'bar', 'pie', 'radar', 'gauge'] }); A(an); an.changeDefaultConfig, an.keys; const sn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.mergeColor = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = (0, O.deepClone)(an.colorConfig, !0); let r = t.color; let i = t.series; i || (i = []); r || (r = []); if (t.color = r = (0, W.deepMerge)(n, r), !i.length) return; const o = r.length; i.forEach(function (e, t) { e.color || (e.color = r[t % o]) }), i.filter(function (e) { return e.type === 'pie' }).forEach(function (e) { return e.data.forEach(function (e, t) { return e.color = r[t % o] }) }), i.filter(function (e) { return e.type === 'gauge' }).forEach(function (e) { return e.data.forEach(function (e, t) { return e.color = r[t % o] }) }) } }); A(sn); sn.mergeColor; const ln = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.doUpdate = function () { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.chart; const n = e.series; const r = e.key; const i = e.getGraphConfig; const a = e.getStartGraphConfig; const s = e.beforeChange; const l = e.beforeUpdate; const d = e.afterAddGraph; t[r] ? t[r].update(n) : t[r] = new o({ chart: t, key: r, getGraphConfig: i, getStartGraphConfig: a, beforeChange: s, beforeUpdate: l, afterAddGraph: d }, n) }, t.Updater = void 0; const n = b(E); const r = b(k); const i = b(Bt); var o = function e (t, n) { (0, i.default)(this, e); const r = t.chart; const o = t.key; typeof t.getGraphConfig === 'function' ? (r[o] || (this.graphs = r[o] = []), Object.assign(this, t), this.update(n)) : console.warn('Updater need function getGraphConfig!') }; function a (e, t) { Object.keys(t).forEach(function (n) { n === 'shape' || n === 'style' ? e.animation(n, t[n], !0) : e[n] = t[n] }) }t.Updater = o, o.prototype.update = function (e) { const t = this; const i = this.graphs; const o = this.beforeUpdate; if ((function (e, t) { const n = e.graphs; const r = e.chart.render; const i = n.length; const o = t.length; if (i > o) { n.splice(o).forEach(function (e) { return e.forEach(function (e) { return r.delGraph(e) }) }) } }(this, e)), e.length) { const s = (0, r.default)(o); e.forEach(function (e, r) { s === 'function' && o(i, e, r, t); const l = i[r]; l ? (function (e, t, r, i) { const o = i.getGraphConfig; const s = i.chart.render; const l = i.beforeChange; const d = o(t, i); (function (e, t, r) { const i = e.length; const o = t.length; if (o > i) { const a = e.slice(-1)[0]; const s = new Array(o - i).fill(0).map(function (e) { return r.clone(a) }); e.push.apply(e, (0, n.default)(s)) } else if (o < i) { e.splice(o).forEach(function (e) { return r.delGraph(e) }) } })(e, d, s), e.forEach(function (e, t) { const n = d[t]; typeof l === 'function' && l(e, n), a(e, n) }) }(l, e, 0, t)) : (function (e, t, n, r) { const i = r.getGraphConfig; const o = r.getStartGraphConfig; const s = r.chart.render; let l = null; typeof o === 'function' && (l = o(t, r)); const d = i(t, r); if (!d.length) return; l ? (e[n] = l.map(function (e) { return s.add(e) }), e[n].forEach(function (e, t) { a(e, d[t]) })) : e[n] = d.map(function (e) { return s.add(e) }); const c = r.afterAddGraph; typeof c === 'function' && c(e[n]) }(i, e, r, t)) }) } } }); A(ln); ln.doUpdate, ln.Updater; const dn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.title = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = []; t.title && (n[0] = (0, W.deepMerge)((0, O.deepClone)(an.titleConfig, !0), t.title)); (0, ln.doUpdate)({ chart: e, series: n, key: 'title', getGraphConfig: r }) }; const n = b(S); function r (e, t) { const r = an.titleConfig.animationCurve; const i = an.titleConfig.animationFrame; const o = an.titleConfig.rLevel; const a = (function (e, t) { const r = e.offset; const i = e.text; const o = t.chart.gridArea; const a = o.x; const s = o.y; const l = o.w; const d = (0, n.default)(r, 2); const c = d[0]; const u = d[1]; return { content: i, position: [a + l / 2 + c, s + u] } }(e, t)); const s = (function (e) { return e.style }(e)); return [{ name: 'text', index: o, visible: e.show, animationCurve: r, animationFrame: i, shape: a, style: s }] } }); A(dn); dn.title; const cn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.grid = function (e) { let t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).grid; t = (0, W.deepMerge)((0, O.deepClone)(an.gridConfig, !0), t || {}), (0, ln.doUpdate)({ chart: e, series: [t], key: 'grid', getGraphConfig: o }) }; const n = b(S); const r = b(Pt); function i (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function o (e, t) { const o = e.animationCurve; const s = e.animationFrame; const l = e.rLevel; const d = (function (e, t) { const r = (0, n.default)(t.chart.render.area, 2); const i = r[0]; const o = r[1]; const s = a(e.left, i); const l = a(e.right, i); const d = a(e.top, o); const c = a(e.bottom, o); return { x: s, y: d, w: i - s - l, h: o - d - c } }(e, t)); const c = (function (e) { return e.style }(e)); return t.chart.gridArea = (function (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? i(n, !0).forEach(function (t) { (0, r.default)(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i(n).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e }({}, d)), [{ name: 'rect', index: l, animationCurve: o, animationFrame: s, shape: d, style: c }] } function a (e, t) { return typeof e === 'number' ? e : typeof e !== 'string' ? 0 : t * parseInt(e) / 100 } }); A(cn); cn.grid; const un = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.axis = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const i = t.xAxis; const a = t.yAxis; const c = t.series; let g = []; i && a && c && (g = (function (e, t) { const n = t.gridArea; const i = n.w; const a = n.h; return e.map(function (e) { const t = e.tickLinePosition; const n = e.position; const l = e.boundaryGap; let d = 0; let c = i; n !== 'top' && n !== 'bottom' || (d = 1), n !== 'top' && n !== 'bottom' || (c = a), n !== 'right' && n !== 'bottom' || (c *= -1); const u = t.map(function (e) { const t = (0, r.default)(e, 1)[0]; const n = (0, o.default)(t); return n[d] += c, [(0, o.default)(t), n] }); return l || u.shift(), s({}, e, { splitLinePosition: u }) }) }(g = (function (e, t) { return e.map(function (e) { const t = e.nameGap; const n = e.nameLocation; const i = e.position; const a = e.linePosition; const l = (0, r.default)(a, 2); const d = l[0]; const c = l[1]; let u = (0, o.default)(d); n === 'end' && (u = (0, o.default)(c)), n === 'center' && (u[0] = (d[0] + c[0]) / 2, u[1] = (d[1] + c[1]) / 2); let f = 0; i === 'top' && n === 'center' && (f = 1), i === 'bottom' && n === 'center' && (f = 1), i === 'left' && n !== 'center' && (f = 1), i === 'right' && n !== 'center' && (f = 1); let h = t; return i === 'top' && n !== 'end' && (h *= -1), i === 'left' && n !== 'start' && (h *= -1), i === 'bottom' && n === 'start' && (h *= -1), i === 'right' && n === 'end' && (h *= -1), u[f] += h, s({}, e, { namePosition: u }) }) }(g = (function (e, t) { return e.map(function (e) { const t = e.axis; const n = e.linePosition; const i = e.position; const o = e.label; let a = e.boundaryGap; typeof a !== 'boolean' && (a = l[t + 'AxisConfig'].boundaryGap); const d = o.length; const c = (0, r.default)(n, 2); const u = (0, r.default)(c[0], 2); const f = u[0]; const h = u[1]; const p = (0, r.default)(c[1], 2); const g = p[0]; const v = p[1]; const m = (t === 'x' ? g - f : v - h) / (a ? d : d - 1); const A = new Array(d).fill(0).map(function (e, n) { return t === 'x' ? [f + m * (a ? n + 0.5 : n), h] : [f, h + m * (a ? n + 0.5 : n)] }); const C = (function (e, t, n, i, o) { let a = e === 'x' ? 1 : 0; let s = 5; e === 'x' && n === 'top' && (s = -5); e === 'y' && n === 'left' && (s = -5); const l = i.map(function (e) { const t = (0, O.deepClone)(e); return t[a] += s, [(0, O.deepClone)(e), t] }); return t ? (a = e === 'x' ? 0 : 1, s = o / 2, l.forEach(function (e) { const t = (0, r.default)(e, 2); const n = t[0]; const i = t[1]; n[a] += s, i[a] += s }), l) : l }(t, a, i, A, m)); return s({}, e, { tickPosition: A, tickLinePosition: C, tickGap: m }) }) }(g = (function (e, t) { const n = t.gridArea; const r = n.x; const i = n.y; const o = n.w; const a = n.h; return e = e.map(function (e) { const t = e.position; let n = []; return t === 'left' ? n = [[r, i], [r, i + a]].reverse() : t === 'right' ? n = [[r + o, i], [r + o, i + a]].reverse() : t === 'top' ? n = [[r, i], [r + o, i]] : t === 'bottom' && (n = [[r, i + a], [r + o, i + a]]), s({}, e, { linePosition: n }) }) }(g = (function (e) { const t = e.filter(function (e) { return e.axis === 'x' }); const n = e.filter(function (e) { return e.axis === 'y' }); t[0] && !t[0].position && (t[0].position = an.xAxisConfig.position); t[1] && !t[1].position && (t[1].position = t[0].position === 'bottom' ? 'top' : 'bottom'); n[0] && !n[0].position && (n[0].position = an.yAxisConfig.position); n[1] && !n[1].position && (n[1].position = n[0].position === 'left' ? 'right' : 'left'); return [].concat((0, o.default)(t), (0, o.default)(n)) }(g = (function (e, t) { let i = e.filter(function (e) { return e.data === 'value' }); let a = e.filter(function (e) { return e.data instanceof Array }); return i = (function (e, t) { return e.map(function (e) { const i = (function (e, t) { if ((t = t.filter(function (e) { const t = e.show; const n = e.type; return !1 !== t && n !== 'pie' })).length === 0) return [0, 0]; const n = e.index; const r = e.axis; t = (function (e) { const t = (0, O.deepClone)(e, !0); return e.forEach(function (n, r) { const i = (0, W.mergeSameStackData)(n, e); t[r].data = i }), t }(t)); const i = r + 'Axis'; let a = t.filter(function (e) { return e[i] === n }); a.length || (a = t); return (function (e) { if (!e) return; const t = Math.min.apply(Math, (0, o.default)(e.map(function (e) { const t = e.data; return Math.min.apply(Math, (0, o.default)((0, W.filterNonNumber)(t))) }))); const n = Math.max.apply(Math, (0, o.default)(e.map(function (e) { const t = e.data; return Math.max.apply(Math, (0, o.default)((0, W.filterNonNumber)(t))) }))); return [t, n] }(a)) }(e, t)); const a = (function (e, t) { let i = e.min; let o = e.max; const a = e.axis; const s = (0, r.default)(t, 2); const c = s[0]; const h = s[1]; let p = (0, n.default)(i); let g = (0, n.default)(o); f(i) || (i = l[a + 'AxisConfig'].min, p = 'string'); f(o) || (o = l[a + 'AxisConfig'].max, g = 'string'); if (p === 'string') { const v = u(i = parseInt(c - d(c * parseFloat(i) / 100))); i = parseFloat((i / v - 0.1).toFixed(1)) * v } if (g === 'string') { const m = u(o = parseInt(h + d(h * parseFloat(o) / 100))); o = parseFloat((o / m + 0.1).toFixed(1)) * m } return [i, o] }(e, i)); const c = (0, r.default)(a, 2); const p = c[0]; const g = c[1]; const v = (function (e, t, n) { let r = n.interval; let i = n.minInterval; let o = n.maxInterval; let a = n.splitNumber; const s = n.axis; const d = l[s + 'AxisConfig']; typeof r !== 'number' && (r = d.interval); typeof i !== 'number' && (i = d.minInterval); typeof o !== 'number' && (o = d.maxInterval); typeof a !== 'number' && (a = d.splitNumber); if (typeof r === 'number') return r; let c = parseInt((t - e) / (a - 1)); c.toString().length > 1 && (c = parseInt(c.toString().replace(/\d$/, '0'))); c === 0 && (c = 1); return typeof i === 'number' && c < i ? i : typeof o === 'number' && c > o ? o : c }(p, g, e)); const m = e.axisLabel.formatter; let A = []; return s({}, e, { maxValue: (A = (A = i[0] === i[1] ? i : p < 0 && g > 0 ? (function (e, t, n) { const r = []; const i = []; let a = 0; let s = 0; do { r.push(a -= n) } while (a > e); do { i.push(s += n) } while (s < t); return [].concat((0, o.default)(r.reverse()), [0], (0, o.default)(i)) }(p, g, v)) : (function (e, t, n) { const r = [e]; let i = e; do { r.push(i += n) } while (i < t); return r }(p, g, v))).map(function (e) { return parseFloat(e.toFixed(2)) })).slice(-1)[0], minValue: A[0], label: h(A, m) }) }) }(i, t)), a = (function (e) { return e.map(function (e) { return s({}, e, { label: h(e.data, e.axisLabel.formatter) }) }) }(a)), [].concat((0, o.default)(i), (0, o.default)(a)) }(g = (function (e) { const t = e.filter(function (e) { return e.data === 'value' }); const n = e.filter(function (e) { return e.data !== 'value' }); return t.forEach(function (e) { typeof e.boundaryGap !== 'boolean' && (e.boundaryGap = !1) }), n.forEach(function (e) { typeof e.boundaryGap !== 'boolean' && (e.boundaryGap = !0) }), [].concat((0, o.default)(t), (0, o.default)(n)) }(g = (g = (function (e) { let t = e.filter(function (e) { return e.axis === 'x' }); let n = e.filter(function (e) { return e.axis === 'y' }); return t = t.map(function (e) { return (0, W.deepMerge)((0, O.deepClone)(an.xAxisConfig), e) }), n = n.map(function (e) { return (0, W.deepMerge)((0, O.deepClone)(an.yAxisConfig), e) }), [].concat((0, o.default)(t), (0, o.default)(n)) }(g = (function (e, t) { let n; let r; let i = []; let a = []; e instanceof Array ? (n = i).push.apply(n, (0, o.default)(e)) : i.push(e); t instanceof Array ? (r = a).push.apply(r, (0, o.default)(t)) : a.push(t); return i.splice(2), a.splice(2), i = i.map(function (e, t) { return s({}, e, { index: t, axis: 'x' }) }), a = a.map(function (e, t) { return s({}, e, { index: t, axis: 'y' }) }), [].concat((0, o.default)(i), (0, o.default)(a)) }(i, a))))).filter(function (e) { return e.show }))), c)))), e)))))), e))); (0, ln.doUpdate)({ chart: e, series: g, key: 'axisLine', getGraphConfig: p }), (0, ln.doUpdate)({ chart: e, series: g, key: 'axisTick', getGraphConfig: m }), (0, ln.doUpdate)({ chart: e, series: g, key: 'axisLabel', getGraphConfig: A }), (0, ln.doUpdate)({ chart: e, series: g, key: 'axisName', getGraphConfig: y }), (0, ln.doUpdate)({ chart: e, series: g, key: 'splitLine', getGraphConfig: B }), e.axisData = g }; var n = b(k); var r = b(S); const i = b(Pt); var o = b(E); function a (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function s (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? a(n, !0).forEach(function (t) { (0, i.default)(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a(n).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } var l = { xAxisConfig: an.xAxisConfig, yAxisConfig: an.yAxisConfig }; var d = Math.abs; const c = Math.pow; function u (e) { const t = d(e).toString(); const n = t.length; const r = t.replace(/0*$/g, '').indexOf('0'); let i = n - 1; return r !== -1 && (i -= r), c(10, i) } function f (e) { const t = (0, n.default)(e); return t === 'string' && /^\d+%$/.test(e) || t === 'number' } function h (e, t) { return t ? (typeof t === 'string' && (e = e.map(function (e) { return t.replace('{value}', e) })), typeof t === 'function' && (e = e.map(function (e, n) { return t({ value: e, index: n }) })), e) : e } function p (e) { const t = e.animationCurve; const n = e.animationFrame; return [{ name: 'polyline', index: e.rLevel, visible: e.axisLine.show, animationCurve: t, animationFrame: n, shape: g(e), style: v(e) }] } function g (e) { return { points: e.linePosition } } function v (e) { return e.axisLine.style } function m (e) { const t = e.animationCurve; const n = e.animationFrame; const r = e.rLevel; const i = (function (e) { return e.tickLinePosition.map(function (e) { return { points: e } }) }(e)); const o = (function (e) { return e.axisTick.style }(e)); return i.map(function (i) { return { name: 'polyline', index: r, visible: e.axisTick.show, animationCurve: t, animationFrame: n, shape: i, style: o } }) } function A (e) { const t = e.animationCurve; const n = e.animationFrame; const r = e.rLevel; const i = (function (e) { const t = e.label; const n = e.tickPosition; const r = e.position; return n.map(function (e, n) { return { position: C(e, r), content: t[n].toString() } }) }(e)); const o = (function (e, t) { const n = e.position; let r = e.axisLabel.style; const i = (function (e) { if (e === 'left') return { textAlign: 'right', textBaseline: 'middle' }; if (e === 'right') return { textAlign: 'left', textBaseline: 'middle' }; if (e === 'top') return { textAlign: 'center', textBaseline: 'bottom' }; if (e === 'bottom') return { textAlign: 'center', textBaseline: 'top' } }(n)); return r = (0, W.deepMerge)(i, r), t.map(function (e) { const t = e.position; return s({}, r, { graphCenter: t }) }) }(e, i)); return i.map(function (i, a) { return { name: 'text', index: r, visible: e.axisLabel.show, animationCurve: t, animationFrame: n, shape: i, style: o[a], setGraphCenter: function () {} } }) } function C (e, t) { let n = 0; let r = 10; return t !== 'top' && t !== 'bottom' || (n = 1), t !== 'top' && t !== 'left' || (r = -10), (e = (0, O.deepClone)(e))[n] += r, e } function y (e) { const t = e.animationCurve; const n = e.animationFrame; return [{ name: 'text', index: e.rLevel, animationCurve: t, animationFrame: n, shape: x(e), style: w(e) }] } function x (e) { return { content: e.name, position: e.namePosition } } function w (e) { const t = e.nameLocation; const n = e.position; const r = e.nameTextStyle; const i = (function (e, t) { if (e === 'top' && t === 'start' || e === 'bottom' && t === 'start' || e === 'left' && t === 'center') return { textAlign: 'right', textBaseline: 'middle' }; if (e === 'top' && t === 'end' || e === 'bottom' && t === 'end' || e === 'right' && t === 'center') return { textAlign: 'left', textBaseline: 'middle' }; if (e === 'top' && t === 'center' || e === 'left' && t === 'end' || e === 'right' && t === 'end') return { textAlign: 'center', textBaseline: 'bottom' }; if (e === 'bottom' && t === 'center' || e === 'left' && t === 'start' || e === 'right' && t === 'start') return { textAlign: 'center', textBaseline: 'top' } }(n, t)); return (0, W.deepMerge)(i, r) } function B (e) { const t = e.animationCurve; const n = e.animationFrame; const r = e.rLevel; const i = (function (e) { return e.splitLinePosition.map(function (e) { return { points: e } }) }(e)); const o = (function (e) { return e.splitLine.style }(e)); return i.map(function (i) { return { name: 'polyline', index: r, visible: e.splitLine.show, animationCurve: t, animationFrame: n, shape: i, style: o } }) } }); A(un); un.axis; const fn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.line = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = t.xAxis; const r = t.yAxis; const i = t.series; let o = []; n && r && i && (o = (function (e, t) { const n = t.axisData; return e.map(function (t) { let r = (0, W.mergeSameStackData)(t, e); r = (function (e, t) { const n = e.data; return t.map(function (e, t) { return typeof n[t] === 'number' ? e : null }) }(t, r)); const i = (function (e, t) { const n = e.xAxisIndex; const r = e.yAxisIndex; const i = t.find(function (e) { const t = e.axis; const r = e.index; return t === 'x' && r === n }); const o = t.find(function (e) { const t = e.axis; const n = e.index; return t === 'y' && n === r }); return [i, o] }(t, n)); const o = (function (e, t) { const n = t.findIndex(function (e) { return e.data === 'value' }); const r = t[n]; const i = t[1 - n]; const o = r.linePosition; const a = r.axis; const s = i.tickPosition; const l = s.length; const d = a === 'x' ? 0 : 1; const c = o[0][d]; const u = o[1][d] - c; const f = r.maxValue; const h = r.minValue; const p = f - h; return new Array(l).fill(0).map(function (t, n) { const r = e[n]; if (typeof r !== 'number') return null; let i = (r - h) / p; return p === 0 && (i = 0), i * u + c }).map(function (e, t) { if (t >= l || typeof e !== 'number') return null; const n = [e, s[t][1 - d]]; return d === 0 ? n : (n.reverse(), n) }) }(r, i)); const a = (function (e) { const t = e.find(function (e) { return e.data === 'value' }); const n = t.axis; const r = t.linePosition; const i = t.minValue; const o = t.maxValue; const a = n === 'x' ? 0 : 1; let s = r[0][a]; if (i < 0 && o > 0) { const l = o - i; const d = Math.abs(r[0][a] - r[1][a]); let c = Math.abs(i) / l * d; n === 'y' && (c *= -1), s += c } return { changeIndex: a, changeValue: s } }(i)); return l({}, t, { linePosition: o.filter(function (e) { return e }), lineFillBottomPos: a }) }) }(o = (0, W.initNeedSeries)(i, an.lineConfig, 'line'), e))); (0, ln.doUpdate)({ chart: e, series: o, key: 'lineArea', getGraphConfig: u, getStartGraphConfig: g, beforeUpdate: v, beforeChange: m }), (0, ln.doUpdate)({ chart: e, series: o, key: 'line', getGraphConfig: A, getStartGraphConfig: x, beforeUpdate: v, beforeChange: m }), (0, ln.doUpdate)({ chart: e, series: o, key: 'linePoint', getGraphConfig: w, getStartGraphConfig: B }), (0, ln.doUpdate)({ chart: e, series: o, key: 'lineLabel', getGraphConfig: P }) }; const n = b(k); const r = b(S); const i = b(E); const o = b(Pt); const a = b(Ot); function s (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function l (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? s(n, !0).forEach(function (t) { (0, o.default)(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s(n).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } const d = a.default.polylineToBezierCurve; const c = a.default.getBezierCurveLength; function u (e) { const t = e.animationCurve; const n = e.animationFrame; const r = e.lineFillBottomPos; const i = e.rLevel; return [{ name: C(e), index: i, animationCurve: t, animationFrame: n, visible: e.lineArea.show, lineFillBottomPos: r, shape: f(e), style: h(e), drawed: p }] } function f (e) { return { points: e.linePosition } } function h (e) { const t = e.lineArea; const n = e.color; const r = t.gradient; let o = t.style; const a = [o.fill || n]; const s = (0, W.deepMerge)(a, r); s.length === 1 && s.push(s[0]); const d = (function (e) { const t = e.lineFillBottomPos; const n = e.linePosition; const r = t.changeIndex; const o = t.changeValue; const a = n.map(function (e) { return e[r] }); const s = Math.max.apply(Math, (0, i.default)(a)); const l = Math.min.apply(Math, (0, i.default)(a)); let d = s; r === 1 && (d = l); return r === 1 ? [0, d, 0, o] : [d, 0, o, 0] }(e)); return o = l({}, o, { stroke: 'rgba(0, 0, 0, 0)' }), (0, W.deepMerge)({ gradientColor: s, gradientParams: d, gradientType: 'linear', gradientWith: 'fill' }, o) } function p (e, t) { const n = e.lineFillBottomPos; const r = e.shape; const o = t.ctx; const a = r.points; const s = n.changeIndex; const l = n.changeValue; const d = (0, i.default)(a[a.length - 1]); const c = (0, i.default)(a[0]); d[s] = l, c[s] = l, o.lineTo.apply(o, (0, i.default)(d)), o.lineTo.apply(o, (0, i.default)(c)), o.closePath(), o.fill() } function g (e) { const t = u(e)[0]; const n = l({}, t.style); return n.opacity = 0, t.style = n, [t] } function v (e, t, n, r) { const i = e[n]; if (i) { const o = C(t); const a = r.chart.render; o !== i[0].name && (i.forEach(function (e) { return a.delGraph(e) }), e[n] = null) } } function m (e, t) { const n = t.shape.points; const r = e.shape.points; const o = r.length; const a = n.length; if (a > o) { const s = r.slice(-1)[0]; const l = new Array(a - o).fill(0).map(function (e) { return (0, i.default)(s) }); r.push.apply(r, (0, i.default)(l)) } else a < o && r.splice(a) } function A (e) { const t = e.animationCurve; const n = e.animationFrame; const r = e.rLevel; return [{ name: C(e), index: r + 1, animationCurve: t, animationFrame: n, shape: f(e), style: y(e) }] } function C (e) { return e.smooth ? 'smoothline' : 'polyline' } function y (e) { const t = e.lineStyle; const n = e.color; const r = e.smooth; const i = (function (e) { if (!(arguments.length > 1 && void 0 !== arguments[1] && arguments[1])) return (0, W.getPolylineLength)(e); const t = d(e); return c(t) }(e.linePosition, r)); return (0, W.deepMerge)({ stroke: n, lineDash: [i, 0] }, t) } function x (e) { const t = e.lineStyle.lineDash; const n = A(e)[0]; let r = n.style.lineDash; return r = t ? [0, 0] : (0, i.default)(r).reverse(), n.style.lineDash = r, [n] } function w (e) { const t = e.animationCurve; const n = e.animationFrame; const i = e.rLevel; const o = (function (e) { const t = e.linePosition; const n = e.linePoint.radius; return t.map(function (e) { const t = (0, r.default)(e, 2); const i = t[0]; const o = t[1]; return { r: n, rx: i, ry: o } }) }(e)); const a = (function (e) { const t = e.color; const n = e.linePoint.style; return (0, W.deepMerge)({ stroke: t }, n) }(e)); return o.map(function (r) { return { name: 'circle', index: i + 2, visible: e.linePoint.show, animationCurve: t, animationFrame: n, shape: r, style: a } }) } function B (e) { const t = w(e); return t.forEach(function (e) { e.shape.r = 0.1 }), t } function P (e) { const t = e.animationCurve; const o = e.animationFrame; const a = e.rLevel; const s = (function (e) { const t = (function (e) { let t = e.data; const r = e.label.formatter; if (t = t.filter(function (e) { return typeof e === 'number' }).map(function (e) { return e.toString() }), !r) return t; const i = (0, n.default)(r); return i === 'string' ? t.map(function (e) { return r.replace('{value}', e) }) : i === 'function' ? t.map(function (e, t) { return r({ value: e, index: t }) }) : t }(e)); const o = (function (e) { const t = e.linePosition; const n = e.lineFillBottomPos; const o = e.label; const a = o.position; const s = o.offset; const l = n.changeIndex; const d = n.changeValue; return t.map(function (e) { if (a === 'bottom' && ((e = (0, i.default)(e))[l] = d), a === 'center') { const t = (0, i.default)(e); t[l] = d, n = e, o = t, c = (0, r.default)(n, 2), u = c[0], f = c[1], h = (0, r.default)(o, 2), p = h[0], g = h[1], e = [(u + p) / 2, (f + g) / 2] } let n, o, c, u, f, h, p, g, v, m, A, C, b, y, x, w; return v = e, m = s, A = (0, r.default)(v, 2), C = A[0], b = A[1], y = (0, r.default)(m, 2), x = y[0], w = y[1], [C + x, b + w] }) }(e)); return t.map(function (e, t) { return { content: e, position: o[t] } }) }(e)); const l = (function (e) { const t = e.color; const n = e.label.style; return (0, W.deepMerge)({ fill: t }, n) }(e)); return s.map(function (n, r) { return { name: 'text', index: a + 3, visible: e.label.show, animationCurve: t, animationFrame: o, shape: n, style: l } }) } }); A(fn); fn.line; const hn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.bar = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = t.xAxis; const r = t.yAxis; const a = t.series; let f = []; n && r && a && (f = (function (e, t) { return e = (function (e) { return e.forEach(function (e) { const t = e.data; const n = e.barLabelAxisPos; const r = e.barValueAxisPos; const i = t.filter(function (e) { return typeof e === 'number' }).length; n.length > i && (n.splice(i), r.splice(i)) }), e }(e = (function (e) { return e.map(function (e) { const t = e.barLabelAxisPos; return e.data.forEach(function (e, n) { typeof e !== 'number' && (t[n] = null) }), s({}, e, { barLabelAxisPos: t.filter(function (e) { return e !== null }) }) }) }(e = (function (e) { return e.map(function (e) { const t = e.labelAxis; const n = e.barAllWidthAndGap; const r = e.barGap; const i = e.barWidth; const o = e.barIndex; const a = t.tickGap; const l = t.tickPosition; const d = t.axis === 'x' ? 0 : 1; return s({}, e, { barLabelAxisPos: l.map(function (e, t) { return l[t][d] - a / 2 + (a - n) / 2 + (o + 0.5) * i + o * r }) }) }) }(e = (function (e) { return e.map(function (t) { let n = (0, W.mergeSameStackData)(t, e); n = (function (e, t) { const n = e.data; return t.map(function (e, t) { return typeof n[t] === 'number' ? e : null }).filter(function (e) { return e !== null }) }(t, n)); const r = t.valueAxis; const i = r.axis; const o = r.minValue; const a = r.maxValue; const l = r.linePosition; const c = d(o, a, o < 0 ? 0 : o, l, i); return s({}, t, { barValueAxisPos: n.map(function (e) { return d(o, a, e, l, i) }).map(function (e) { return [c, e] }) }) }) }(e)))))))) }(f = (function (e, t) { return l(e).forEach(function (e) { !(function (e) { let t = (function (e) { const t = []; return e.forEach(function (e) { const n = e.stack; n && t.push(n) }), (0, o.default)(new Set(t)) }(e)); t = t.map(function (e) { return { stack: e, index: -1 } }); let n = 0; e.forEach(function (e) { const r = e.stack; if (r) { const i = t.find(function (e) { return e.stack === r }); i.index === -1 && (i.index = n, n++), e.barIndex = i.index } else e.barIndex = n, n++ }) }(e)), (function (e) { const t = (0, o.default)(new Set(e.map(function (e) { return e.barIndex }))).length; e.forEach(function (e) { return e.barNum = t }) }(e)), (function (e) { const t = e.slice(-1)[0]; const n = t.barCategoryGap; const r = t.labelAxis.tickGap; let i = 0; i = typeof n === 'number' ? n : (1 - parseInt(n) / 100) * r; e.forEach(function (e) { return e.barCategoryWidth = i }) }(e)), (function (e) { const t = e.slice(-1)[0]; const n = t.barCategoryWidth; const r = t.barWidth; const o = t.barGap; const a = t.barNum; let s = []; typeof r === 'number' || r !== 'auto' ? s = (function (e, t, n) { let r = 0; let i = 0; r = typeof t === 'number' ? t : parseInt(t) / 100 * e; i = typeof n === 'number' ? n : parseInt(n) / 100 * r; return [r, i] }(n, r, o)) : r === 'auto' && (s = (function (e, t, n, r) { let i = 0; let o = 0; const a = e / r; if (typeof n === 'number')i = a - (o = n); else { const s = 10 + parseInt(n) / 10; o = s === 0 ? -(i = 2 * a) : a - (i = a / s * 10) } return [i, o] }(n, 0, o, a))); const l = s; const d = (0, i.default)(l, 2); const c = d[0]; const u = d[1]; e.forEach(function (e) { e.barWidth = c, e.barGap = u }) }(e)), (function (e) { const t = e.slice(-1)[0]; const n = t.barGap; const r = t.barWidth; const i = t.barNum; const o = (n + r) * i - n; e.forEach(function (e) { return e.barAllWidthAndGap = o }) }(e)) }), e }(f = (function (e, t) { const n = t.axisData; return e.forEach(function (e) { let t = e.xAxisIndex; let r = e.yAxisIndex; typeof t !== 'number' && (t = 0), typeof r !== 'number' && (r = 0); const i = [n.find(function (e) { const n = e.axis; const r = e.index; return ''.concat(n).concat(r) === 'x'.concat(t) }), n.find(function (e) { const t = e.axis; const n = e.index; return ''.concat(t).concat(n) === 'y'.concat(r) })]; const o = i.findIndex(function (e) { return e.data === 'value' }); e.valueAxis = i[o], e.labelAxis = i[1 - o] }), e }(f = (0, W.initNeedSeries)(a, an.barConfig, 'bar'), e))))))); (0, ln.doUpdate)({ chart: e, series: f.slice(-1), key: 'backgroundBar', getGraphConfig: c }), f.reverse(), (0, ln.doUpdate)({ chart: e, series: f, key: 'bar', getGraphConfig: u, getStartGraphConfig: g, beforeUpdate: v }), (0, ln.doUpdate)({ chart: e, series: f, key: 'barLabel', getGraphConfig: m }) }; const n = b(k); const r = b(Pt); var i = b(S); var o = b(E); function a (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function s (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? a(n, !0).forEach(function (t) { (0, r.default)(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a(n).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function l (e) { let t = e.map(function (e) { const t = e.labelAxis; return t.axis + t.index }); return (t = (0, o.default)(new Set(t))).map(function (t) { return e.filter(function (e) { const n = e.labelAxis; return n.axis + n.index === t }) }) } function d (e, t, n, r, i) { if (typeof n !== 'number') return null; const o = t - e; const a = i === 'x' ? 0 : 1; let s = (n - e) / o; return o === 0 && (s = 0), s * (r[1][a] - r[0][a]) + r[0][a] } function c (e) { const t = e.animationCurve; const n = e.animationFrame; const r = e.rLevel; const i = (function (e) { const t = e.labelAxis; const n = e.valueAxis; const r = t.tickPosition; const i = n.axis; const o = n.linePosition; const a = (function (e) { const t = e.barAllWidthAndGap; const n = e.barCategoryWidth; const r = e.backgroundBar.width; return typeof r === 'number' ? r : r === 'auto' ? t : parseInt(r) / 100 * n }(e)); const s = a / 2; const l = i === 'x' ? 0 : 1; const d = r.map(function (e) { return e[1 - l] }); const c = [o[0][l], o[1][l]]; const u = c[0]; const f = c[1]; return d.map(function (e) { return i === 'x' ? { x: u, y: e - s, w: f - u, h: a } : { x: e - s, y: f, w: a, h: u - f } }) }(e)); const o = (function (e) { return e.backgroundBar.style }(e)); return i.map(function (i) { return { name: 'rect', index: r, visible: e.backgroundBar.show, animationCurve: t, animationFrame: n, shape: i, style: o } }) } function u (e) { const t = e.barLabelAxisPos; const n = e.animationCurve; const r = e.animationFrame; const i = e.rLevel; const o = f(e); return t.map(function (t, a) { return { name: o, index: i, animationCurve: n, animationFrame: r, shape: h(e, a), style: p(e, a) } }) } function f (e) { const t = e.shapeType; return t === 'leftEchelon' || t === 'rightEchelon' ? 'polyline' : 'rect' } function h (e, t) { const n = e.shapeType; return n === 'leftEchelon' ? (function (e, t) { const n = e.barValueAxisPos; const r = e.barLabelAxisPos; const o = e.barWidth; const a = e.echelonOffset; const s = (0, i.default)(n[t], 2); const l = s[0]; const d = s[1]; const c = r[t]; const u = o / 2; const f = e.valueAxis.axis; const h = []; f === 'x' ? (h[0] = [d, c - u], h[1] = [d, c + u], h[2] = [l, c + u], h[3] = [l + a, c - u], d - l < a && h.splice(3, 1)) : (h[0] = [c - u, d], h[1] = [c + u, d], h[2] = [c + u, l], h[3] = [c - u, l - a], l - d < a && h.splice(3, 1)); return { points: h, close: !0 } }(e, t)) : n === 'rightEchelon' ? (function (e, t) { const n = e.barValueAxisPos; const r = e.barLabelAxisPos; const o = e.barWidth; const a = e.echelonOffset; const s = (0, i.default)(n[t], 2); const l = s[0]; const d = s[1]; const c = r[t]; const u = o / 2; const f = e.valueAxis.axis; const h = []; f === 'x' ? (h[0] = [d, c + u], h[1] = [d, c - u], h[2] = [l, c - u], h[3] = [l + a, c + u], d - l < a && h.splice(2, 1)) : (h[0] = [c + u, d], h[1] = [c - u, d], h[2] = [c - u, l], h[3] = [c + u, l - a], l - d < a && h.splice(2, 1)); return { points: h, close: !0 } }(e, t)) : (function (e, t) { const n = e.barValueAxisPos; const r = e.barLabelAxisPos; const o = e.barWidth; const a = (0, i.default)(n[t], 2); const s = a[0]; const l = a[1]; const d = r[t]; const c = e.valueAxis.axis; const u = {}; c === 'x' ? (u.x = s, u.y = d - o / 2, u.w = l - s, u.h = o) : (u.x = d - o / 2, u.y = l, u.w = o, u.h = s - l); return u }(e, t)) } function p (e, t) { const n = e.barStyle; const r = e.gradient; const o = e.color; const a = [n.fill || o]; const s = (0, W.deepMerge)(a, r.color); s.length === 1 && s.push(s[0]); const l = (function (e, t) { const n = e.barValueAxisPos; const r = e.barLabelAxisPos; const o = e.data; const a = e.valueAxis; const s = a.linePosition; const l = a.axis; const d = (0, i.default)(n[t], 2); const c = d[0]; const u = d[1]; const f = r[t]; const h = o[t]; const p = (0, i.default)(s, 2); const g = p[0]; const v = p[1]; const m = l === 'x' ? 0 : 1; let A = u; e.gradient.local || (A = h < 0 ? g[m] : v[m]); return l === 'y' ? [f, A, f, c] : [A, f, c, f] }(e, t)); return (0, W.deepMerge)({ gradientColor: s, gradientParams: l, gradientType: 'linear', gradientWith: 'fill' }, n) } function g (e) { const t = u(e); const n = e.shapeType; return t.forEach(function (t) { let r = t.shape; r = n === 'leftEchelon' ? (function (e, t) { const n = t.valueAxis.axis; const r = (e = (0, O.deepClone)(e)).points; const i = n === 'x' ? 0 : 1; const o = r[2][i]; return r.forEach(function (e) { return e[i] = o }), e }(r, e)) : n === 'rightEchelon' ? (function (e, t) { const n = t.valueAxis.axis; const r = (e = (0, O.deepClone)(e)).points; const i = n === 'x' ? 0 : 1; const o = r[2][i]; return r.forEach(function (e) { return e[i] = o }), e }(r, e)) : (function (e, t) { const n = t.valueAxis.axis; const r = e.x; let i = e.y; let o = e.w; let a = e.h; n === 'x' ? o = 0 : (i += a, a = 0); return { x: r, y: i, w: o, h: a } }(r, e)), t.shape = r }), t } function v (e, t, n, r) { const i = r.chart.render; const o = f(t); e[n] && e[n][0].name !== o && (e[n].forEach(function (e) { return i.delGraph(e) }), e[n] = null) } function m (e) { const t = e.animationCurve; const r = e.animationFrame; const o = e.rLevel; const a = (function (e) { const t = (function (e) { let t = e.data; const r = e.label.formatter; if (t = t.filter(function (e) { return typeof e === 'number' }).map(function (e) { return e.toString() }), !r) return t; const i = (0, n.default)(r); return i === 'string' ? t.map(function (e) { return r.replace('{value}', e) }) : i === 'function' ? t.map(function (e, t) { return r({ value: e, index: t }) }) : t }(e)); return (function (e) { const t = e.label; const n = e.barValueAxisPos; const r = e.barLabelAxisPos; const o = t.position; const a = t.offset; const s = e.valueAxis.axis; return n.map(function (e, t) { let n; let l; let d; let c; let u; let f; let h; let p; const g = (0, i.default)(e, 2); const v = g[0]; const m = g[1]; const A = r[t]; let C = [m, A]; return o === 'bottom' && (C = [v, A]), o === 'center' && (C = [(v + m) / 2, A]), s === 'y' && C.reverse(), n = C, l = a, d = (0, i.default)(n, 2), c = d[0], u = d[1], f = (0, i.default)(l, 2), h = f[0], p = f[1], [c + h, u + p] }) }(e)).map(function (e, n) { return { position: e, content: t[n] } }) }(e)); const s = (function (e) { let t = e.color; let n = e.label.style; const r = e.gradient.color; r.length && (t = r[0]); return n = (0, W.deepMerge)({ fill: t }, n) }(e)); return a.map(function (n) { return { name: 'text', index: o, visible: e.label.show, animationCurve: t, animationFrame: r, shape: n, style: s } }) } }); A(hn); hn.bar; const pn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.pie = function (e) { let t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).series; t || (t = []); let n = (0, W.initNeedSeries)(t, en.pieConfig, 'pie'); n = (function (e) { return e.forEach(function (e) { let t = d(e); let n = d(e, !1); t = c(t), n = c(n), u(t, e), u(n, e, !1) }), e }(n = (function (e) { return e.forEach(function (e) { const t = e.data; const n = e.center; t.forEach(function (e) { const t = e.startAngle; const r = e.endAngle; const i = e.radius; const a = (t + r) / 2; const s = O.getCircleRadianPoint.apply(void 0, (0, o.default)(n).concat([i[1], a])); e.edgeCenterPos = s }) }), e }(n = (function (e) { return e.forEach(function (e) { e.data.forEach(function (t) { t.insideLabelPos = (function (e, t) { const n = e.center; const r = t.startAngle; const a = t.endAngle; const s = (0, i.default)(t.radius, 2); const l = s[0]; const d = s[1]; const c = (l + d) / 2; const u = (r + a) / 2; return O.getCircleRadianPoint.apply(void 0, (0, o.default)(n).concat([c, u])) }(e, t)) }) }), e }(n = (function (e) { return e.forEach(function (e) { const t = e.startAngle; const n = e.data; n.forEach(function (e, r) { const o = (function (e, t) { const n = 2 * Math.PI; const r = e.slice(0, t + 1); const i = (0, W.mulAdd)(r.map(function (e) { return e.percent })); const o = e[t].percent; return [n * (i - o) / 100, n * i / 100] }(n, r)); const a = (0, i.default)(o, 2); const s = a[0]; const l = a[1]; e.startAngle = t + s, e.endAngle = t + l }) }), e }(n = (function (e) { return e.forEach(function (e) { const t = e.data; const n = e.percentToFixed; const r = (function (e) { return (0, W.mulAdd)(e.map(function (e) { return e.value })) }(t)); t.forEach(function (e) { const t = e.value; e.percent = parseFloat((t / r * 100).toFixed(n)) }); const i = (0, W.mulAdd)(t.slice(0, -1).map(function (e) { return e.percent })); t.slice(-1)[0].percent = 100 - i }), e }(n = (function (e, t) { return e.filter(function (e) { const t = e.roseType; return t }).forEach(function (e) { const t = e.radius; let n = e.data; const r = e.roseSort; const i = (function (e) { const t = e.radius; const n = e.roseIncrement; if (typeof n === 'number') return n; if (n === 'auto') { const r = e.data; const i = r.reduce(function (e, t) { const n = t.radius; return [].concat((0, o.default)(e), (0, o.default)(n)) }, []); const a = Math.min.apply(Math, (0, o.default)(i)); return 0.6 * (Math.max.apply(Math, (0, o.default)(i)) - a) / (r.length - 1 || 1) } return parseInt(n) / 100 * t[1] }(e)); const a = (0, o.default)(n); (n = (function (e) { return e.sort(function (e, t) { const n = e.value; const r = t.value; return n === r ? 0 : n > r ? -1 : n < r ? 1 : void 0 }) }(n))).forEach(function (e, n) { e.radius[1] = t[1] - i * n }), r ? n.reverse() : e.data = a, e.roseIncrement = i }), e }(n = (function (e, t) { const n = Math.min.apply(Math, (0, o.default)(t.render.area)) / 2; return e.forEach(function (e) { let t = e.radius; const r = e.data; t = s(t, n), r.forEach(function (e) { let r = e.radius; r || (r = t), r = s(r, n), e.radius = r }), e.radius = t }), e }(n = (function (e, t) { const n = t.render.area; return e.forEach(function (e) { let t = e.center; t = t.map(function (e, t) { return typeof e === 'number' ? e : parseInt(e) / 100 * n[t] }), e.center = t }), e }(n, e)), e)))))))))))))), (0, ln.doUpdate)({ chart: e, series: n, key: 'pie', getGraphConfig: f, getStartGraphConfig: h, beforeChange: p }), (0, ln.doUpdate)({ chart: e, series: n, key: 'pieInsideLabel', getGraphConfig: m }), (0, ln.doUpdate)({ chart: e, series: n, key: 'pieOutsideLabelLine', getGraphConfig: y, getStartGraphConfig: x }), (0, ln.doUpdate)({ chart: e, series: n, key: 'pieOutsideLabel', getGraphConfig: P, getStartGraphConfig: _ }) }; const n = b(Pt); const r = b(k); var i = b(S); var o = b(E); function a (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function s (e, t) { return e instanceof Array || (e = [0, e]), e = e.map(function (e) { return typeof e === 'number' ? e : parseInt(e) / 100 * t }) } function l (e) { let t = e.outsideLabel.labelLineBendGap; const n = (function (e) { const t = e.data.map(function (e) { const t = (0, i.default)(e.radius, 2); t[0]; return t[1] }); return Math.max.apply(Math, (0, o.default)(t)) }(e)); return typeof t !== 'number' && (t = parseInt(t) / 100 * n), t + n } function d (e) { const t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const n = e.data; const r = e.center[0]; return n.filter(function (e) { const n = e.edgeCenterPos[0]; return t ? n <= r : n > r }) } function c (e) { return e.sort(function (e, t) { const n = (0, i.default)(e.edgeCenterPos, 2); const r = (n[0], n[1]); const o = (0, i.default)(t.edgeCenterPos, 2); const a = (o[0], o[1]); return r > a ? 1 : r < a ? -1 : r === a ? 0 : void 0 }), e } function u (e, t) { const n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; const r = t.center; const i = t.outsideLabel; const a = l(t); e.forEach(function (e) { const t = e.edgeCenterPos; const s = e.startAngle; const l = e.endAngle; const d = i.labelLineEndLength; const c = (s + l) / 2; const u = O.getCircleRadianPoint.apply(void 0, (0, o.default)(r).concat([a, c])); const f = (0, o.default)(u); f[0] += d * (n ? -1 : 1), e.labelLine = [t, u, f], e.labelLineLength = (0, W.getPolylineLength)(e.labelLine), e.align = { textAlign: 'left', textBaseline: 'middle' }, n && (e.align.textAlign = 'right') }) } function f (e) { const t = e.data; const n = e.animationCurve; const r = e.animationFrame; const i = e.rLevel; return t.map(function (t, o) { return { name: 'pie', index: i, animationCurve: n, animationFrame: r, shape: g(e, o), style: v(e, o) } }) } function h (e) { const t = e.animationDelayGap; const n = e.startAnimationCurve; const r = f(e); return r.forEach(function (e, r) { e.animationCurve = n, e.animationDelay = r * t, e.shape.or = e.shape.ir }), r } function p (e) { e.animationDelay = 0 } function g (e, t) { const n = e.center; const r = e.data[t]; const i = r.radius; return { startAngle: r.startAngle, endAngle: r.endAngle, ir: i[0], or: i[1], rx: n[0], ry: n[1] } } function v (e, t) { const n = e.pieStyle; const r = e.data[t].color; return (0, W.deepMerge)({ fill: r }, n) } function m (e) { const t = e.animationCurve; const n = e.animationFrame; const r = e.data; const i = e.rLevel; return r.map(function (r, o) { return { name: 'text', index: i, visible: e.insideLabel.show, animationCurve: t, animationFrame: n, shape: A(e, o), style: C(e) } }) } function A (e, t) { const n = e.insideLabel; const i = e.data; const o = n.formatter; const a = i[t]; const s = (0, r.default)(o); let l = ''; return s === 'string' && (l = (l = (l = o.replace('{name}', a.name)).replace('{percent}', a.percent)).replace('{value}', a.value)), s === 'function' && (l = o(a)), { content: l, position: a.insideLabelPos } } function C (e, t) { return e.insideLabel.style } function y (e) { const t = e.animationCurve; const n = e.animationFrame; const r = e.data; const i = e.rLevel; return r.map(function (r, o) { return { name: 'polyline', index: i, visible: e.outsideLabel.show, animationCurve: t, animationFrame: n, shape: w(e, o), style: B(e, o) } }) } function x (e) { const t = e.data; const n = y(e); return n.forEach(function (e, n) { e.style.lineDash = [0, t[n].labelLineLength] }), n } function w (e, t) { return { points: e.data[t].labelLine } } function B (e, t) { const n = e.outsideLabel; const r = e.data; const i = n.labelLineStyle; const o = r[t].color; return (0, W.deepMerge)({ stroke: o, lineDash: [r[t].labelLineLength, 0] }, i) } function P (e) { const t = e.animationCurve; const n = e.animationFrame; const r = e.data; const i = e.rLevel; return r.map(function (r, o) { return { name: 'text', index: i, visible: e.outsideLabel.show, animationCurve: t, animationFrame: n, shape: I(e, o), style: L(e, o) } }) } function _ (e) { const t = e.data; const n = P(e); return n.forEach(function (e, n) { e.shape.position = t[n].labelLine[1] }), n } function I (e, t) { const n = e.outsideLabel; const i = e.data; const o = n.formatter; const a = i[t]; const s = a.labelLine; const l = a.name; const d = a.percent; const c = a.value; const u = (0, r.default)(o); let f = ''; return u === 'string' && (f = (f = (f = o.replace('{name}', l)).replace('{percent}', d)).replace('{value}', c)), u === 'function' && (f = o(i[t])), { content: f, position: s[2] } } function L (e, t) { const r = e.outsideLabel; const i = e.data[t]; const o = i.color; const s = i.align; const l = r.style; return (0, W.deepMerge)((function (e) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; t % 2 ? a(r, !0).forEach(function (t) { (0, n.default)(e, t, r[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : a(r).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t)) }) } return e }({ fill: o }, s)), l) } }); A(pn); pn.pie; const gn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.radarAxis = function (e) { const t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).radar; let n = []; t && (n = [n = (function (e) { const t = e.axisLineAngles; const n = e.centerPos; let r = e.radius; const o = e.axisLabel; return r += o.labelGap, e.axisLabelPosition = t.map(function (e) { return O.getCircleRadianPoint.apply(void 0, (0, i.default)(n).concat([r, e])) }), e }(n = (function (e) { const t = e.ringRadius; const n = t[0] / 2; return e.areaRadius = t.map(function (e) { return e - n }), e }(n = (function (e) { const t = e.indicator; const n = e.centerPos; const r = e.radius; const o = e.startAngle; const a = 2 * Math.PI; const s = t.length; const l = a / s; const d = new Array(s).fill(0).map(function (e, t) { return l * t + o }); return e.axisLineAngles = d, e.axisLinePosition = d.map(function (e) { return O.getCircleRadianPoint.apply(void 0, (0, i.default)(n).concat([r, e])) }), e }(n = (function (e, t) { const n = t.render.area; const r = e.splitNum; let o = e.radius; const a = Math.min.apply(Math, (0, i.default)(n)) / 2; typeof o !== 'number' && (o = parseInt(o) / 100 * a); const s = o / r; return e.ringRadius = new Array(r).fill(0).map(function (e, t) { return s * (t + 1) }), e.radius = o, e }(n = (function (e, t) { const n = t.render.area; const r = e.center; return e.centerPos = r.map(function (e, t) { return typeof e === 'number' ? e : parseInt(e) / 100 * n[t] }), e }(n = (function (e) { return (0, W.deepMerge)((0, O.deepClone)(an.radarAxisConfig), e) }(t)), e)), e))))))))]); let r = n; n.length && !n[0].show && (r = []); (0, ln.doUpdate)({ chart: e, series: r, key: 'radarAxisSplitArea', getGraphConfig: s, beforeUpdate: c, beforeChange: u }), (0, ln.doUpdate)({ chart: e, series: r, key: 'radarAxisSplitLine', getGraphConfig: f, beforeUpdate: g, beforeChange: v }), (0, ln.doUpdate)({ chart: e, series: r, key: 'radarAxisLine', getGraphConfig: m }), (0, ln.doUpdate)({ chart: e, series: r, key: 'radarAxisLable', getGraphConfig: y }), e.radarAxis = n[0] }; const n = b(S); const r = b(Pt); var i = b(E); function o (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function a (e) { for (let t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? o(n, !0).forEach(function (t) { (0, r.default)(e, t, n[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o(n).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) }) } return e } function s (e) { const t = e.areaRadius; const n = e.polygon; const r = e.animationCurve; const i = e.animationFrame; const o = e.rLevel; const a = n ? 'regPolygon' : 'ring'; return t.map(function (t, n) { return { name: a, index: o, visible: e.splitArea.show, animationCurve: r, animationFrame: i, shape: l(e, n), style: d(e, n) } }) } function l (e, t) { const n = e.polygon; const r = e.areaRadius; const i = e.indicator; const o = e.centerPos; const a = i.length; const s = { rx: o[0], ry: o[1], r: r[t] }; return n && (s.side = a), s } function d (e, t) { const n = e.splitArea; const r = e.ringRadius; const o = e.axisLineAngles; const s = e.polygon; const l = e.centerPos; const d = n.color; let c = n.style; c = a({ fill: 'rgba(0, 0, 0, 0)' }, c); let u = r[0] - 0; if (s) { const f = O.getCircleRadianPoint.apply(void 0, (0, i.default)(l).concat([r[0], o[0]])); const h = O.getCircleRadianPoint.apply(void 0, (0, i.default)(l).concat([r[0], o[1]])); u = (0, W.getPointToLineDistance)(l, f, h) } if (c = (0, W.deepMerge)((0, O.deepClone)(c, !0), { lineWidth: u }), !d.length) return c; const p = d.length; return (0, W.deepMerge)(c, { stroke: d[t % p] }) } function c (e, t, n, r) { const i = e[n]; if (i) { const o = r.chart.render; (t.polygon ? 'regPolygon' : 'ring') !== i[0].name && (i.forEach(function (e) { return o.delGraph(e) }), e[n] = null) } } function u (e, t) { const n = t.shape.side; typeof n === 'number' && (e.shape.side = n) } function f (e) { const t = e.ringRadius; const n = e.polygon; const r = e.animationCurve; const i = e.animationFrame; const o = e.rLevel; const a = n ? 'regPolygon' : 'ring'; return t.map(function (t, n) { return { name: a, index: o, animationCurve: r, animationFrame: i, visible: e.splitLine.show, shape: h(e, n), style: p(e, n) } }) } function h (e, t) { const n = e.ringRadius; const r = e.centerPos; const i = e.indicator; const o = e.polygon; const a = { rx: r[0], ry: r[1], r: n[t] }; const s = i.length; return o && (a.side = s), a } function p (e, t) { const n = e.splitLine; const r = n.color; let i = n.style; if (i = a({ fill: 'rgba(0, 0, 0, 0)' }, i), !r.length) return i; const o = r.length; return (0, W.deepMerge)(i, { stroke: r[t % o] }) } function g (e, t, n, r) { const i = e[n]; if (i) { const o = r.chart.render; (t.polygon ? 'regPolygon' : 'ring') !== i[0].name && (i.forEach(function (e) { return o.delGraph(e) }), e[n] = null) } } function v (e, t) { const n = t.shape.side; typeof n === 'number' && (e.shape.side = n) } function m (e) { const t = e.axisLinePosition; const n = e.animationCurve; const r = e.animationFrame; const i = e.rLevel; return t.map(function (t, o) { return { name: 'polyline', index: i, visible: e.axisLine.show, animationCurve: n, animationFrame: r, shape: A(e, o), style: C(e, o) } }) } function A (e, t) { return { points: [e.centerPos, e.axisLinePosition[t]] } } function C (e, t) { const n = e.axisLine; const r = n.color; const i = n.style; if (!r.length) return i; const o = r.length; return (0, W.deepMerge)(i, { stroke: r[t % o] }) } function y (e) { const t = e.axisLabelPosition; const n = e.animationCurve; const r = e.animationFrame; const i = e.rLevel; return t.map(function (t, o) { return { name: 'text', index: i, visible: e.axisLabel.show, animationCurve: n, animationFrame: r, shape: x(e, o), style: w(e, o) } }) } function x (e, t) { const n = e.axisLabelPosition; return { content: e.indicator[t].name, position: n[t] } } function w (e, t) { const r = e.axisLabel; const i = (0, n.default)(e.centerPos, 2); const o = i[0]; const a = i[1]; const s = e.axisLabelPosition; const l = r.color; let d = r.style; const c = (0, n.default)(s[t], 2); const u = c[0] > o ? 'left' : 'right'; const f = c[1] > a ? 'top' : 'bottom'; if (d = (0, W.deepMerge)({ textAlign: u, textBaseline: f }, d), !l.length) return d; const h = l.length; return (0, W.deepMerge)(d, { fill: l[t % h] }) } }); A(gn); gn.radarAxis; const vn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.radar = function (e) { let t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).series; t || (t = []); let n = (0, W.initNeedSeries)(t, an.radarConfig, 'radar'); n = (function (e, t) { const n = t.radarAxis; if (!n) return []; const r = (0, i.default)(n.centerPos, 2); const o = r[0]; const a = r[1]; return e.forEach(function (e) { const t = e.labelPosition.map(function (e) { const t = (0, i.default)(e, 2); const n = t[0]; const r = t[1]; return { textAlign: n > o ? 'left' : 'right', textBaseline: r > a ? 'top' : 'bottom' } }); e.labelAlign = t }), e }(n = (function (e, t) { const n = t.radarAxis; if (!n) return []; const r = n.centerPos; const i = n.axisLineAngles; return e.forEach(function (e) { const t = e.dataRadius; const n = e.label.labelGap; e.labelPosition = t.map(function (e, t) { return O.getCircleRadianPoint.apply(void 0, (0, o.default)(r).concat([e + n, i[t]])) }) }), e }(n = (function (e, t) { const n = t.radarAxis; if (!n) return []; const r = n.indicator; const i = n.axisLineAngles; const a = n.radius; const s = n.centerPos; return e.forEach(function (e) { const t = e.data; e.dataRadius = [], e.radarPosition = r.map(function (n, r) { let l = n.max; let d = n.min; let c = t[r]; typeof l !== 'number' && (l = c), typeof d !== 'number' && (d = 0), typeof c !== 'number' && (c = d); const u = (c - d) / (l - d) * a; return e.dataRadius[r] = u, O.getCircleRadianPoint.apply(void 0, (0, o.default)(s).concat([u, i[r]])) }) }), e }(n, e)), e)), e)), (0, ln.doUpdate)({ chart: e, series: n, key: 'radar', getGraphConfig: s, getStartGraphConfig: l, beforeChange: u }), (0, ln.doUpdate)({ chart: e, series: n, key: 'radarPoint', getGraphConfig: f, getStartGraphConfig: h }), (0, ln.doUpdate)({ chart: e, series: n, key: 'radarLabel', getGraphConfig: v }) }; const n = b(Pt); const r = b(k); var i = b(S); var o = b(E); function a (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function s (e) { const t = e.animationCurve; const n = e.animationFrame; return [{ name: 'polyline', index: e.rLevel, animationCurve: t, animationFrame: n, shape: d(e), style: c(e) }] } function l (e, t) { const n = t.chart.radarAxis.centerPos; const r = s(e)[0]; const i = r.shape.points.length; const a = new Array(i).fill(0).map(function (e) { return (0, o.default)(n) }); return r.shape.points = a, [r] } function d (e) { return { points: e.radarPosition, close: !0 } } function c (e) { const t = e.radarStyle; const n = e.color; const r = (0, xe.getRgbaValue)(n); r[3] = 0.5; const i = { stroke: n, fill: (0, xe.getColorFromRgbValue)(r) }; return (0, W.deepMerge)(i, t) } function u (e, t) { const n = t.shape; const r = e.shape.points; const i = r.length; const a = n.points.length; if (a > i) { const s = r.slice(-1)[0]; const l = new Array(a - i).fill(0).map(function (e) { return (0, o.default)(s) }); r.push.apply(r, (0, o.default)(l)) } else a < i && r.splice(a) } function f (e) { const t = e.radarPosition; const n = e.animationCurve; const r = e.animationFrame; const i = e.rLevel; return t.map(function (t, o) { return { name: 'circle', index: i, animationCurve: n, animationFrame: r, visible: e.point.show, shape: p(e, o), style: g(e) } }) } function h (e) { const t = f(e); return t.forEach(function (e) { return e.shape.r = 0.01 }), t } function p (e, t) { const n = e.radarPosition; const r = e.point.radius; const i = n[t]; return { rx: i[0], ry: i[1], r: r } } function g (e, t) { const n = e.point; const r = e.color; const i = n.style; return (0, W.deepMerge)({ stroke: r }, i) } function v (e) { const t = e.labelPosition; const n = e.animationCurve; const r = e.animationFrame; const i = e.rLevel; return t.map(function (t, o) { return { name: 'text', index: i, visible: e.label.show, animationCurve: n, animationFrame: r, shape: m(e, o), style: A(e, o) } }) } function m (e, t) { let n; let o; let a; let s; let l; let d; let c; let u; const f = e.labelPosition; const h = e.label; const p = e.data; const g = h.offset; const v = h.formatter; const m = (n = f[t], o = g, a = (0, i.default)(n, 2), s = a[0], l = a[1], d = (0, i.default)(o, 2), c = d[0], u = d[1], [s + c, l + u]); let A = p[t] ? p[t].toString() : '0'; const C = (0, r.default)(v); return C === 'string' && (A = v.replace('{value}', A)), C === 'function' && (A = v(A)), { content: A, position: m } } function A (e, t) { const r = e.label; const i = e.color; const o = e.labelAlign; const s = r.style; const l = (function (e) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; t % 2 ? a(r, !0).forEach(function (t) { (0, n.default)(e, t, r[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : a(r).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t)) }) } return e }({ fill: i }, o[t])); return (0, W.deepMerge)(l, s) } }); A(vn); vn.radar; const mn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.gauge = function (e) { let t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).series; t || (t = []); let n = (0, W.initNeedSeries)(t, rn.gaugeConfig, 'gauge'); n = (function (e, t) { return e.forEach(function (e) { const t = e.data; const n = e.details.formatter; const i = (0, r.default)(n); const o = t.map(function (e) { let t = e.value; return i === 'string' && (t = (t = n.replace('{value}', '{nt}')).replace('{name}', e.name)), i === 'function' && (t = n(e)), t.toString() }); e.detailsContent = o }), e }(n = (function (e, t) { return e.forEach(function (e) { const t = e.data; const n = e.details; const r = e.center; const a = n.position; const s = n.offset; const l = t.map(function (e) { let t; let n; let l; let d; let c; let u; let f; let h; const p = e.startAngle; const g = e.endAngle; const v = e.radius; let m = null; return a === 'center' ? m = r : a === 'start' ? m = O.getCircleRadianPoint.apply(void 0, (0, o.default)(r).concat([v, p])) : a === 'end' && (m = O.getCircleRadianPoint.apply(void 0, (0, o.default)(r).concat([v, g]))), t = m, n = s, l = (0, i.default)(t, 2), d = l[0], c = l[1], u = (0, i.default)(n, 2), f = u[0], h = u[1], [d + f, c + h] }); e.detailsPosition = l }), e }(n = (function (e, t) { return e.forEach(function (e) { const t = e.axisLabel; const n = e.min; const i = e.max; const o = e.splitNum; let a = t.data; const s = t.formatter; const l = (i - n) / (o - 1); const d = new Array(o).fill(0).map(function (e, t) { return parseInt(n + l * t) }); const c = (0, r.default)(s); a = (0, W.deepMerge)(d, a).map(function (e, t) { let n = e; return c === 'string' && (n = s.replace('{value}', e)), c === 'function' && (n = s({ value: e, index: t })), n }), t.data = a }), e }(n = (function (e, t) { return e.forEach(function (e) { const t = e.center; const n = e.tickInnerRadius; const r = e.tickAngles; const a = e.axisLabel.labelGap; const s = r.map(function (e, i) { return O.getCircleRadianPoint.apply(void 0, (0, o.default)(t).concat([n[i] - a, r[i]])) }); const l = s.map(function (e) { const n = (0, i.default)(e, 2); const r = n[0]; const o = n[1]; return { textAlign: r > t[0] ? 'right' : 'left', textBaseline: o > t[1] ? 'bottom' : 'top' } }); e.labelPosition = s, e.labelAlign = l }), e }(n = (function (e, t) { return e.forEach(function (e) { const t = e.startAngle; const n = e.endAngle; const r = e.splitNum; const i = e.center; const a = e.radius; const s = e.arcLineWidth; const l = e.axisTick; const d = l.tickLength; const c = l.style.lineWidth; const u = n - t; const f = a - s / 2; const h = f - d; const p = u / (r - 1); const g = 2 * Math.PI * a * u / (2 * Math.PI); const v = Math.ceil(c / 2) / g * u; e.tickAngles = [], e.tickInnerRadius = [], e.tickPosition = new Array(r).fill(0).map(function (n, a) { let s = t + p * a; return a === 0 && (s += v), a === r - 1 && (s -= v), e.tickAngles[a] = s, e.tickInnerRadius[a] = h, [O.getCircleRadianPoint.apply(void 0, (0, o.default)(i).concat([f, s])), O.getCircleRadianPoint.apply(void 0, (0, o.default)(i).concat([h, s]))] }) }), e }(n = (function (e, t) { return e.forEach(function (e) { e.data.forEach(function (e) { const t = e.color; let n = e.gradient; n && n.length || (n = t), n instanceof Array || (n = [n]), e.gradient = n }) }), e }(n = (function (e, t) { return e.forEach(function (e) { const t = e.startAngle; const n = e.endAngle; const r = e.data; const i = e.min; const o = e.max; const a = n - t; const s = o - i; r.forEach(function (e) { const n = e.value; const r = Math.abs((n - i) / s * a); e.startAngle = t, e.endAngle = t + r }) }), e }(n = (function (e, t) { const n = t.render.area; const r = Math.min.apply(Math, (0, o.default)(n)) / 2; return e.forEach(function (e) { const t = e.radius; const n = e.data; const i = e.arcLineWidth; n.forEach(function (e) { let n = e.radius; let o = e.lineWidth; n || (n = t), typeof n !== 'number' && (n = parseInt(n) / 100 * r), e.radius = n, o || (o = i), e.lineWidth = o }) }), e }(n = (function (e, t) { const n = t.render.area; const r = Math.min.apply(Math, (0, o.default)(n)) / 2; return e.forEach(function (e) { let t = e.radius; typeof t !== 'number' && (t = parseInt(t) / 100 * r), e.radius = t }), e }(n = (function (e, t) { const n = t.render.area; return e.forEach(function (e) { let t = e.center; t = t.map(function (e, t) { return typeof e === 'number' ? e : parseInt(e) / 100 * n[t] }), e.center = t }), e }(n, e)), e)), e)))))))))))))))), (0, ln.doUpdate)({ chart: e, series: n, key: 'gaugeAxisTick', getGraphConfig: l }), (0, ln.doUpdate)({ chart: e, series: n, key: 'gaugeAxisLabel', getGraphConfig: u }), (0, ln.doUpdate)({ chart: e, series: n, key: 'gaugeBackgroundArc', getGraphConfig: p, getStartGraphConfig: m }), (0, ln.doUpdate)({ chart: e, series: n, key: 'gaugeArc', getGraphConfig: A, getStartGraphConfig: x, beforeChange: w }), (0, ln.doUpdate)({ chart: e, series: n, key: 'gaugePointer', getGraphConfig: B, getStartGraphConfig: I }), (0, ln.doUpdate)({ chart: e, series: n, key: 'gaugeDetails', getGraphConfig: L }) }; const n = b(Pt); var r = b(k); var i = b(S); var o = b(E); function a (e, t) { const n = Object.keys(e); if (Object.getOwnPropertySymbols) { let r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, r) } return n } function s (e) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; t % 2 ? a(r, !0).forEach(function (t) { (0, n.default)(e, t, r[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : a(r).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t)) }) } return e } function l (e) { const t = e.tickPosition; const n = e.animationCurve; const r = e.animationFrame; const i = e.rLevel; return t.map(function (t, o) { return { name: 'polyline', index: i, visible: e.axisTick.show, animationCurve: n, animationFrame: r, shape: d(e, o), style: c(e) } }) } function d (e, t) { return { points: e.tickPosition[t] } } function c (e, t) { return e.axisTick.style } function u (e) { const t = e.labelPosition; const n = e.animationCurve; const r = e.animationFrame; const i = e.rLevel; return t.map(function (t, o) { return { name: 'text', index: i, visible: e.axisLabel.show, animationCurve: n, animationFrame: r, shape: f(e, o), style: h(e, o) } }) } function f (e, t) { const n = e.labelPosition; return { content: e.axisLabel.data[t].toString(), position: n[t] } } function h (e, t) { const n = e.labelAlign; const r = e.axisLabel.style; return (0, W.deepMerge)(s({}, n[t]), r) } function p (e) { const t = e.animationCurve; const n = e.animationFrame; return [{ name: 'arc', index: e.rLevel, visible: e.backgroundArc.show, animationCurve: t, animationFrame: n, shape: g(e), style: v(e) }] } function g (e) { const t = e.startAngle; const n = e.endAngle; const r = e.center; const i = e.radius; return { rx: r[0], ry: r[1], r: i, startAngle: t, endAngle: n } } function v (e) { const t = e.backgroundArc; const n = e.arcLineWidth; const r = t.style; return (0, W.deepMerge)({ lineWidth: n }, r) } function m (e) { const t = p(e)[0]; const n = s({}, t.shape); return n.endAngle = t.shape.startAngle, t.shape = n, [t] } function A (e) { const t = e.data; const n = e.animationCurve; const r = e.animationFrame; const i = e.rLevel; return t.map(function (t, o) { return { name: 'agArc', index: i, animationCurve: n, animationFrame: r, shape: C(e, o), style: y(e, o) } }) } function C (e, t) { const n = e.data; const r = e.center; let i = e.endAngle; const o = n[t]; const a = o.radius; const s = o.startAngle; const l = o.endAngle; return o.localGradient && (i = l), { rx: r[0], ry: r[1], r: a, startAngle: s, endAngle: l, gradientEndAngle: i } } function y (e, t) { const n = e.data; const r = e.dataItemStyle; const i = n[t]; const o = i.lineWidth; let a = i.gradient; return a = a.map(function (e) { return (0, xe.getRgbaValue)(e) }), (0, W.deepMerge)({ lineWidth: o, gradient: a }, r) } function x (e) { const t = A(e); return t.map(function (e) { const t = s({}, e.shape); t.endAngle = e.shape.startAngle, e.shape = t }), t } function w (e, t) { const n = e.style.gradient; const r = n.length; const i = t.style.gradient.length; if (r > i)n.splice(i); else { const a = n.slice(-1)[0]; n.push.apply(n, (0, o.default)(new Array(i - r).fill(0).map(function (e) { return (0, o.default)(a) }))) } } function B (e) { const t = e.animationCurve; const n = e.animationFrame; const r = e.center; return [{ name: 'polyline', index: e.rLevel, visible: e.pointer.show, animationCurve: t, animationFrame: n, shape: P(e), style: _(e), setGraphCenter: function (e, t) { t.style.graphCenter = r } }] } function P (e) { let t; let n; let r; let o; let a; let s; let l; let d; const c = e.center; return { points: (t = c, n = (0, i.default)(t, 2), r = n[0], o = n[1], a = [r, o - 40], s = [r + 5, o], l = [r, o + 10], d = [r - 5, o], [a, s, l, d]), close: !0 } } function _ (e) { const t = e.startAngle; const n = e.endAngle; const r = e.min; const i = e.max; const o = e.data; const a = e.pointer; const s = e.center; const l = a.valueIndex; const d = a.style; const c = ((o[l] ? o[l].value : 0) - r) / (i - r) * (n - t) + t + Math.PI / 2; return (0, W.deepMerge)({ rotate: (0, W.radianToAngle)(c), scale: [1, 1], graphCenter: s }, d) } function I (e) { const t = e.startAngle; const n = B(e)[0]; return n.style.rotate = (0, W.radianToAngle)(t + Math.PI / 2), [n] } function L (e) { const t = e.detailsPosition; const n = e.animationCurve; const r = e.animationFrame; const i = e.rLevel; const o = e.details.show; return t.map(function (t, a) { return { name: 'numberText', index: i, visible: o, animationCurve: n, animationFrame: r, shape: j(e, a), style: M(e, a) } }) } function j (e, t) { const n = e.detailsPosition; const r = e.detailsContent; const i = e.data; const o = e.details; const a = n[t]; const s = r[t]; return { number: [i[t].value], content: s, position: a, toFixed: o.valueToFixed } } function M (e, t) { const n = e.details; const r = e.data; const i = n.style; const o = r[t].color; return (0, W.deepMerge)({ fill: o }, i) } }); A(mn); mn.gauge; const An = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.legend = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; let n = t.legend; n = n ? [n = (function (e, t) { e.orient === 'vertical' ? (function (e, t) { const n = (function (e, t) { const n = e.left; const r = e.right; const i = t.render.area[0]; const o = [n, r].findIndex(function (e) { return e !== 'auto' }); if (o === -1) return [!0, i - 10]; let a = [n, r][o]; return typeof a !== 'number' && (a = parseInt(a) / 100 * i), [Boolean(o), a] }(e, t)); const i = (0, r.default)(n, 2); const o = i[0]; const s = i[1]; const l = (function (e, t) { const n = e.iconHeight; const r = e.itemGap; const i = e.data; const o = e.top; const a = e.bottom; const s = t.render.area[1]; const l = i.length; const d = l * n + (l - 1) * r; const c = [o, a].findIndex(function (e) { return e !== 'auto' }); if (c === -1) return (s - d) / 2; let u = [o, a][c]; return typeof u !== 'number' && (u = parseInt(u) / 100 * s), c === 1 && (u = s - u - d), u }(e, t)); !(function (e, t) { const n = e.data; const r = e.iconWidth; const i = e.iconHeight; const o = e.itemGap; const a = i / 2; n.forEach(function (e, n) { const s = e.textWidth; const l = (i + o) * n + a; const d = t ? 0 - r : 0; const c = t ? d - 5 - s : r + 5; e.iconPosition = [d, l], e.textPosition = [c, l] }) }(e, o)); const d = { textAlign: 'left', textBaseline: 'middle' }; e.data.forEach(function (e) { const t = e.textPosition; const n = e.iconPosition; e.textPosition = a(t, [s, l]), e.iconPosition = a(n, [s, l]), e.align = d }) }(e, t)) : (function (e, t) { const n = e.iconHeight; const r = e.itemGap; const i = (function (e, t) { const n = e.data; const r = e.iconWidth; const i = t.render.area[0]; let a = 0; const s = [[]]; return n.forEach(function (t, n) { let l = o(a, n, e); l + r + 5 + t.textWidth >= i && (l = o(a = n, n, e), s.push([])), t.iconPosition = [l, 0], t.textPosition = [l + r + 5, 0], s.slice(-1)[0].push(t) }), s }(e, t)); const s = i.map(function (n) { return (function (e, t, n) { const r = t.left; let i = t.right; const o = t.iconWidth; const a = t.itemGap; const s = n.render.area[0]; const l = e.length; const d = (0, W.mulAdd)(e.map(function (e) { return e.textWidth })) + l * (5 + o) + (l - 1) * a; const c = [r, i].findIndex(function (e) { return e !== 'auto' }); return c === -1 ? (s - d) / 2 : c === 0 ? typeof r === 'number' ? r : parseInt(r) / 100 * s : (typeof i !== 'number' && (i = parseInt(i) / 100 * s), s - (d + i)) }(n, e, t)) }); const l = (function (e, t) { const n = e.top; let r = e.bottom; const i = e.iconHeight; const o = t.render.area[1]; const a = [n, r].findIndex(function (e) { return e !== 'auto' }); const s = i / 2; if (a === -1) { const l = t.gridArea; const d = l.y; const c = l.h; return d + c + 45 - s } return a === 0 ? typeof n === 'number' ? n - s : parseInt(n) / 100 * o - s : (typeof r !== 'number' && (r = parseInt(r) / 100 * o), o - r - s) }(e, t)); const d = { textAlign: 'left', textBaseline: 'middle' }; i.forEach(function (e, t) { return e.forEach(function (e) { const i = e.iconPosition; const o = e.textPosition; const c = s[t]; const u = l + t * (r + n); e.iconPosition = a(i, [c, u]), e.textPosition = a(o, [c, u]), e.align = d }) }) }(e, t)); return e }(n = (function (e, t) { const n = t.render.ctx; const r = e.data; const i = e.textStyle; const o = e.textUnselectedStyle; return r.forEach(function (e) { const t = e.status; const r = e.name; e.textWidth = (function (e, t, n) { return e.font = (function (e) { const t = e.fontFamily; const n = e.fontSize; return ''.concat(n, 'px ').concat(t) }(n)), e.measureText(t).width }(n, r, t ? i : o)) }), e }(n = (function (e, t, n) { const r = t.series; let i = n.legendStatus; const o = e.data.filter(function (e) { const t = e.name; const n = r.find(function (e) { const n = e.name; return t === n }); return !!n && (e.color || (e.color = n.color), e.icon || (e.icon = n.type), e) }); i && i.length === e.data.length || (i = new Array(e.data.length).fill(!0)); return o.forEach(function (e, t) { return e.status = i[t] }), e.data = o, n.legendStatus = i, e }(n = (function (e) { const t = e.data; return e.data = t.map(function (e) { const t = (0, i.default)(e); return t === 'string' ? { name: e } : t === 'object' ? e : { name: '' } }), e }(n = (0, W.deepMerge)((0, O.deepClone)(an.legendConfig, !0), n))), t, e)), e)), e))] : []; (0, ln.doUpdate)({ chart: e, series: n, key: 'legendIcon', getGraphConfig: s }), (0, ln.doUpdate)({ chart: e, series: n, key: 'legendText', getGraphConfig: c }) }; const n = b(Pt); var r = b(S); var i = b(k); function o (e, t, n) { const r = n.data; const i = n.iconWidth; const o = n.itemGap; const a = r.slice(e, t); return (0, W.mulAdd)(a.map(function (e) { return e.textWidth })) + (t - e) * (o + 5 + i) } function a (e, t) { const n = (0, r.default)(e, 2); const i = n[0]; const o = n[1]; const a = (0, r.default)(t, 2); return [i + a[0], o + a[1]] } function s (e, t) { const r = e.data; const i = e.selectAble; const o = e.animationCurve; const a = e.animationFrame; const s = e.rLevel; return r.map(function (r, c) { return (0, n.default)({ name: r.icon === 'line' ? 'lineIcon' : 'rect', index: s, visible: e.show, hover: i, click: i, animationCurve: o, animationFrame: a, shape: l(e, c), style: d(e, c) }, 'click', p(e, c, t)) }) } function l (e, t) { const n = e.data; const i = e.iconWidth; const o = e.iconHeight; const a = (0, r.default)(n[t].iconPosition, 2); return { x: a[0], y: a[1] - o / 2, w: i, h: o } } function d (e, t) { const n = e.data; const r = e.iconStyle; const i = e.iconUnselectedStyle; const o = n[t]; const a = o.status; const s = o.color; const l = a ? r : i; return (0, W.deepMerge)({ fill: s }, l) } function c (e, t) { const n = e.data; const r = e.selectAble; const i = e.animationCurve; const o = e.animationFrame; const a = e.rLevel; return n.map(function (n, s) { return { name: 'text', index: a, visible: e.show, hover: r, animationCurve: i, animationFrame: o, hoverRect: h(e, s), shape: u(e, s), style: f(e, s), click: p(e, s, t) } }) } function u (e, t) { const n = e.data[t]; const r = n.textPosition; return { content: n.name, position: r } } function f (e, t) { const n = e.textStyle; const r = e.textUnselectedStyle; const i = e.data[t]; const o = i.status; const a = i.align; const s = o ? n : r; return (0, W.deepMerge)((0, O.deepClone)(s, !0), a) } function h (e, t) { const n = e.textStyle; const i = e.textUnselectedStyle; const o = e.data[t]; const a = o.status; const s = (0, r.default)(o.textPosition, 2); const l = s[0]; const d = s[1]; const c = o.textWidth; const u = (a ? n : i).fontSize; return [l, d - u / 2, c, u] } function p (e, t, n) { const r = e.data[t].name; return function () { const e = n.chart; const i = e.legendStatus; const o = e.option; const a = !i[t]; o.series.find(function (e) { return e.name === r }).show = a, i[t] = a, n.chart.setOption(o) } } }); A(An); An.legend; const Cn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), Object.defineProperty(t, 'mergeColor', { enumerable: !0, get: function () { return sn.mergeColor } }), Object.defineProperty(t, 'title', { enumerable: !0, get: function () { return dn.title } }), Object.defineProperty(t, 'grid', { enumerable: !0, get: function () { return cn.grid } }), Object.defineProperty(t, 'axis', { enumerable: !0, get: function () { return un.axis } }), Object.defineProperty(t, 'line', { enumerable: !0, get: function () { return fn.line } }), Object.defineProperty(t, 'bar', { enumerable: !0, get: function () { return hn.bar } }), Object.defineProperty(t, 'pie', { enumerable: !0, get: function () { return pn.pie } }), Object.defineProperty(t, 'radarAxis', { enumerable: !0, get: function () { return gn.radarAxis } }), Object.defineProperty(t, 'radar', { enumerable: !0, get: function () { return vn.radar } }), Object.defineProperty(t, 'gauge', { enumerable: !0, get: function () { return mn.gauge } }), Object.defineProperty(t, 'legend', { enumerable: !0, get: function () { return An.legend } }) }); A(Cn); const bn = C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), t.default = void 0; const n = b(k); const r = b(Bt); const i = b(Tt); const o = function e (t) { if ((0, r.default)(this, e), !t) return console.error('Charts Missing parameters!'), !1; const n = t.clientWidth; const o = t.clientHeight; const a = document.createElement('canvas'); a.setAttribute('width', n), a.setAttribute('height', o), t.appendChild(a); const s = { container: t, canvas: a, render: new i.default(a), option: null }; Object.assign(this, s) }; t.default = o, o.prototype.setOption = function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (!e || (0, n.default)(e) !== 'object') return console.error('setOption Missing parameters!'), !1; t && this.render.graphs.forEach(function (e) { return e.animationEnd() }); const r = (0, O.deepClone)(e, !0); (0, Cn.mergeColor)(this, r), (0, Cn.grid)(this, r), (0, Cn.axis)(this, r), (0, Cn.radarAxis)(this, r), (0, Cn.title)(this, r), (0, Cn.bar)(this, r), (0, Cn.line)(this, r), (0, Cn.pie)(this, r), (0, Cn.radar)(this, r), (0, Cn.gauge)(this, r), (0, Cn.legend)(this, r), this.option = e, this.render.launchAnimation() }, o.prototype.resize = function () { const e = this.container; const t = this.canvas; const n = this.render; const r = this.option; const i = e.clientWidth; const o = e.clientHeight; t.setAttribute('width', i), t.setAttribute('height', o), n.area = [i, o], this.setOption(r) } }); A(bn); const yn = A(C(function (e, t) { Object.defineProperty(t, '__esModule', { value: !0 }), Object.defineProperty(t, 'changeDefaultConfig', { enumerable: !0, get: function () { return an.changeDefaultConfig } }), t.default = void 0; const n = b(bn).default; t.default = n })); const xn = { name: 'DvCharts', mixins: [r], props: { option: { type: Object, default: () => ({}) } }, data () { const e = Date.now(); return { ref: `charts-container-${e}`, chartRef: `chart-${e}`, chart: null } }, watch: { option () { let { chart: e, option: t } = this; e && (t || (t = {}), e.setOption(t, !0)) } }, methods: { afterAutoResizeMixinInit () { const { initChart: e } = this; e() }, initChart () { const { $refs: e, chartRef: t, option: n } = this; const r = this.chart = new yn(e[t]); n && r.setOption(n) }, onResize () { const { chart: e } = this; e && e.resize() } } }; const wn = function () { const e = this.$createElement; const t = this._self._c || e; return t('div', { ref: this.ref, staticClass: 'dv-charts-container' }, [t('div', { ref: this.chartRef, staticClass: 'charts-canvas-container' })]) }; wn._withStripped = !0; const En = a({ render: wn, staticRenderFns: [] }, function (e) { e && e('data-v-5e36f670_0', { source: '.dv-charts-container {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-charts-container .charts-canvas-container {\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;AACA;EACE,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-charts-container {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.dv-charts-container .charts-canvas-container {\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, xn, void 0, !1, void 0, d, void 0); function kn (e) { e.component(En.name, En) } const Bn = { name: 'DvDigitalFlop', props: { config: { type: Object, default: () => ({}) } }, data: () => ({ renderer: null, defaultConfig: { number: [], content: '', toFixed: 0, textAlign: 'center', style: { fontSize: 30, fill: '#3de7c9' }, animationCurve: 'easeOutCubic', animationFrame: 50 }, mergedConfig: null, graph: null }), watch: { config () { const { update: e } = this; e() } }, methods: { init () { const { initRender: e, mergeConfig: t, initGraph: n } = this; e(), t(), n() }, initRender () { const { $refs: e } = this; this.renderer = new Yt(e['digital-flop']) }, mergeConfig () { const { defaultConfig: e, config: t } = this; this.mergedConfig = L(I(e, !0), t || {}) }, initGraph () { const { getShape: e, getStyle: t, renderer: n, mergedConfig: r } = this; const { animationCurve: i, animationFrame: o } = r; const a = e(); const s = t(); this.graph = n.add({ name: 'numberText', animationCurve: i, animationFrame: o, shape: a, style: s }) }, getShape () { const { number: e, content: t, toFixed: n, textAlign: r } = this.mergedConfig; const [i, o] = this.renderer.area; const a = [i / 2, o / 2]; return r === 'left' && (a[0] = 0), r === 'right' && (a[0] = i), { number: e, content: t, toFixed: n, position: a } }, getStyle () { const { style: e, textAlign: t } = this.mergedConfig; return L(e, { textAlign: t, textBaseline: 'middle' }) }, update () { const { mergeConfig: e, mergeShape: t, getShape: n, getStyle: r, graph: i, mergedConfig: o } = this; if (i.animationEnd(), e(), !i) return; const { animationCurve: a, animationFrame: s } = o; const l = n(); const d = r(); t(i, l), i.animationCurve = a, i.animationFrame = s, i.animation('style', d, !0), i.animation('shape', l) }, mergeShape (e, t) { e.shape.number.length !== t.number.length && (e.shape.number = t.number) } }, mounted () { const { init: e } = this; e() } }; const Pn = function () { const e = this.$createElement; const t = this._self._c || e; return t('div', { staticClass: 'dv-digital-flop' }, [t('canvas', { ref: 'digital-flop' })]) }; Pn._withStripped = !0; const _n = a({ render: Pn, staticRenderFns: [] }, function (e) { e && e('data-v-2cf25a2e_0', { source: '.dv-digital-flop canvas {\n  width: 100%;\n  height: 100%;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,WAAW;EACX,YAAY;AACd', file: 'main.vue', sourcesContent: ['.dv-digital-flop canvas {\n  width: 100%;\n  height: 100%;\n}\n'] }, media: void 0 }) }, Bn, void 0, !1, void 0, d, void 0); const Sn = { name: 'DvActiveRingChart', components: { dvDigitalFlop: _n }, props: { config: { type: Object, default: () => ({}) } }, data: () => ({ defaultConfig: { radius: '50%', activeRadius: '55%', data: [{ name: '', value: 0 }], lineWidth: 20, activeTimeGap: 3e3, color: [], digitalFlopStyle: { fontSize: 25, fill: '#fff' }, digitalFlopToFixed: 0, animationCurve: 'easeOutCubic', animationFrame: 50 }, mergedConfig: null, chart: null, activeIndex: 0, animationHandler: '' }), computed: { digitalFlop () { const { mergedConfig: e, activeIndex: t } = this; if (!e) return {}; const { digitalFlopStyle: n, digitalFlopToFixed: r, data: i } = e; const o = i.map(({ value: e }) => e); const a = o.reduce((e, t) => e + t, 0); return { content: '{nt}%', number: [parseFloat(o[t] / a * 100) || 0], style: n, toFixed: r } }, ringName () { const { mergedConfig: e, activeIndex: t } = this; return e ? e.data[t].name : '' }, fontSize () { const { mergedConfig: e } = this; return e ? `font-size: ${e.digitalFlopStyle.fontSize}px;` : '' } }, watch: { config () { const { animationHandler: e, mergeConfig: t, setRingOption: n } = this; clearTimeout(e), this.activeIndex = 0, t(), n() } }, methods: { init () { const { initChart: e, mergeConfig: t, setRingOption: n } = this; e(), t(), n() }, initChart () { const { $refs: e } = this; this.chart = new yn(e['active-ring-chart']) }, mergeConfig () { const { defaultConfig: e, config: t } = this; this.mergedConfig = L(I(e, !0), t || {}) }, setRingOption () { const { getRingOption: e, chart: t, ringAnimation: n } = this; const r = e(); t.setOption(r, !0), n() }, getRingOption () { const { mergedConfig: e, getRealRadius: t } = this; const n = t(); return e.data.forEach(e => { e.radius = n }), { series: [{ type: 'pie', ...e, outsideLabel: { show: !1 } }], color: e.color } }, getRealRadius (e = !1) { const { mergedConfig: t, chart: n } = this; const { radius: r, activeRadius: i, lineWidth: o } = t; const a = Math.min(...n.render.area) / 2; const s = o / 2; let l = e ? i : r; return typeof l !== 'number' && (l = parseInt(l) / 100 * a), [l - s, l + s] }, ringAnimation () { let { activeIndex: e, getRingOption: t, chart: n, getRealRadius: r } = this; const i = r(); const o = r(!0); const a = t(); const { data: s } = a.series[0]; s.forEach((t, n) => { t.radius = n === e ? o : i }), n.setOption(a, !0); const { activeTimeGap: l } = a.series[0]; this.animationHandler = setTimeout(t => { (e += 1) >= s.length && (e = 0), this.activeIndex = e, this.ringAnimation() }, l) } }, mounted () { const { init: e } = this; e() }, beforeDestroy () { const { animationHandler: e } = this; clearTimeout(e) } }; const On = function () { const e = this.$createElement; const t = this._self._c || e; return t('div', { staticClass: 'dv-active-ring-chart' }, [t('div', { ref: 'active-ring-chart', staticClass: 'active-ring-chart-container' }), this._v(' '), t('div', { staticClass: 'active-ring-info' }, [t('dv-digital-flop', { attrs: { config: this.digitalFlop } }), this._v(' '), t('div', { staticClass: 'active-ring-name', style: this.fontSize }, [this._v(this._s(this.ringName))])], 1)]) }; On._withStripped = !0; const In = a({ render: On, staticRenderFns: [] }, function (e) { e && e('data-v-b2e793e2_0', { source: '.dv-active-ring-chart {\n  position: relative;\n}\n.dv-active-ring-chart .active-ring-chart-container {\n  width: 100%;\n  height: 100%;\n}\n.dv-active-ring-chart .active-ring-info {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0px;\n  top: 0px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n}\n.dv-active-ring-chart .active-ring-info .dv-digital-flop {\n  width: 100px;\n  height: 30px;\n}\n.dv-active-ring-chart .active-ring-info .active-ring-name {\n  width: 100px;\n  height: 30px;\n  color: #fff;\n  text-align: center;\n  vertical-align: middle;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;AACpB;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,SAAS;EACT,QAAQ;EACR,aAAa;EACb,sBAAsB;EACtB,uBAAuB;EACvB,mBAAmB;AACrB;AACA;EACE,YAAY;EACZ,YAAY;AACd;AACA;EACE,YAAY;EACZ,YAAY;EACZ,WAAW;EACX,kBAAkB;EAClB,sBAAsB;EACtB,uBAAuB;EACvB,gBAAgB;EAChB,mBAAmB;AACrB', file: 'main.vue', sourcesContent: ['.dv-active-ring-chart {\n  position: relative;\n}\n.dv-active-ring-chart .active-ring-chart-container {\n  width: 100%;\n  height: 100%;\n}\n.dv-active-ring-chart .active-ring-info {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0px;\n  top: 0px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n}\n.dv-active-ring-chart .active-ring-info .dv-digital-flop {\n  width: 100px;\n  height: 30px;\n}\n.dv-active-ring-chart .active-ring-info .active-ring-name {\n  width: 100px;\n  height: 30px;\n  color: #fff;\n  text-align: center;\n  vertical-align: middle;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n}\n'] }, media: void 0 }) }, Sn, void 0, !1, void 0, d, void 0); function Wn (e) { e.component(In.name, In) } const Ln = { name: 'DvCapsuleChart', props: { config: { type: Object, default: () => ({}) } }, data: () => ({ defaultConfig: { data: [], colors: ['#37a2da', '#32c5e9', '#67e0e3', '#9fe6b8', '#ffdb5c', '#ff9f7f', '#fb7293'], unit: '' }, mergedConfig: null, capsuleLength: [], labelData: [] }), watch: { config () { const { calcData: e } = this; e() } }, methods: { calcData () { const { mergeConfig: e, calcCapsuleLengthAndLabelData: t } = this; e(), t() }, mergeConfig () { const { config: e, defaultConfig: t } = this; this.mergedConfig = L(I(t, !0), e || {}) }, calcCapsuleLengthAndLabelData () { const { data: e } = this.mergedConfig; if (!e.length) return; const t = e.map(({ value: e }) => e); const n = Math.max(...t); this.capsuleLength = t.map(e => n ? e / n : 0); const r = n / 5; this.labelData = new Array(6).fill(0).map((e, t) => Math.ceil(t * r)) } }, mounted () { const { calcData: e } = this; e() } }; const jn = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { staticClass: 'dv-capsule-chart' }, [e.mergedConfig ? [n('div', { staticClass: 'label-column' }, [e._l(e.mergedConfig.data, function (t) { return n('div', { key: t.name }, [e._v(e._s(t.name))]) }), e._v(' '), n('div', [e._v('')])], 2), e._v(' '), n('div', { staticClass: 'capsule-container' }, [e._l(e.capsuleLength, function (t, r) { return n('div', { key: r, staticClass: 'capsule-item' }, [n('div', { style: 'width: ' + 100 * t + '%; background-color: ' + e.mergedConfig.colors[r % e.mergedConfig.colors.length] + ';' })]) }), e._v(' '), n('div', { staticClass: 'unit-label' }, e._l(e.labelData, function (t, r) { return n('div', { key: t + r }, [e._v(e._s(t))]) }), 0)], 2), e._v(' '), e.mergedConfig.unit ? n('div', { staticClass: 'unit-text' }, [e._v(e._s(e.mergedConfig.unit))]) : e._e()] : e._e()], 2) }; jn._withStripped = !0; const Mn = a({ render: jn, staticRenderFns: [] }, function (e) { e && e('data-v-99dd88f2_0', { source: '.dv-capsule-chart {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  box-sizing: border-box;\n  padding: 10px;\n  color: #fff;\n}\n.dv-capsule-chart .label-column {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  box-sizing: border-box;\n  padding-right: 10px;\n  text-align: right;\n  font-size: 12px;\n}\n.dv-capsule-chart .label-column div {\n  height: 20px;\n  line-height: 20px;\n}\n.dv-capsule-chart .capsule-container {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n}\n.dv-capsule-chart .capsule-item {\n  box-shadow: 0 0 3px #999;\n  height: 10px;\n  margin: 5px 0px;\n  border-radius: 5px;\n}\n.dv-capsule-chart .capsule-item div {\n  height: 8px;\n  margin-top: 1px;\n  border-radius: 5px;\n  transition: all 0.3s;\n}\n.dv-capsule-chart .unit-label {\n  height: 20px;\n  font-size: 12px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-between;\n}\n.dv-capsule-chart .unit-text {\n  text-align: right;\n  display: flex;\n  align-items: flex-end;\n  font-size: 12px;\n  line-height: 20px;\n  margin-left: 10px;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,aAAa;EACb,mBAAmB;EACnB,sBAAsB;EACtB,aAAa;EACb,WAAW;AACb;AACA;EACE,aAAa;EACb,sBAAsB;EACtB,8BAA8B;EAC9B,sBAAsB;EACtB,mBAAmB;EACnB,iBAAiB;EACjB,eAAe;AACjB;AACA;EACE,YAAY;EACZ,iBAAiB;AACnB;AACA;EACE,OAAO;EACP,aAAa;EACb,sBAAsB;EACtB,8BAA8B;AAChC;AACA;EACE,wBAAwB;EACxB,YAAY;EACZ,eAAe;EACf,kBAAkB;AACpB;AACA;EACE,WAAW;EACX,eAAe;EACf,kBAAkB;EAClB,oBAAoB;AACtB;AACA;EACE,YAAY;EACZ,eAAe;EACf,aAAa;EACb,mBAAmB;EACnB,mBAAmB;EACnB,8BAA8B;AAChC;AACA;EACE,iBAAiB;EACjB,aAAa;EACb,qBAAqB;EACrB,eAAe;EACf,iBAAiB;EACjB,iBAAiB;AACnB', file: 'main.vue', sourcesContent: ['.dv-capsule-chart {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  box-sizing: border-box;\n  padding: 10px;\n  color: #fff;\n}\n.dv-capsule-chart .label-column {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  box-sizing: border-box;\n  padding-right: 10px;\n  text-align: right;\n  font-size: 12px;\n}\n.dv-capsule-chart .label-column div {\n  height: 20px;\n  line-height: 20px;\n}\n.dv-capsule-chart .capsule-container {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n}\n.dv-capsule-chart .capsule-item {\n  box-shadow: 0 0 3px #999;\n  height: 10px;\n  margin: 5px 0px;\n  border-radius: 5px;\n}\n.dv-capsule-chart .capsule-item div {\n  height: 8px;\n  margin-top: 1px;\n  border-radius: 5px;\n  transition: all 0.3s;\n}\n.dv-capsule-chart .unit-label {\n  height: 20px;\n  font-size: 12px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-between;\n}\n.dv-capsule-chart .unit-text {\n  text-align: right;\n  display: flex;\n  align-items: flex-end;\n  font-size: 12px;\n  line-height: 20px;\n  margin-left: 10px;\n}\n'] }, media: void 0 }) }, Ln, void 0, !1, void 0, d, void 0); function Fn (e) { e.component(Mn.name, Mn) } const Rn = { name: 'DvWaterLevelPond', props: { config: Object, default: () => ({}) }, data: () => ({ gradientId: `water-level-pond-${Date.now()}`, defaultConfig: { data: [], shape: 'rect', waveNum: 3, waveHeight: 40, waveOpacity: 0.4, colors: ['#3DE7C9', '#00BAFF'], formatter: '{value}%' }, mergedConfig: {}, renderer: null, svgBorderGradient: [], details: '', waves: [], animation: !1 }), computed: { radius () { const { shape: e } = this.mergedConfig; return e === 'round' ? '50%' : e === 'rect' ? '0' : e === 'roundRect' ? '10px' : '0' }, shape () { const { shape: e } = this.mergedConfig; return e || 'rect' } }, watch: { config () { const { calcData: e, renderer: t } = this; t.delAllGraph(), this.waves = [], setTimeout(e, 0) } }, methods: { init () { const { initRender: e, config: t, calcData: n } = this; e(), t && n() }, initRender () { const { $refs: e } = this; this.renderer = new Yt(e['water-pond-level']) }, calcData () { const { mergeConfig: e, calcSvgBorderGradient: t, calcDetails: n } = this; e(), t(), n(); const { addWave: r, animationWave: i } = this; r(), i() }, mergeConfig () { const { config: e, defaultConfig: t } = this; this.mergedConfig = L(I(t, !0), e) }, calcSvgBorderGradient () { const { colors: e } = this.mergedConfig; const t = 100 / (e.length - 1); this.svgBorderGradient = e.map((e, n) => [t * n, e]) }, calcDetails () { const { data: e, formatter: t } = this.mergedConfig; if (!e.length) return void (this.details = ''); const n = Math.max(...e); this.details = t.replace('{value}', n) }, addWave () { const { renderer: e, getWaveShapes: t, getWaveStyle: n, drawed: r } = this; const i = t(); const o = n(); this.waves = i.map(t => e.add({ name: 'smoothline', animationFrame: 300, shape: t, style: o, drawed: r })) }, getWaveShapes () { const { mergedConfig: e, renderer: t, mergeOffset: n } = this; const { waveNum: r, waveHeight: i, data: o } = e; const [a, s] = t.area; const l = 4 * r + 4; const d = a / r / 2; return o.map(e => { let t = new Array(l).fill(0).map((t, n) => { const r = (1 - e / 100) * s; return [a - d * n, n % 2 == 0 ? r : r - i] }); return { points: t = t.map(e => n(e, [2 * d, 0])) } }) }, mergeOffset: ([e, t], [n, r]) => [e + n, t + r], getWaveStyle () { const { renderer: e, mergedConfig: t } = this; const n = e.area[1]; return { gradientColor: t.colors, gradientType: 'linear', gradientParams: [0, 0, 0, n], gradientWith: 'fill', opacity: t.waveOpacity, translate: [0, 0] } }, drawed ({ shape: { points: e } }, { ctx: t, area: n }) { const r = e[0]; const i = e.slice(-1)[0]; const o = n[1]; t.lineTo(i[0], o), t.lineTo(r[0], o), t.closePath(), t.fill() }, async animationWave (e = 1) { const { waves: t, renderer: n, animation: r } = this; if (r) return; this.animation = !0; const i = n.area[0]; t.forEach(e => { e.attr('style', { translate: [0, 0] }), e.animation('style', { translate: [i, 0] }, !0) }), await n.launchAnimation(), this.animation = !1, n.graphs.length && this.animationWave(e + 1) } }, mounted () { const { init: e } = this; e() }, beforeDestroy () { const { renderer: e } = this; e.delAllGraph(), this.waves = [] } }; const Dn = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { staticClass: 'dv-water-pond-level' }, [e.renderer ? n('svg', [n('defs', [n('linearGradient', { attrs: { id: e.gradientId, x1: '0%', y1: '0%', x2: '0%', y2: '100%' } }, e._l(e.svgBorderGradient, function (e) { return n('stop', { key: e[0], attrs: { offset: e[0], 'stop-color': e[1] } }) }), 1)], 1), e._v(' '), e.renderer ? n('text', { attrs: { stroke: 'url(#' + e.gradientId + ')', fill: 'url(#' + e.gradientId + ')', x: e.renderer.area[0] / 2 + 8, y: e.renderer.area[1] / 2 + 8 } }, [e._v('\n      ' + e._s(e.details) + '\n    ')]) : e._e(), e._v(' '), e.shape && e.shape !== 'round' ? n('rect', { attrs: { x: '2', y: '2', rx: e.shape === 'roundRect' ? 10 : 0, ry: e.shape === 'roundRect' ? 10 : 0, width: e.renderer.area[0] + 12, height: e.renderer.area[1] + 12, stroke: 'url(#' + e.gradientId + ')' } }) : n('ellipse', { attrs: { cx: e.renderer.area[0] / 2 + 8, cy: e.renderer.area[1] / 2 + 8, rx: e.renderer.area[0] / 2 + 5, ry: e.renderer.area[1] / 2 + 5, stroke: 'url(#' + e.gradientId + ')' } })]) : e._e(), e._v(' '), n('canvas', { ref: 'water-pond-level', style: 'border-radius: ' + e.radius + ';' })]) }; Dn._withStripped = !0; const Gn = a({ render: Dn, staticRenderFns: [] }, function (e) { e && e('data-v-48b03636_0', { source: '.dv-water-pond-level {\n  position: relative;\n}\n.dv-water-pond-level svg {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-water-pond-level text {\n  font-size: 25px;\n  font-weight: bold;\n  text-anchor: middle;\n  dominant-baseline: middle;\n}\n.dv-water-pond-level ellipse,\n.dv-water-pond-level rect {\n  fill: none;\n  stroke-width: 3;\n}\n.dv-water-pond-level canvas {\n  margin-top: 8px;\n  margin-left: 8px;\n  width: calc(100% - 16px);\n  height: calc(100% - 16px);\n  box-sizing: border-box;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;AACpB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,QAAQ;EACR,SAAS;AACX;AACA;EACE,eAAe;EACf,iBAAiB;EACjB,mBAAmB;EACnB,yBAAyB;AAC3B;AACA;;EAEE,UAAU;EACV,eAAe;AACjB;AACA;EACE,eAAe;EACf,gBAAgB;EAChB,wBAAwB;EACxB,yBAAyB;EACzB,sBAAsB;AACxB', file: 'main.vue', sourcesContent: ['.dv-water-pond-level {\n  position: relative;\n}\n.dv-water-pond-level svg {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n}\n.dv-water-pond-level text {\n  font-size: 25px;\n  font-weight: bold;\n  text-anchor: middle;\n  dominant-baseline: middle;\n}\n.dv-water-pond-level ellipse,\n.dv-water-pond-level rect {\n  fill: none;\n  stroke-width: 3;\n}\n.dv-water-pond-level canvas {\n  margin-top: 8px;\n  margin-left: 8px;\n  width: calc(100% - 16px);\n  height: calc(100% - 16px);\n  box-sizing: border-box;\n}\n'] }, media: void 0 }) }, Rn, void 0, !1, void 0, d, void 0); function zn (e) { e.component(Gn.name, Gn) } const Tn = { name: 'DvPercentPond', props: { config: { type: Object, default: () => ({}) } }, data () { const e = Date.now(); return { gradientId1: `percent-pond-gradientId1-${e}`, gradientId2: `percent-pond-gradientId2-${e}`, width: 0, height: 0, defaultConfig: { value: 0, colors: ['#3DE7C9', '#00BAFF'], borderWidth: 3, borderGap: 3, lineDash: [5, 1], textColor: '#fff', borderRadius: 5, localGradient: !1, formatter: '{value}%' }, mergedConfig: null } }, computed: { rectWidth () { const { mergedConfig: e, width: t } = this; if (!e) return 0; const { borderWidth: n } = e; return t - n }, rectHeight () { const { mergedConfig: e, height: t } = this; if (!e) return 0; const { borderWidth: n } = e; return t - n }, points () { const { mergedConfig: e, width: t, height: n } = this; const r = n / 2; if (!e) return `0, ${r} 0, ${r}`; const { borderWidth: i, borderGap: o, value: a } = e; return `\n        ${i + o}, ${r}\n        ${i + o + (t - 2 * (i + o)) / 100 * a}, ${r + 0.001}\n      ` }, polylineWidth () { const { mergedConfig: e, height: t } = this; if (!e) return 0; const { borderWidth: n, borderGap: r } = e; return t - 2 * (n + r) }, linearGradient () { const { mergedConfig: e } = this; if (!e) return []; const { colors: t } = e; const n = 100 / (t.length - 1); return t.map((e, t) => [n * t, e]) }, polylineGradient () { const { gradientId1: e, gradientId2: t, mergedConfig: n } = this; return n && n.localGradient ? e : t }, gradient2XPos () { const { mergedConfig: e } = this; if (!e) return '100%'; const { value: t } = e; return `${200 - t}%` }, details () { const { mergedConfig: e } = this; if (!e) return ''; const { value: t, formatter: n } = e; return n.replace('{value}', t) } }, watch: { config () { const { mergeConfig: e } = this; e() } }, methods: { async init () { const { initWH: e, config: t, mergeConfig: n } = this; await e(), t && n() }, async initWH () { const { $nextTick: e, $refs: t } = this; await e(); const n = t['percent-pond']; this.width = n.clientWidth, this.height = n.clientHeight }, mergeConfig () { const { config: e, defaultConfig: t } = this; this.mergedConfig = L(I(t, !0), e || {}) } }, mounted () { const { init: e } = this; e() } }; const Yn = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: 'percent-pond', staticClass: 'dv-percent-pond' }, [n('svg', [n('defs', [n('linearGradient', { attrs: { id: e.gradientId1, x1: '0%', y1: '0%', x2: '100%', y2: '0%' } }, e._l(e.linearGradient, function (e) { return n('stop', { key: e[0], attrs: { offset: e[0] + '%', 'stop-color': e[1] } }) }), 1), e._v(' '), n('linearGradient', { attrs: { id: e.gradientId2, x1: '0%', y1: '0%', x2: e.gradient2XPos, y2: '0%' } }, e._l(e.linearGradient, function (e) { return n('stop', { key: e[0], attrs: { offset: e[0] + '%', 'stop-color': e[1] } }) }), 1)], 1), e._v(' '), n('rect', { attrs: { x: e.mergedConfig ? e.mergedConfig.borderWidth / 2 : '0', y: e.mergedConfig ? e.mergedConfig.borderWidth / 2 : '0', rx: e.mergedConfig ? e.mergedConfig.borderRadius : '0', ry: e.mergedConfig ? e.mergedConfig.borderRadius : '0', fill: 'transparent', 'stroke-width': e.mergedConfig ? e.mergedConfig.borderWidth : '0', stroke: 'url(#' + e.gradientId1 + ')', width: e.rectWidth > 0 ? e.rectWidth : 0, height: e.rectHeight > 0 ? e.rectHeight : 0 } }), e._v(' '), n('polyline', { attrs: { 'stroke-width': e.polylineWidth, 'stroke-dasharray': e.mergedConfig ? e.mergedConfig.lineDash.join(',') : '0', stroke: 'url(#' + e.polylineGradient + ')', points: e.points } }), e._v(' '), n('text', { attrs: { stroke: e.mergedConfig ? e.mergedConfig.textColor : '#fff', fill: e.mergedConfig ? e.mergedConfig.textColor : '#fff', x: e.width / 2, y: e.height / 2 } }, [e._v('\n      ' + e._s(e.details) + '\n    ')])])]) }; Yn._withStripped = !0; const Nn = a({ render: Yn, staticRenderFns: [] }, function (e) { e && e('data-v-67d721de_0', { source: '.dv-percent-pond {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n}\n.dv-percent-pond svg {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  width: 100%;\n  height: 100%;\n}\n.dv-percent-pond polyline {\n  transition: all 0.3s;\n}\n.dv-percent-pond text {\n  font-size: 25px;\n  font-weight: bold;\n  text-anchor: middle;\n  dominant-baseline: middle;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,aAAa;EACb,sBAAsB;AACxB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,WAAW;EACX,YAAY;AACd;AACA;EACE,oBAAoB;AACtB;AACA;EACE,eAAe;EACf,iBAAiB;EACjB,mBAAmB;EACnB,yBAAyB;AAC3B', file: 'main.vue', sourcesContent: ['.dv-percent-pond {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n}\n.dv-percent-pond svg {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  width: 100%;\n  height: 100%;\n}\n.dv-percent-pond polyline {\n  transition: all 0.3s;\n}\n.dv-percent-pond text {\n  font-size: 25px;\n  font-weight: bold;\n  text-anchor: middle;\n  dominant-baseline: middle;\n}\n'] }, media: void 0 }) }, Tn, void 0, !1, void 0, d, void 0); function $n (e) { e.component(Nn.name, Nn) } const Xn = { name: 'DvFlylineChart', mixins: [r], props: { config: { type: Object, default: () => ({}) }, dev: { type: Boolean, default: !1 } }, data () { const e = Date.now(); return { ref: 'dv-flyline-chart', unique: Math.random(), maskId: `flyline-mask-id-${e}`, maskCircleId: `mask-circle-id-${e}`, gradientId: `gradient-id-${e}`, gradient2Id: `gradient2-id-${e}`, defaultConfig: { centerPoint: [0, 0], points: [], lineWidth: 1, orbitColor: 'rgba(103, 224, 227, .2)', flylineColor: '#ffde93', k: -0.5, curvature: 5, flylineRadius: 100, duration: [20, 30], relative: !0, bgImgUrl: '', text: { offset: [0, 15], color: '#ffdb5c', fontSize: 12 }, halo: { show: !0, duration: 30, color: '#fb7293', radius: 120 }, centerPointImg: { width: 40, height: 40, url: '' }, pointsImg: { width: 15, height: 15, url: '' } }, mergedConfig: null, paths: [], lengths: [], times: [], texts: [] } }, watch: { config () { const { calcData: e } = this; e() } }, methods: { afterAutoResizeMixinInit () { const { calcData: e } = this; e() }, onResize () { const { calcData: e } = this; e() }, async calcData () { const { mergeConfig: e, createFlylinePaths: t, calcLineLengths: n } = this; e(), t(), await n(); const { calcTimes: r, calcTexts: i } = this; r(), i() }, mergeConfig () { const { config: e, defaultConfig: t } = this; const n = L(I(t, !0), e || {}); const { points: r } = n; n.points = r.map(e => e instanceof Array ? { position: e, text: '' } : e), this.mergedConfig = n }, createFlylinePaths () { const { getPath: e, mergedConfig: t, width: n, height: r } = this; let { centerPoint: i, points: o, relative: a } = t; o = o.map(({ position: e }) => e), a && (i = [n * i[0], r * i[1]], o = o.map(([e, t]) => [n * e, r * t])), this.paths = o.map(t => e(i, t)) }, getPath (e, t) { const { getControlPoint: n } = this; return [t, n(e, t), e] }, getControlPoint ([e, t], [r, i]) { const { getKLinePointByx: o, mergedConfig: a } = this; const { curvature: s, k: l } = a; const [d, c] = [(e + r) / 2, (t + i) / 2]; const u = n([e, t], [r, i]) / s; const f = u / 2; let [h, p] = [d, c]; do { p = o(l, [d, c], h += f)[1] } while (n([d, c], [h, p]) < u); return [h, p] }, getKLinePointByx: (e, [t, n], r) => [r, n - e * t + e * r], async calcLineLengths () { const { $nextTick: e, paths: t, $refs: n } = this; await e(), this.lengths = t.map((e, t) => n[`path${t}`][0].getTotalLength()) }, calcTimes () { const { duration: e, points: n } = this.mergedConfig; this.times = n.map(n => t(...e) / 10) }, calcTexts () { const { points: e } = this.mergedConfig; this.texts = e.map(({ text: e }) => e) }, consoleClickPos ({ offsetX: e, offsetY: t }) { const { width: n, height: r, dev: i } = this; if (!i) return; const o = (e / n).toFixed(2); const a = (t / r).toFixed(2); console.warn(`dv-flyline-chart DEV: \n Click Position is [${e}, ${t}] \n Relative Position is [${o}, ${a}]`) } } }; const Qn = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: 'dv-flyline-chart', staticClass: 'dv-flyline-chart', style: 'background-image: url(' + (e.mergedConfig ? e.mergedConfig.bgImgUrl : '') + ')', on: { click: e.consoleClickPos } }, [e.mergedConfig ? n('svg', { attrs: { width: e.width, height: e.height } }, [n('defs', [n('radialGradient', { attrs: { id: e.gradientId, cx: '50%', cy: '50%', r: '50%' } }, [n('stop', { attrs: { offset: '0%', 'stop-color': '#fff', 'stop-opacity': '1' } }), e._v(' '), n('stop', { attrs: { offset: '100%', 'stop-color': '#fff', 'stop-opacity': '0' } })], 1), e._v(' '), n('radialGradient', { attrs: { id: e.gradient2Id, cx: '50%', cy: '50%', r: '50%' } }, [n('stop', { attrs: { offset: '0%', 'stop-color': '#fff', 'stop-opacity': '0' } }), e._v(' '), n('stop', { attrs: { offset: '100%', 'stop-color': '#fff', 'stop-opacity': '1' } })], 1), e._v(' '), e.paths[0] ? n('circle', { attrs: { id: 'circle' + e.paths[0].toString(), cx: e.paths[0][2][0], cy: e.paths[0][2][1] } }, [n('animate', { attrs: { attributeName: 'r', values: '1;' + e.mergedConfig.halo.radius, dur: e.mergedConfig.halo.duration / 10 + 's', repeatCount: 'indefinite' } }), e._v(' '), n('animate', { attrs: { attributeName: 'opacity', values: '1;0', dur: e.mergedConfig.halo.duration / 10 + 's', repeatCount: 'indefinite' } })]) : e._e()], 1), e._v(' '), e.paths[0] ? n('image', { attrs: { 'xlink:href': e.mergedConfig.centerPointImg.url, width: e.mergedConfig.centerPointImg.width, height: e.mergedConfig.centerPointImg.height, x: e.paths[0][2][0] - e.mergedConfig.centerPointImg.width / 2, y: e.paths[0][2][1] - e.mergedConfig.centerPointImg.height / 2 } }) : e._e(), e._v(' '), n('mask', { attrs: { id: 'maskhalo' + e.paths[0].toString() } }, [e.paths[0] ? n('use', { attrs: { 'xlink:href': '#circle' + e.paths[0].toString(), fill: 'url(#' + e.gradient2Id + ')' } }) : e._e()]), e._v(' '), e.paths[0] && e.mergedConfig.halo.show ? n('use', { attrs: { 'xlink:href': '#circle' + e.paths[0].toString(), fill: e.mergedConfig.halo.color, mask: 'url(#maskhalo' + e.paths[0].toString() + ')' } }) : e._e(), e._v(' '), e._l(e.paths, function (t, r) { return n('g', { key: r }, [n('defs', [n('path', { ref: 'path' + r, refInFor: !0, attrs: { id: 'path' + t.toString(), d: 'M' + t[0].toString() + ' Q' + t[1].toString() + ' ' + t[2].toString(), fill: 'transparent' } })]), e._v(' '), n('use', { attrs: { 'xlink:href': '#path' + t.toString(), 'stroke-width': e.mergedConfig.lineWidth, stroke: e.mergedConfig.orbitColor } }), e._v(' '), e.lengths[r] ? n('use', { attrs: { 'xlink:href': '#path' + t.toString(), 'stroke-width': e.mergedConfig.lineWidth, stroke: e.mergedConfig.flylineColor, mask: 'url(#mask' + e.unique + t.toString() + ')' } }, [n('animate', { attrs: { attributeName: 'stroke-dasharray', from: '0, ' + e.lengths[r], to: e.lengths[r] + ', 0', dur: e.times[r] || 0, repeatCount: 'indefinite' } })]) : e._e(), e._v(' '), n('mask', { attrs: { id: 'mask' + e.unique + t.toString() } }, [n('circle', { attrs: { cx: '0', cy: '0', r: e.mergedConfig.flylineRadius, fill: 'url(#' + e.gradientId + ')' } }, [n('animateMotion', { attrs: { dur: e.times[r] || 0, path: 'M' + t[0].toString() + ' Q' + t[1].toString() + ' ' + t[2].toString(), rotate: 'auto', repeatCount: 'indefinite' } })], 1)]), e._v(' '), n('image', { attrs: { 'xlink:href': e.mergedConfig.pointsImg.url, width: e.mergedConfig.pointsImg.width, height: e.mergedConfig.pointsImg.height, x: t[0][0] - e.mergedConfig.pointsImg.width / 2, y: t[0][1] - e.mergedConfig.pointsImg.height / 2 } }), e._v(' '), n('text', { style: 'fontSize:' + e.mergedConfig.text.fontSize + 'px;', attrs: { fill: e.mergedConfig.text.color, x: t[0][0] + e.mergedConfig.text.offset[0], y: t[0][1] + e.mergedConfig.text.offset[1] } }, [e._v('\n        ' + e._s(e.texts[r]) + '\n      ')])]) })], 2) : e._e()]) }; Qn._withStripped = !0; const Hn = a({ render: Qn, staticRenderFns: [] }, function (e) { e && e('data-v-e406698c_0', { source: '.dv-flyline-chart {\n  display: flex;\n  flex-direction: column;\n  background-size: 100% 100%;\n}\n.dv-flyline-chart polyline {\n  transition: all 0.3s;\n}\n.dv-flyline-chart text {\n  text-anchor: middle;\n  dominant-baseline: middle;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,aAAa;EACb,sBAAsB;EACtB,0BAA0B;AAC5B;AACA;EACE,oBAAoB;AACtB;AACA;EACE,mBAAmB;EACnB,yBAAyB;AAC3B', file: 'main.vue', sourcesContent: ['.dv-flyline-chart {\n  display: flex;\n  flex-direction: column;\n  background-size: 100% 100%;\n}\n.dv-flyline-chart polyline {\n  transition: all 0.3s;\n}\n.dv-flyline-chart text {\n  text-anchor: middle;\n  dominant-baseline: middle;\n}\n'] }, media: void 0 }) }, Xn, void 0, !1, void 0, d, void 0); function Un (e) { e.component(Hn.name, Hn) } const Vn = { name: 'DvFlylineChartEnhanced', mixins: [r], props: { config: { type: Object, default: () => ({}) }, dev: { type: Boolean, default: !1 } }, data () { const e = Date.now(); return { ref: 'dv-flyline-chart-enhanced', unique: Math.random(), flylineGradientId: `flyline-gradient-id-${e}`, haloGradientId: `halo-gradient-id-${e}`, defaultConfig: { points: [], lines: [], halo: { show: !1, duration: [20, 30], color: '#fb7293', radius: 120 }, text: { show: !1, offset: [0, 15], color: '#ffdb5c', fontSize: 12 }, icon: { show: !1, src: '', width: 15, height: 15 }, line: { width: 1, color: '#ffde93', orbitColor: 'rgba(103, 224, 227, .2)', duration: [20, 30], radius: 100 }, bgImgSrc: '', k: -0.5, curvature: 5, relative: !0 }, flylines: [], flylineLengths: [], flylinePoints: [], mergedConfig: null } }, watch: { config () { const { calcData: e } = this; e() } }, methods: { afterAutoResizeMixinInit () { const { calcData: e } = this; e() }, onResize () { const { calcData: e } = this; e() }, async calcData () { const { mergeConfig: e, calcflylinePoints: t, calcLinePaths: n } = this; e(), t(), n(); const { calcLineLengths: r } = this; await r() }, mergeConfig () { const { config: e, defaultConfig: t } = this; const n = L(I(t, !0), e || {}); const { points: r, lines: i, halo: o, text: a, icon: s, line: l } = n; n.points = r.map(e => (e.halo = L(I(o, !0), e.halo || {}), e.text = L(I(a, !0), e.text || {}), e.icon = L(I(s, !0), e.icon || {}), e)), n.lines = i.map(e => L(I(l, !0), e)), this.mergedConfig = n }, calcflylinePoints () { const { mergedConfig: e, width: n, height: r } = this; const { relative: i, points: o } = e; this.flylinePoints = o.map((e, o) => { const { coordinate: [a, s], halo: l, icon: d, text: c } = e; i && (e.coordinate = [a * n, s * r]), e.halo.time = t(...l.duration) / 10; const { width: u, height: f } = d; e.icon.x = e.coordinate[0] - u / 2, e.icon.y = e.coordinate[1] - f / 2; const [h, p] = c.offset; return e.text.x = e.coordinate[0] + h, e.text.y = e.coordinate[1] + p, e.key = `${e.coordinate.toString()}${o}`, e }) }, calcLinePaths () { const { getPath: e, mergedConfig: n } = this; const { points: r, lines: i } = n; this.flylines = i.map(n => { const { source: i, target: o, duration: a } = n; const s = r.find(({ name: e }) => e === i).coordinate; const l = r.find(({ name: e }) => e === o).coordinate; const d = e(s, l).map(e => e.map(e => parseFloat(e.toFixed(10)))); const c = `M${d[0].toString()} Q${d[1].toString()} ${d[2].toString()}`; const u = `path${d.toString()}`; const f = t(...a) / 10; return { ...n, path: d, key: u, d: c, time: f } }) }, getPath (e, t) { const { getControlPoint: n } = this; return [e, n(e, t), t] }, getControlPoint ([e, t], [r, i]) { const { getKLinePointByx: o, mergedConfig: a } = this; const { curvature: s, k: l } = a; const [d, c] = [(e + r) / 2, (t + i) / 2]; const u = n([e, t], [r, i]) / s; const f = u / 2; let [h, p] = [d, c]; do { p = o(l, [d, c], h += f)[1] } while (n([d, c], [h, p]) < u); return [h, p] }, getKLinePointByx: (e, [t, n], r) => [r, n - e * t + e * r], async calcLineLengths () { const { $nextTick: e, flylines: t, $refs: n } = this; await e(), this.flylineLengths = t.map(({ key: e }) => n[e][0].getTotalLength()) }, consoleClickPos ({ offsetX: e, offsetY: t }) { const { width: n, height: r, dev: i } = this; if (!i) return; const o = (e / n).toFixed(2); const a = (t / r).toFixed(2); console.warn(`dv-flyline-chart-enhanced DEV: \n Click Position is [${e}, ${t}] \n Relative Position is [${o}, ${a}]`) } } }; const qn = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-flyline-chart-enhanced', style: 'background-image: url(' + (e.mergedConfig ? e.mergedConfig.bgImgSrc : '') + ')', on: { click: e.consoleClickPos } }, [e.flylines.length ? n('svg', { attrs: { width: e.width, height: e.height } }, [n('defs', [n('radialGradient', { attrs: { id: e.flylineGradientId, cx: '50%', cy: '50%', r: '50%' } }, [n('stop', { attrs: { offset: '0%', 'stop-color': '#fff', 'stop-opacity': '1' } }), e._v(' '), n('stop', { attrs: { offset: '100%', 'stop-color': '#fff', 'stop-opacity': '0' } })], 1), e._v(' '), n('radialGradient', { attrs: { id: e.haloGradientId, cx: '50%', cy: '50%', r: '50%' } }, [n('stop', { attrs: { offset: '0%', 'stop-color': '#fff', 'stop-opacity': '0' } }), e._v(' '), n('stop', { attrs: { offset: '100%', 'stop-color': '#fff', 'stop-opacity': '1' } })], 1)], 1), e._v(' '), e._l(e.flylinePoints, function (t) { return n('g', { key: t.key + Math.random() }, [n('defs', [t.halo.show ? n('circle', { attrs: { id: 'halo' + e.unique + t.key, cx: t.coordinate[0], cy: t.coordinate[1] } }, [n('animate', { attrs: { attributeName: 'r', values: '1;' + t.halo.radius, dur: t.halo.time + 's', repeatCount: 'indefinite' } }), e._v(' '), n('animate', { attrs: { attributeName: 'opacity', values: '1;0', dur: t.halo.time + 's', repeatCount: 'indefinite' } })]) : e._e()]), e._v(' '), n('mask', { attrs: { id: 'mask' + e.unique + t.key } }, [t.halo.show ? n('use', { attrs: { 'xlink:href': '#halo' + e.unique + t.key, fill: 'url(#' + e.haloGradientId + ')' } }) : e._e()]), e._v(' '), t.halo.show ? n('use', { attrs: { 'xlink:href': '#halo' + e.unique + t.key, fill: t.halo.color, mask: 'url(#mask' + e.unique + t.key + ')' } }) : e._e(), e._v(' '), t.icon.show ? n('image', { attrs: { 'xlink:href': t.icon.src, width: t.icon.width, height: t.icon.height, x: t.icon.x, y: t.icon.y } }) : e._e(), e._v(' '), t.text.show ? n('text', { style: 'fontSize:' + t.text.fontSize + 'px;color:' + t.text.color, attrs: { fill: t.text.color, x: t.text.x, y: t.text.y } }, [e._v('\n        ' + e._s(t.name) + '\n      ')]) : e._e()]) }), e._v(' '), e._l(e.flylines, function (t, r) { return n('g', { key: t.key + Math.random() }, [n('defs', [n('path', { ref: t.key, refInFor: !0, attrs: { id: t.key, d: t.d, fill: 'transparent' } })]), e._v(' '), n('use', { attrs: { 'xlink:href': '#' + t.key, 'stroke-width': t.width, stroke: t.orbitColor } }), e._v(' '), n('mask', { attrs: { id: 'mask' + e.unique + t.key } }, [n('circle', { attrs: { cx: '0', cy: '0', r: t.radius, fill: 'url(#' + e.flylineGradientId + ')' } }, [n('animateMotion', { attrs: { dur: t.time, path: t.d, rotate: 'auto', repeatCount: 'indefinite' } })], 1)]), e._v(' '), e.flylineLengths[r] ? n('use', { attrs: { 'xlink:href': '#' + t.key, 'stroke-width': t.width, stroke: t.color, mask: 'url(#mask' + e.unique + t.key + ')' } }, [n('animate', { attrs: { attributeName: 'stroke-dasharray', from: '0, ' + e.flylineLengths[r], to: e.flylineLengths[r] + ', 0', dur: t.time, repeatCount: 'indefinite' } })]) : e._e()]) })], 2) : e._e()]) }; qn._withStripped = !0; const Zn = a({ render: qn, staticRenderFns: [] }, function (e) { e && e('data-v-5cc44b0b_0', { source: '.dv-flyline-chart-enhanced {\n  display: flex;\n  flex-direction: column;\n  background-size: 100% 100%;\n}\n.dv-flyline-chart-enhanced text {\n  text-anchor: middle;\n  dominant-baseline: middle;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,aAAa;EACb,sBAAsB;EACtB,0BAA0B;AAC5B;AACA;EACE,mBAAmB;EACnB,yBAAyB;AAC3B', file: 'main.vue', sourcesContent: ['.dv-flyline-chart-enhanced {\n  display: flex;\n  flex-direction: column;\n  background-size: 100% 100%;\n}\n.dv-flyline-chart-enhanced text {\n  text-anchor: middle;\n  dominant-baseline: middle;\n}\n'] }, media: void 0 }) }, Vn, void 0, !1, void 0, d, void 0); function Kn (e) { e.component(Zn.name, Zn) } const Jn = { name: 'DvConicalColumnChart', mixins: [r], props: { config: { type: Object, default: () => ({}) } }, data: () => ({ ref: 'conical-column-chart', defaultConfig: { data: [], img: [], fontSize: 12, imgSideLength: 30, columnColor: 'rgba(0, 194, 255, 0.4)', textColor: '#fff', showValue: !1 }, mergedConfig: null, column: [] }), watch: { config () { const { calcData: e } = this; e() } }, methods: { afterAutoResizeMixinInit () { const { calcData: e } = this; e() }, onResize () { const { calcData: e } = this; e() }, calcData () { const { mergeConfig: e, initData: t, calcSVGPath: n } = this; e(), t(), n() }, mergeConfig () { const { defaultConfig: e, config: t } = this; this.mergedConfig = L(I(e, !0), t || {}) }, initData () { const { mergedConfig: e } = this; let { data: t } = e; (t = I(t, !0)).sort(({ value: e }, { value: t }) => e > t ? -1 : e < t ? 1 : e === t ? 0 : void 0); const n = t[0] ? t[0].value : 10; t = t.map(e => ({ ...e, percent: e.value / n })), e.data = t }, calcSVGPath () { const { mergedConfig: e, width: t, height: n } = this; const { imgSideLength: r, fontSize: i, data: o } = e; const a = t / (o.length + 1); const s = n - r - i - 5; const l = n - i - 5; this.column = o.map((e, t) => { const { percent: n } = e; const r = a * (t + 1); const o = a * t; const d = l - s * n; const c = s * n * 0.6 + d; const u = `\n          M${o}, ${l}\n          Q${r}, ${c} ${r},${d}\n          M${r},${d}\n          Q${r}, ${c} ${a * (t + 2)},${l}\n          L${o}, ${l}\n          Z\n        `; const f = (l + d) / 2 + i / 2; return { ...e, d: u, x: r, y: d, textY: f } }) } } }; const er = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-conical-column-chart' }, [n('svg', { attrs: { width: e.width, height: e.height } }, e._l(e.column, function (t, r) { return n('g', { key: r }, [n('path', { attrs: { d: t.d, fill: e.mergedConfig.columnColor } }), e._v(' '), n('text', { style: 'fontSize:' + e.mergedConfig.fontSize + 'px', attrs: { fill: e.mergedConfig.textColor, x: t.x, y: e.height - 4 } }, [e._v('\n        ' + e._s(t.name) + '\n      ')]), e._v(' '), e.mergedConfig.img.length ? n('image', { attrs: { 'xlink:href': e.mergedConfig.img[r % e.mergedConfig.img.length], width: e.mergedConfig.imgSideLength, height: e.mergedConfig.imgSideLength, x: t.x - e.mergedConfig.imgSideLength / 2, y: t.y - e.mergedConfig.imgSideLength } }) : e._e(), e._v(' '), e.mergedConfig.showValue ? n('text', { style: 'fontSize:' + e.mergedConfig.fontSize + 'px', attrs: { fill: e.mergedConfig.textColor, x: t.x, y: t.textY } }, [e._v('\n        ' + e._s(t.value) + '\n      ')]) : e._e()]) }), 0)]) }; er._withStripped = !0; const tr = a({ render: er, staticRenderFns: [] }, function (e) { e && e('data-v-382f06c7_0', { source: '.dv-conical-column-chart {\n  width: 100%;\n  height: 100%;\n}\n.dv-conical-column-chart text {\n  text-anchor: middle;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,mBAAmB;AACrB', file: 'main.vue', sourcesContent: ['.dv-conical-column-chart {\n  width: 100%;\n  height: 100%;\n}\n.dv-conical-column-chart text {\n  text-anchor: middle;\n}\n'] }, media: void 0 }) }, Jn, void 0, !1, void 0, d, void 0); function nr (e) { e.component(tr.name, tr) } function rr (e) { e.component(_n.name, _n) } const ir = { name: 'DvScrollBoard', mixins: [r], props: { config: { type: Object, default: () => ({}) } }, data: () => ({ ref: 'scroll-board', defaultConfig: { header: [], data: [], rowNum: 5, headerBGC: '#00BAFF', oddRowBGC: '#003B51', evenRowBGC: '#0A2732', waitTime: 2e3, headerHeight: 35, columnWidth: [], align: [], index: !1, indexHeader: '#', carousel: 'single' }, mergedConfig: null, header: [], rowsData: [], rows: [], widths: [], heights: [], avgHeight: 0, aligns: [], animationIndex: 0, animationHandler: '', updater: 0 }), watch: { config () { const { stopAnimation: e, calcData: t } = this; e(), t() } }, methods: { afterAutoResizeMixinInit () { const { calcData: e } = this; e() }, onResize () { const { mergedConfig: e, calcWidths: t, calcHeights: n } = this; e && (t(), n()) }, calcData () { const { mergeConfig: e, calcHeaderData: t, calcRowsData: n } = this; e(), t(), n(); const { calcWidths: r, calcHeights: i, calcAligns: o } = this; r(), i(), o(); const { animation: a } = this; a(!0) }, mergeConfig () { const { config: e, defaultConfig: t } = this; this.mergedConfig = L(I(t, !0), e || {}) }, calcHeaderData () { let { header: e, index: t, indexHeader: n } = this.mergedConfig; e.length ? (e = [...e], t && e.unshift(n), this.header = e) : this.header = [] }, calcRowsData () { let { data: e, index: t, headerBGC: n, rowNum: r } = this.mergedConfig; t && (e = e.map((e, t) => { e = [...e]; const r = `<span class="index" style="background-color: ${n};">${t + 1}</span>`; return e.unshift(r), e })); const i = (e = e.map((e, t) => ({ ceils: e, rowIndex: t }))).length; i > r && i < 2 * r && (e = [...e, ...e]), e = e.map((e, t) => ({ ...e, scroll: t })), this.rowsData = e, this.rows = e }, calcWidths () { const { width: e, mergedConfig: t, rowsData: n } = this; const { columnWidth: r, header: i } = t; const o = r.reduce((e, t) => e + t, 0); let a = 0; n[0] ? a = n[0].ceils.length : i.length && (a = i.length); const s = (e - o) / (a - r.length); const l = new Array(a).fill(s); this.widths = L(l, r) }, calcHeights (e = !1) { const { height: t, mergedConfig: n, header: r } = this; const { headerHeight: i, rowNum: o, data: a } = n; let s = t; r.length && (s -= i); const l = s / o; this.avgHeight = l, e || (this.heights = new Array(a.length).fill(l)) }, calcAligns () { const { header: e, mergedConfig: t } = this; const n = e.length; const r = new Array(n).fill('left'); const { align: i } = t; this.aligns = L(r, i) }, async animation (e = !1) { let { avgHeight: t, animationIndex: n, mergedConfig: r, rowsData: i, animation: o, updater: a } = this; const { waitTime: s, carousel: l, rowNum: d } = r; const c = i.length; if (d >= c) return; if (e && (await new Promise(e => setTimeout(e, s)), a !== this.updater)) return; const u = l === 'single' ? 1 : d; const f = i.slice(n); if (f.push(...i.slice(0, n)), this.rows = f, this.heights = new Array(c).fill(t), await new Promise(e => setTimeout(e, 300)), a !== this.updater) return; this.heights.splice(0, u, ...new Array(u).fill(0)); const h = (n += u) - c; h >= 0 && (n = h), this.animationIndex = n, this.animationHandler = setTimeout(o, s - 300) }, stopAnimation () { const { animationHandler: e, updater: t } = this; this.updater = (t + 1) % 999999, e && clearTimeout(e) }, emitEvent (e, t, n, r) { const { ceils: i, rowIndex: o } = n; this.$emit('click', { row: i, ceil: r, rowIndex: o, columnIndex: t }) } }, destroyed () { const { stopAnimation: e } = this; e() } }; const or = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-scroll-board' }, [e.header.length && e.mergedConfig ? n('div', { staticClass: 'header', style: 'background-color: ' + e.mergedConfig.headerBGC + ';' }, e._l(e.header, function (t, r) { return n('div', { key: t + r, staticClass: 'header-item', style: '\n        height: ' + e.mergedConfig.headerHeight + 'px;\n        line-height: ' + e.mergedConfig.headerHeight + 'px;\n        width: ' + e.widths[r] + 'px;\n      ', attrs: { align: e.aligns[r] }, domProps: { innerHTML: e._s(t) } }) }), 0) : e._e(), e._v(' '), e.mergedConfig ? n('div', { staticClass: 'rows', style: 'height: ' + (e.height - (e.header.length ? e.mergedConfig.headerHeight : 0)) + 'px;' }, e._l(e.rows, function (t, r) { return n('div', { key: t.toString() + t.scroll, staticClass: 'row-item', style: '\n        height: ' + e.heights[r] + 'px;\n        line-height: ' + e.heights[r] + 'px;\n        background-color: ' + e.mergedConfig[t.rowIndex % 2 == 0 ? 'evenRowBGC' : 'oddRowBGC'] + ';\n      ' }, e._l(t.ceils, function (i, o) { return n('div', { key: i + r + o, staticClass: 'ceil', style: 'width: ' + e.widths[o] + 'px;', attrs: { align: e.aligns[o] }, domProps: { innerHTML: e._s(i) }, on: { click: function (n) { return e.emitEvent(r, o, t, i) } } }) }), 0) }), 0) : e._e()]) }; or._withStripped = !0; const ar = a({ render: or, staticRenderFns: [] }, function (e) { e && e('data-v-1aad958a_0', { source: '.dv-scroll-board {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  color: #fff;\n}\n.dv-scroll-board .text {\n  padding: 0 10px;\n  box-sizing: border-box;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.dv-scroll-board .header {\n  display: flex;\n  flex-direction: row;\n  font-size: 15px;\n}\n.dv-scroll-board .header .header-item {\n  padding: 0 10px;\n  box-sizing: border-box;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  transition: all 0.3s;\n}\n.dv-scroll-board .rows {\n  overflow: hidden;\n}\n.dv-scroll-board .rows .row-item {\n  display: flex;\n  font-size: 14px;\n  transition: all 0.3s;\n}\n.dv-scroll-board .rows .ceil {\n  padding: 0 10px;\n  box-sizing: border-box;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.dv-scroll-board .rows .index {\n  border-radius: 3px;\n  padding: 0px 3px;\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,WAAW;AACb;AACA;EACE,eAAe;EACf,sBAAsB;EACtB,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;AACzB;AACA;EACE,aAAa;EACb,mBAAmB;EACnB,eAAe;AACjB;AACA;EACE,eAAe;EACf,sBAAsB;EACtB,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;EACvB,oBAAoB;AACtB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,aAAa;EACb,eAAe;EACf,oBAAoB;AACtB;AACA;EACE,eAAe;EACf,sBAAsB;EACtB,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;AACzB;AACA;EACE,kBAAkB;EAClB,gBAAgB;AAClB', file: 'main.vue', sourcesContent: ['.dv-scroll-board {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  color: #fff;\n}\n.dv-scroll-board .text {\n  padding: 0 10px;\n  box-sizing: border-box;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.dv-scroll-board .header {\n  display: flex;\n  flex-direction: row;\n  font-size: 15px;\n}\n.dv-scroll-board .header .header-item {\n  padding: 0 10px;\n  box-sizing: border-box;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  transition: all 0.3s;\n}\n.dv-scroll-board .rows {\n  overflow: hidden;\n}\n.dv-scroll-board .rows .row-item {\n  display: flex;\n  font-size: 14px;\n  transition: all 0.3s;\n}\n.dv-scroll-board .rows .ceil {\n  padding: 0 10px;\n  box-sizing: border-box;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.dv-scroll-board .rows .index {\n  border-radius: 3px;\n  padding: 0px 3px;\n}\n'] }, media: void 0 }) }, ir, void 0, !1, void 0, d, void 0); function sr (e) { e.component(ar.name, ar) } const lr = { name: 'DvScrollRankingBoard', mixins: [r], props: { config: { type: Object, default: () => ({}) } }, data: () => ({ ref: 'scroll-ranking-board', defaultConfig: { data: [], rowNum: 5, waitTime: 2e3, carousel: 'single', unit: '', sort: !0 }, mergedConfig: null, rowsData: [], rows: [], heights: [], animationIndex: 0, animationHandler: '', updater: 0 }), watch: { config () { const { stopAnimation: e, calcData: t } = this; e(), t() } }, methods: { afterAutoResizeMixinInit () { const { calcData: e } = this; e() }, onResize () { const { mergedConfig: e, calcHeights: t } = this; e && t(!0) }, calcData () { const { mergeConfig: e, calcRowsData: t } = this; e(), t(); const { calcHeights: n } = this; n(); const { animation: r } = this; r(!0) }, mergeConfig () { const { config: e, defaultConfig: t } = this; this.mergedConfig = L(I(t, !0), e || {}) }, calcRowsData () { let { data: e, rowNum: t, sort: n } = this.mergedConfig; n && e.sort(({ value: e }, { value: t }) => e > t ? -1 : e < t ? 1 : e === t ? 0 : void 0); const r = e.map(({ value: e }) => e); const i = Math.max(...r) || 0; const o = (e = e.map((e, t) => ({ ...e, ranking: t + 1, percent: e.value / i * 100 }))).length; o > t && o < 2 * t && (e = [...e, ...e]), e = e.map((e, t) => ({ ...e, scroll: t })), this.rowsData = e, this.rows = e }, calcHeights (e = !1) { const { height: t, mergedConfig: n } = this; const { rowNum: r, data: i } = n; const o = t / r; this.avgHeight = o, e || (this.heights = new Array(i.length).fill(o)) }, async animation (e = !1) { let { avgHeight: t, animationIndex: n, mergedConfig: r, rowsData: i, animation: o, updater: a } = this; const { waitTime: s, carousel: l, rowNum: d } = r; const c = i.length; if (d >= c) return; if (e && (await new Promise(e => setTimeout(e, s)), a !== this.updater)) return; const u = l === 'single' ? 1 : d; const f = i.slice(n); if (f.push(...i.slice(0, n)), this.rows = f, this.heights = new Array(c).fill(t), await new Promise(e => setTimeout(e, 300)), a !== this.updater) return; this.heights.splice(0, u, ...new Array(u).fill(0)); const h = (n += u) - c; h >= 0 && (n = h), this.animationIndex = n, this.animationHandler = setTimeout(o, s - 300) }, stopAnimation () { const { animationHandler: e, updater: t } = this; this.updater = (t + 1) % 999999, e && clearTimeout(e) } }, destroyed () { const { stopAnimation: e } = this; e() } }; const dr = function () { const e = this; const t = e.$createElement; const n = e._self._c || t; return n('div', { ref: e.ref, staticClass: 'dv-scroll-ranking-board' }, e._l(e.rows, function (t, r) { return n('div', { key: t.toString() + t.scroll, staticClass: 'row-item', style: 'height: ' + e.heights[r] + 'px;' }, [n('div', { staticClass: 'ranking-info' }, [n('div', { staticClass: 'rank' }, [e._v('No.' + e._s(t.ranking))]), e._v(' '), n('div', { staticClass: 'info-name', domProps: { innerHTML: e._s(t.name) } }), e._v(' '), n('div', { staticClass: 'ranking-value' }, [e._v(e._s(t.value + e.mergedConfig.unit))])]), e._v(' '), n('div', { staticClass: 'ranking-column' }, [n('div', { staticClass: 'inside-column', style: 'width: ' + t.percent + '%;' }, [n('div', { staticClass: 'shine' })])])]) }), 0) }; dr._withStripped = !0; const cr = a({ render: dr, staticRenderFns: [] }, function (e) { e && e('data-v-4fe9e817_0', { source: '.dv-scroll-ranking-board {\n  width: 100%;\n  height: 100%;\n  color: #fff;\n  overflow: hidden;\n}\n.dv-scroll-ranking-board .row-item {\n  transition: all 0.3s;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  overflow: hidden;\n}\n.dv-scroll-ranking-board .ranking-info {\n  display: flex;\n  width: 100%;\n  font-size: 13px;\n}\n.dv-scroll-ranking-board .ranking-info .rank {\n  width: 40px;\n  color: #1370fb;\n}\n.dv-scroll-ranking-board .ranking-info .info-name {\n  flex: 1;\n}\n.dv-scroll-ranking-board .ranking-column {\n  border-bottom: 2px solid rgba(19, 112, 251, 0.5);\n  margin-top: 5px;\n}\n.dv-scroll-ranking-board .ranking-column .inside-column {\n  position: relative;\n  height: 6px;\n  background-color: #1370fb;\n  margin-bottom: 2px;\n  border-radius: 1px;\n  overflow: hidden;\n}\n.dv-scroll-ranking-board .ranking-column .shine {\n  position: absolute;\n  left: 0%;\n  top: 2px;\n  height: 2px;\n  width: 50px;\n  transform: translateX(-100%);\n  background: radial-gradient(#28f8ff 5%, transparent 80%);\n  animation: shine 3s ease-in-out infinite alternate;\n}\n@keyframes shine {\n80% {\n    left: 0%;\n    transform: translateX(-100%);\n}\n100% {\n    left: 100%;\n    transform: translateX(0%);\n}\n}\n', map: { version: 3, sources: ['main.vue'], names: [], mappings: 'AAAA;EACE,WAAW;EACX,YAAY;EACZ,WAAW;EACX,gBAAgB;AAClB;AACA;EACE,oBAAoB;EACpB,aAAa;EACb,sBAAsB;EACtB,uBAAuB;EACvB,gBAAgB;AAClB;AACA;EACE,aAAa;EACb,WAAW;EACX,eAAe;AACjB;AACA;EACE,WAAW;EACX,cAAc;AAChB;AACA;EACE,OAAO;AACT;AACA;EACE,gDAAgD;EAChD,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,yBAAyB;EACzB,kBAAkB;EAClB,kBAAkB;EAClB,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,QAAQ;EACR,WAAW;EACX,WAAW;EACX,4BAA4B;EAC5B,wDAAwD;EACxD,kDAAkD;AACpD;AACA;AACE;IACE,QAAQ;IACR,4BAA4B;AAC9B;AACA;IACE,UAAU;IACV,yBAAyB;AAC3B;AACF', file: 'main.vue', sourcesContent: ['.dv-scroll-ranking-board {\n  width: 100%;\n  height: 100%;\n  color: #fff;\n  overflow: hidden;\n}\n.dv-scroll-ranking-board .row-item {\n  transition: all 0.3s;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  overflow: hidden;\n}\n.dv-scroll-ranking-board .ranking-info {\n  display: flex;\n  width: 100%;\n  font-size: 13px;\n}\n.dv-scroll-ranking-board .ranking-info .rank {\n  width: 40px;\n  color: #1370fb;\n}\n.dv-scroll-ranking-board .ranking-info .info-name {\n  flex: 1;\n}\n.dv-scroll-ranking-board .ranking-column {\n  border-bottom: 2px solid rgba(19, 112, 251, 0.5);\n  margin-top: 5px;\n}\n.dv-scroll-ranking-board .ranking-column .inside-column {\n  position: relative;\n  height: 6px;\n  background-color: #1370fb;\n  margin-bottom: 2px;\n  border-radius: 1px;\n  overflow: hidden;\n}\n.dv-scroll-ranking-board .ranking-column .shine {\n  position: absolute;\n  left: 0%;\n  top: 2px;\n  height: 2px;\n  width: 50px;\n  transform: translateX(-100%);\n  background: radial-gradient(#28f8ff 5%, transparent 80%);\n  animation: shine 3s ease-in-out infinite alternate;\n}\n@keyframes shine {\n  80% {\n    left: 0%;\n    transform: translateX(-100%);\n  }\n  100% {\n    left: 100%;\n    transform: translateX(0%);\n  }\n}\n'] }, media: void 0 }) }, lr, void 0, !1, void 0, d, void 0); function ur (e) { e.component(cr.name, cr) }e.use(function (e) { e.use(h), e.use(m), e.use(D), e.use(Y), e.use(Q), e.use(q), e.use(ee), e.use(ie), e.use(le), e.use(fe), e.use(ve), e.use(be), e.use(Pe), e.use(Ie), e.use(Me), e.use(Ge), e.use(Ne), e.use(He), e.use(Ze), e.use(tt), e.use(ot), e.use(dt), e.use(ht), e.use(mt), e.use(yt), e.use(kt), e.use(kn), e.use(Wn), e.use(Fn), e.use(zn), e.use($n), e.use(Un), e.use(Kn), e.use(nr), e.use(rr), e.use(sr), e.use(ur) }) }))
