(function () { function r (e, n, t) { function o (i, f) { if (!n[i]) { if (!e[i]) { const c = typeof require === 'function' && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); const a = new Error("Cannot find module '" + i + "'"); throw a.code = 'MODULE_NOT_FOUND', a } const p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { const n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = typeof require === 'function' && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({ 1: [function (require, module, exports) { const CRender = require('../lib/index'); window.CRender = CRender }, { '../lib/index': 6 }], 2: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _classCallCheck2 = _interopRequireDefault(require('@babel/runtime/helpers/classCallCheck')); const _color = _interopRequireDefault(require('@jiaminghi/color')); const _bezierCurve = _interopRequireDefault(require('@jiaminghi/bezier-curve')); const _util = require('../plugin/util'); const _graphs = _interopRequireDefault(require('../config/graphs')); const _graph = _interopRequireDefault(require('./graph.class')); function ownKeys (object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly)symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread (target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } const CRender = function CRender (canvas) { (0, _classCallCheck2.default)(this, CRender); if (!canvas) { console.error('CRender Missing parameters!'); return } const ctx = canvas.getContext('2d'); const clientWidth = canvas.clientWidth; const clientHeight = canvas.clientHeight; const area = [clientWidth, clientHeight]; canvas.setAttribute('width', clientWidth); canvas.setAttribute('height', clientHeight); this.ctx = ctx; this.area = area; this.animationStatus = false; this.graphs = []; this.color = _color.default; this.bezierCurve = _bezierCurve.default; canvas.addEventListener('mousedown', mouseDown.bind(this)); canvas.addEventListener('mousemove', mouseMove.bind(this)); canvas.addEventListener('mouseup', mouseUp.bind(this)) }; exports.default = CRender; CRender.prototype.clearArea = function () { let _this$ctx; const area = this.area; (_this$ctx = this.ctx).clearRect.apply(_this$ctx, [0, 0].concat((0, _toConsumableArray2.default)(area))) }; CRender.prototype.add = function () { const config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; const name = config.name; if (!name) { console.error('add Missing parameters!'); return } const graphConfig = _graphs.default.get(name); if (!graphConfig) { console.warn('No corresponding graph configuration found!'); return } const graph = new _graph.default(graphConfig, config); if (!graph.validator(graph)) return; graph.render = this; this.graphs.push(graph); this.sortGraphsByIndex(); this.drawAllGraph(); return graph }; CRender.prototype.sortGraphsByIndex = function () { const graphs = this.graphs; graphs.sort(function (a, b) { if (a.index > b.index) return 1; if (a.index === b.index) return 0; if (a.index < b.index) return -1 }) }; CRender.prototype.delGraph = function (graph) { if (typeof graph.delProcessor !== 'function') return; graph.delProcessor(this); this.graphs = this.graphs.filter(function (graph) { return graph }); this.drawAllGraph() }; CRender.prototype.delAllGraph = function () { const _this = this; this.graphs.forEach(function (graph) { return graph.delProcessor(_this) }); this.graphs = this.graphs.filter(function (graph) { return graph }); this.drawAllGraph() }; CRender.prototype.drawAllGraph = function () { const _this2 = this; this.clearArea(); this.graphs.filter(function (graph) { return graph && graph.visible }).forEach(function (graph) { return graph.drawProcessor(_this2, graph) }) }; CRender.prototype.launchAnimation = function () { const _this3 = this; const animationStatus = this.animationStatus; if (animationStatus) return; this.animationStatus = true; return new Promise(function (resolve) { animation.call(_this3, function () { _this3.animationStatus = false; resolve() }, Date.now()) }) }; function animation (callback, timeStamp) { const graphs = this.graphs; if (!animationAble(graphs)) { callback(); return }graphs.forEach(function (graph) { return graph.turnNextAnimationFrame(timeStamp) }); this.drawAllGraph(); requestAnimationFrame(animation.bind(this, callback, timeStamp)) } function animationAble (graphs) { return graphs.find(function (graph) { return !graph.animationPause && graph.animationFrameState.length }) } function mouseDown (e) { const graphs = this.graphs; const hoverGraph = graphs.find(function (graph) { return graph.status === 'hover' }); if (!hoverGraph) return; hoverGraph.status = 'active' } function mouseMove (e) { const offsetX = e.offsetX; const offsetY = e.offsetY; const position = [offsetX, offsetY]; const graphs = this.graphs; const activeGraph = graphs.find(function (graph) { return graph.status === 'active' || graph.status === 'drag' }); if (activeGraph) { if (!activeGraph.drag) return; if (typeof activeGraph.move !== 'function') { console.error('No move method is provided, cannot be dragged!'); return }activeGraph.moveProcessor(e); activeGraph.status = 'drag'; return } const hoverGraph = graphs.find(function (graph) { return graph.status === 'hover' }); const hoverAbleGraphs = graphs.filter(function (graph) { return graph.hover && (typeof graph.hoverCheck === 'function' || graph.hoverRect) }); const hoveredGraph = hoverAbleGraphs.find(function (graph) { return graph.hoverCheckProcessor(position, graph) }); if (hoveredGraph) { document.body.style.cursor = hoveredGraph.style.hoverCursor } else { document.body.style.cursor = 'default' } let hoverGraphMouseOuterIsFun = false; let hoveredGraphMouseEnterIsFun = false; if (hoverGraph)hoverGraphMouseOuterIsFun = typeof hoverGraph.mouseOuter === 'function'; if (hoveredGraph)hoveredGraphMouseEnterIsFun = typeof hoveredGraph.mouseEnter === 'function'; if (!hoveredGraph && !hoverGraph) return; if (!hoveredGraph && hoverGraph) { if (hoverGraphMouseOuterIsFun)hoverGraph.mouseOuter(e, hoverGraph); hoverGraph.status = 'static'; return } if (hoveredGraph && hoveredGraph === hoverGraph) return; if (hoveredGraph && !hoverGraph) { if (hoveredGraphMouseEnterIsFun)hoveredGraph.mouseEnter(e, hoveredGraph); hoveredGraph.status = 'hover'; return } if (hoveredGraph && hoverGraph && hoveredGraph !== hoverGraph) { if (hoverGraphMouseOuterIsFun)hoverGraph.mouseOuter(e, hoverGraph); hoverGraph.status = 'static'; if (hoveredGraphMouseEnterIsFun)hoveredGraph.mouseEnter(e, hoveredGraph); hoveredGraph.status = 'hover' } } function mouseUp (e) { const graphs = this.graphs; const activeGraph = graphs.find(function (graph) { return graph.status === 'active' }); const dragGraph = graphs.find(function (graph) { return graph.status === 'drag' }); if (activeGraph && typeof activeGraph.click === 'function')activeGraph.click(e, activeGraph); graphs.forEach(function (graph) { return graph && (graph.status = 'static') }); if (activeGraph)activeGraph.status = 'hover'; if (dragGraph)dragGraph.status = 'hover' }CRender.prototype.clone = function (graph) { const style = graph.style.getStyle(); let clonedGraph = _objectSpread({}, graph, { style: style }); delete clonedGraph.render; clonedGraph = (0, _util.deepClone)(clonedGraph, true); return this.add(clonedGraph) } }, { '../config/graphs': 5, '../plugin/util': 8, './graph.class': 3, '@babel/runtime/helpers/classCallCheck': 12, '@babel/runtime/helpers/defineProperty': 13, '@babel/runtime/helpers/interopRequireDefault': 14, '@babel/runtime/helpers/toConsumableArray': 20, '@jiaminghi/bezier-curve': 25, '@jiaminghi/color': 27 }], 3: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _regenerator = _interopRequireDefault(require('@babel/runtime/regenerator')); const _asyncToGenerator2 = _interopRequireDefault(require('@babel/runtime/helpers/asyncToGenerator')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _classCallCheck2 = _interopRequireDefault(require('@babel/runtime/helpers/classCallCheck')); const _style = _interopRequireDefault(require('./style.class')); const _transition = _interopRequireDefault(require('@jiaminghi/transition')); const _util = require('../plugin/util'); const Graph = function Graph (graph, config) { (0, _classCallCheck2.default)(this, Graph); config = (0, _util.deepClone)(config, true); const defaultConfig = { visible: true, drag: false, hover: false, index: 1, animationDelay: 0, animationFrame: 30, animationCurve: 'linear', animationPause: false, hoverRect: null, mouseEnter: null, mouseOuter: null, click: null }; const configAbleNot = { status: 'static', animationRoot: [], animationKeys: [], animationFrameState: [], cache: {} }; if (!config.shape)config.shape = {}; if (!config.style)config.style = {}; const shape = Object.assign({}, graph.shape, config.shape); Object.assign(defaultConfig, config, configAbleNot); Object.assign(this, graph, defaultConfig); this.shape = shape; this.style = new _style.default(config.style); this.addedProcessor() }; exports.default = Graph; Graph.prototype.addedProcessor = function () { if (typeof this.setGraphCenter === 'function') this.setGraphCenter(null, this); if (typeof this.added === 'function') this.added(this) }; Graph.prototype.drawProcessor = function (render, graph) { const ctx = render.ctx; graph.style.initStyle(ctx); if (typeof this.beforeDraw === 'function') this.beforeDraw(this, render); graph.draw(render, graph); if (typeof this.drawed === 'function') this.drawed(this, render); graph.style.restoreTransform(ctx) }; Graph.prototype.hoverCheckProcessor = function (position, _ref) { const hoverRect = _ref.hoverRect; const style = _ref.style; const hoverCheck = _ref.hoverCheck; const graphCenter = style.graphCenter; const rotate = style.rotate; const scale = style.scale; const translate = style.translate; if (graphCenter) { if (rotate)position = (0, _util.getRotatePointPos)(-rotate, position, graphCenter); if (scale)position = (0, _util.getScalePointPos)(scale.map(function (s) { return 1 / s }), position, graphCenter); if (translate)position = (0, _util.getTranslatePointPos)(translate.map(function (v) { return v * -1 }), position) } if (hoverRect) return _util.checkPointIsInRect.apply(void 0, [position].concat((0, _toConsumableArray2.default)(hoverRect))); return hoverCheck(position, this) }; Graph.prototype.moveProcessor = function (e) { this.move(e, this); if (typeof this.beforeMove === 'function') this.beforeMove(e, this); if (typeof this.setGraphCenter === 'function') this.setGraphCenter(e, this); if (typeof this.moved === 'function') this.moved(e, this) }; Graph.prototype.attr = function (attrName) { let change = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined; if (!attrName || change === undefined) return false; const isObject = (0, _typeof2.default)(this[attrName]) === 'object'; if (isObject)change = (0, _util.deepClone)(change, true); const render = this.render; if (attrName === 'style') { this.style.update(change) } else if (isObject) { Object.assign(this[attrName], change) } else { this[attrName] = change } if (attrName === 'index')render.sortGraphsByIndex(); render.drawAllGraph() }; Graph.prototype.animation = (function () { const _ref2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2 (attrName, change) { let wait; let changeRoot; let changeKeys; let beforeState; let animationFrame; let animationCurve; let animationDelay; let animationFrameState; let render; const _args2 = arguments; return _regenerator.default.wrap(function _callee2$ (_context2) { while (1) { switch (_context2.prev = _context2.next) { case 0:wait = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false; if (!(attrName !== 'shape' && attrName !== 'style')) { _context2.next = 4; break }console.error('Only supported shape and style animation!'); return _context2.abrupt('return'); case 4:change = (0, _util.deepClone)(change, true); if (attrName === 'style') this.style.colorProcessor(change); changeRoot = this[attrName]; changeKeys = Object.keys(change); beforeState = {}; changeKeys.forEach(function (key) { return beforeState[key] = changeRoot[key] }); animationFrame = this.animationFrame, animationCurve = this.animationCurve, animationDelay = this.animationDelay; animationFrameState = (0, _transition.default)(animationCurve, beforeState, change, animationFrame, true); this.animationRoot.push(changeRoot); this.animationKeys.push(changeKeys); this.animationFrameState.push(animationFrameState); if (!wait) { _context2.next = 17; break } return _context2.abrupt('return'); case 17:if (!(animationDelay > 0)) { _context2.next = 20; break }_context2.next = 20; return delay(animationDelay); case 20:render = this.render; return _context2.abrupt('return', new Promise(function () { const _ref3 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee (resolve) { return _regenerator.default.wrap(function _callee$ (_context) { while (1) { switch (_context.prev = _context.next) { case 0:_context.next = 2; return render.launchAnimation(); case 2:resolve(); case 3:case 'end':return _context.stop() } } }, _callee) })); return function (_x3) { return _ref3.apply(this, arguments) } }())); case 22:case 'end':return _context2.stop() } } }, _callee2, this) })); return function (_x, _x2) { return _ref2.apply(this, arguments) } }()); Graph.prototype.turnNextAnimationFrame = function (timeStamp) { const animationDelay = this.animationDelay; const animationRoot = this.animationRoot; const animationKeys = this.animationKeys; const animationFrameState = this.animationFrameState; const animationPause = this.animationPause; if (animationPause) return; if (Date.now() - timeStamp < animationDelay) return; animationRoot.forEach(function (root, i) { animationKeys[i].forEach(function (key) { root[key] = animationFrameState[i][0][key] }) }); animationFrameState.forEach(function (stateItem, i) { stateItem.shift(); const noFrame = stateItem.length === 0; if (noFrame)animationRoot[i] = null; if (noFrame)animationKeys[i] = null }); this.animationFrameState = animationFrameState.filter(function (state) { return state.length }); this.animationRoot = animationRoot.filter(function (root) { return root }); this.animationKeys = animationKeys.filter(function (keys) { return keys }) }; Graph.prototype.animationEnd = function () { const animationFrameState = this.animationFrameState; const animationKeys = this.animationKeys; const animationRoot = this.animationRoot; const render = this.render; animationRoot.forEach(function (root, i) { const currentKeys = animationKeys[i]; const lastState = animationFrameState[i].pop(); currentKeys.forEach(function (key) { return root[key] = lastState[key] }) }); this.animationFrameState = []; this.animationKeys = []; this.animationRoot = []; return render.drawAllGraph() }; Graph.prototype.pauseAnimation = function () { this.attr('animationPause', true) }; Graph.prototype.playAnimation = function () { const render = this.render; this.attr('animationPause', false); return new Promise(function () { const _ref4 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3 (resolve) { return _regenerator.default.wrap(function _callee3$ (_context3) { while (1) { switch (_context3.prev = _context3.next) { case 0:_context3.next = 2; return render.launchAnimation(); case 2:resolve(); case 3:case 'end':return _context3.stop() } } }, _callee3) })); return function (_x4) { return _ref4.apply(this, arguments) } }()) }; Graph.prototype.delProcessor = function (render) { const _this = this; const graphs = render.graphs; const index = graphs.findIndex(function (graph) { return graph === _this }); if (index === -1) return; if (typeof this.beforeDelete === 'function') this.beforeDelete(this); graphs.splice(index, 1, null); if (typeof this.deleted === 'function') this.deleted(this) }; function delay (time) { return new Promise(function (resolve) { setTimeout(resolve, time) }) } }, { '../plugin/util': 8, './style.class': 4, '@babel/runtime/helpers/asyncToGenerator': 11, '@babel/runtime/helpers/classCallCheck': 12, '@babel/runtime/helpers/interopRequireDefault': 14, '@babel/runtime/helpers/toConsumableArray': 20, '@babel/runtime/helpers/typeof': 21, '@babel/runtime/regenerator': 22, '@jiaminghi/transition': 29 }], 4: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _classCallCheck2 = _interopRequireDefault(require('@babel/runtime/helpers/classCallCheck')); const _color = require('@jiaminghi/color'); const _util = require('../plugin/util'); const Style = function Style (style) { (0, _classCallCheck2.default)(this, Style); this.colorProcessor(style); const defaultStyle = { fill: [0, 0, 0, 1], stroke: [0, 0, 0, 0], opacity: 1, lineCap: null, lineJoin: null, lineDash: null, lineDashOffset: null, shadowBlur: 0, shadowColor: [0, 0, 0, 0], shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 0, graphCenter: null, scale: null, rotate: null, translate: null, hoverCursor: 'pointer', fontStyle: 'normal', fontVarient: 'normal', fontWeight: 'normal', fontSize: 10, fontFamily: 'Arial', textAlign: 'center', textBaseline: 'middle', gradientColor: null, gradientType: 'linear', gradientParams: null, gradientWith: 'stroke', gradientStops: 'auto', colors: null }; Object.assign(this, defaultStyle, style) }; exports.default = Style; Style.prototype.colorProcessor = function (style) { const reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; const processor = reverse ? _color.getColorFromRgbValue : _color.getRgbaValue; const colorProcessorKeys = ['fill', 'stroke', 'shadowColor']; const allKeys = Object.keys(style); const colorKeys = allKeys.filter(function (key) { return colorProcessorKeys.find(function (k) { return k === key }) }); colorKeys.forEach(function (key) { return style[key] = processor(style[key]) }); const gradientColor = style.gradientColor; const colors = style.colors; if (gradientColor)style.gradientColor = gradientColor.map(function (c) { return processor(c) }); if (colors) { const colorsKeys = Object.keys(colors); colorsKeys.forEach(function (key) { return colors[key] = processor(colors[key]) }) } }; Style.prototype.initStyle = function (ctx) { initTransform(ctx, this); initGraphStyle(ctx, this); initGradient(ctx, this) }; function initTransform (ctx, style) { ctx.save(); const graphCenter = style.graphCenter; const rotate = style.rotate; const scale = style.scale; const translate = style.translate; if (!(graphCenter instanceof Array)) return; ctx.translate.apply(ctx, (0, _toConsumableArray2.default)(graphCenter)); if (rotate)ctx.rotate(rotate * Math.PI / 180); if (scale instanceof Array)ctx.scale.apply(ctx, (0, _toConsumableArray2.default)(scale)); if (translate)ctx.translate.apply(ctx, (0, _toConsumableArray2.default)(translate)); ctx.translate(-graphCenter[0], -graphCenter[1]) } const autoSetStyleKeys = ['lineCap', 'lineJoin', 'lineDashOffset', 'shadowOffsetX', 'shadowOffsetY', 'lineWidth', 'textAlign', 'textBaseline']; function initGraphStyle (ctx, style) { let fill = style.fill; let stroke = style.stroke; let shadowColor = style.shadowColor; const opacity = style.opacity; autoSetStyleKeys.forEach(function (key) { if (key || typeof key === 'number')ctx[key] = style[key] }); fill = (0, _toConsumableArray2.default)(fill); stroke = (0, _toConsumableArray2.default)(stroke); shadowColor = (0, _toConsumableArray2.default)(shadowColor); fill[3] *= opacity; stroke[3] *= opacity; shadowColor[3] *= opacity; ctx.fillStyle = (0, _color.getColorFromRgbValue)(fill); ctx.strokeStyle = (0, _color.getColorFromRgbValue)(stroke); ctx.shadowColor = (0, _color.getColorFromRgbValue)(shadowColor); let lineDash = style.lineDash; const shadowBlur = style.shadowBlur; if (lineDash) { lineDash = lineDash.map(function (v) { return v >= 0 ? v : 0 }); ctx.setLineDash(lineDash) } if (typeof shadowBlur === 'number')ctx.shadowBlur = shadowBlur > 0 ? shadowBlur : 0.001; const fontStyle = style.fontStyle; const fontVarient = style.fontVarient; const fontWeight = style.fontWeight; const fontSize = style.fontSize; const fontFamily = style.fontFamily; ctx.font = fontStyle + ' ' + fontVarient + ' ' + fontWeight + ' ' + fontSize + 'px' + ' ' + fontFamily } function initGradient (ctx, style) { if (!gradientValidator(style)) return; let gradientColor = style.gradientColor; const gradientParams = style.gradientParams; const gradientType = style.gradientType; const gradientWith = style.gradientWith; let gradientStops = style.gradientStops; const opacity = style.opacity; gradientColor = gradientColor.map(function (color) { const colorOpacity = color[3] * opacity; const clonedColor = (0, _toConsumableArray2.default)(color); clonedColor[3] = colorOpacity; return clonedColor }); gradientColor = gradientColor.map(function (c) { return (0, _color.getColorFromRgbValue)(c) }); if (gradientStops === 'auto')gradientStops = getAutoColorStops(gradientColor); const gradient = ctx['create'.concat(gradientType.slice(0, 1).toUpperCase() + gradientType.slice(1), 'Gradient')].apply(ctx, (0, _toConsumableArray2.default)(gradientParams)); gradientStops.forEach(function (stop, i) { return gradient.addColorStop(stop, gradientColor[i]) }); ctx[''.concat(gradientWith, 'Style')] = gradient } function gradientValidator (style) { const gradientColor = style.gradientColor; const gradientParams = style.gradientParams; const gradientType = style.gradientType; const gradientWith = style.gradientWith; const gradientStops = style.gradientStops; if (!gradientColor || !gradientParams) return false; if (gradientColor.length === 1) { console.warn('The gradient needs to provide at least two colors'); return false } if (gradientType !== 'linear' && gradientType !== 'radial') { console.warn('GradientType only supports linear or radial, current value is ' + gradientType); return false } const gradientParamsLength = gradientParams.length; if (gradientType === 'linear' && gradientParamsLength !== 4 || gradientType === 'radial' && gradientParamsLength !== 6) { console.warn('The expected length of gradientParams is ' + (gradientType === 'linear' ? '4' : '6')); return false } if (gradientWith !== 'fill' && gradientWith !== 'stroke') { console.warn('GradientWith only supports fill or stroke, current value is ' + gradientWith); return false } if (gradientStops !== 'auto' && !(gradientStops instanceof Array)) { console.warn("gradientStops only supports 'auto' or Number Array ([0, .5, 1]), current value is " + gradientStops); return false } return true } function getAutoColorStops (color) { const stopGap = 1 / (color.length - 1); return color.map(function (foo, i) { return stopGap * i }) }Style.prototype.restoreTransform = function (ctx) { ctx.restore() }; Style.prototype.update = function (change) { this.colorProcessor(change); Object.assign(this, change) }; Style.prototype.getStyle = function () { const clonedStyle = (0, _util.deepClone)(this, true); this.colorProcessor(clonedStyle, true); return clonedStyle } }, { '../plugin/util': 8, '@babel/runtime/helpers/classCallCheck': 12, '@babel/runtime/helpers/interopRequireDefault': 14, '@babel/runtime/helpers/toConsumableArray': 20, '@jiaminghi/color': 27 }], 5: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.extendNewGraph = extendNewGraph; exports.default = exports.text = exports.bezierCurve = exports.smoothline = exports.polyline = exports.regPolygon = exports.sector = exports.arc = exports.ring = exports.rect = exports.ellipse = exports.circle = void 0; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _bezierCurve2 = _interopRequireDefault(require('@jiaminghi/bezier-curve')); const _util = require('../plugin/util'); const _canvas = require('../plugin/canvas'); const polylineToBezierCurve = _bezierCurve2.default.polylineToBezierCurve; const bezierCurveToPolyline = _bezierCurve2.default.bezierCurveToPolyline; const circle = { shape: { rx: 0, ry: 0, r: 0 }, validator: function validator (_ref) { const shape = _ref.shape; const rx = shape.rx; const ry = shape.ry; const r = shape.r; if (typeof rx !== 'number' || typeof ry !== 'number' || typeof r !== 'number') { console.error('Circle shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref2, _ref3) { const ctx = _ref2.ctx; const shape = _ref3.shape; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const r = shape.r; ctx.arc(rx, ry, r > 0 ? r : 0.01, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref4) { const shape = _ref4.shape; const rx = shape.rx; const ry = shape.ry; const r = shape.r; return (0, _util.checkPointIsInCircle)(position, rx, ry, r) }, setGraphCenter: function setGraphCenter (e, _ref5) { const shape = _ref5.shape; const style = _ref5.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref6, _ref7) { const movementX = _ref6.movementX; const movementY = _ref6.movementY; const shape = _ref7.shape; this.attr('shape', { rx: shape.rx + movementX, ry: shape.ry + movementY }) } }; exports.circle = circle; const ellipse = { shape: { rx: 0, ry: 0, hr: 0, vr: 0 }, validator: function validator (_ref8) { const shape = _ref8.shape; const rx = shape.rx; const ry = shape.ry; const hr = shape.hr; const vr = shape.vr; if (typeof rx !== 'number' || typeof ry !== 'number' || typeof hr !== 'number' || typeof vr !== 'number') { console.error('Ellipse shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref9, _ref10) { const ctx = _ref9.ctx; const shape = _ref10.shape; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const hr = shape.hr; const vr = shape.vr; ctx.ellipse(rx, ry, hr > 0 ? hr : 0.01, vr > 0 ? vr : 0.01, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref11) { const shape = _ref11.shape; const rx = shape.rx; const ry = shape.ry; const hr = shape.hr; const vr = shape.vr; const a = Math.max(hr, vr); const b = Math.min(hr, vr); const c = Math.sqrt(a * a - b * b); const leftFocusPoint = [rx - c, ry]; const rightFocusPoint = [rx + c, ry]; const distance = (0, _util.getTwoPointDistance)(position, leftFocusPoint) + (0, _util.getTwoPointDistance)(position, rightFocusPoint); return distance <= 2 * a }, setGraphCenter: function setGraphCenter (e, _ref12) { const shape = _ref12.shape; const style = _ref12.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref13, _ref14) { const movementX = _ref13.movementX; const movementY = _ref13.movementY; const shape = _ref14.shape; this.attr('shape', { rx: shape.rx + movementX, ry: shape.ry + movementY }) } }; exports.ellipse = ellipse; const rect = { shape: { x: 0, y: 0, w: 0, h: 0 }, validator: function validator (_ref15) { const shape = _ref15.shape; const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; if (typeof x !== 'number' || typeof y !== 'number' || typeof w !== 'number' || typeof h !== 'number') { console.error('Rect shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref16, _ref17) { const ctx = _ref16.ctx; const shape = _ref17.shape; ctx.beginPath(); const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; ctx.rect(x, y, w, h); ctx.fill(); ctx.stroke(); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref18) { const shape = _ref18.shape; const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; return (0, _util.checkPointIsInRect)(position, x, y, w, h) }, setGraphCenter: function setGraphCenter (e, _ref19) { const shape = _ref19.shape; const style = _ref19.style; const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; style.graphCenter = [x + w / 2, y + h / 2] }, move: function move (_ref20, _ref21) { const movementX = _ref20.movementX; const movementY = _ref20.movementY; const shape = _ref21.shape; this.attr('shape', { x: shape.x + movementX, y: shape.y + movementY }) } }; exports.rect = rect; const ring = { shape: { rx: 0, ry: 0, r: 0 }, validator: function validator (_ref22) { const shape = _ref22.shape; const rx = shape.rx; const ry = shape.ry; const r = shape.r; if (typeof rx !== 'number' || typeof ry !== 'number' || typeof r !== 'number') { console.error('Ring shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref23, _ref24) { const ctx = _ref23.ctx; const shape = _ref24.shape; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const r = shape.r; ctx.arc(rx, ry, r > 0 ? r : 0.01, 0, Math.PI * 2); ctx.stroke(); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref25) { const shape = _ref25.shape; const style = _ref25.style; const rx = shape.rx; const ry = shape.ry; const r = shape.r; const lineWidth = style.lineWidth; const halfLineWidth = lineWidth / 2; const minDistance = r - halfLineWidth; const maxDistance = r + halfLineWidth; const distance = (0, _util.getTwoPointDistance)(position, [rx, ry]); return distance >= minDistance && distance <= maxDistance }, setGraphCenter: function setGraphCenter (e, _ref26) { const shape = _ref26.shape; const style = _ref26.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref27, _ref28) { const movementX = _ref27.movementX; const movementY = _ref27.movementY; const shape = _ref28.shape; this.attr('shape', { rx: shape.rx + movementX, ry: shape.ry + movementY }) } }; exports.ring = ring; const arc = { shape: { rx: 0, ry: 0, r: 0, startAngle: 0, endAngle: 0, clockWise: true }, validator: function validator (_ref29) { const shape = _ref29.shape; const keys = ['rx', 'ry', 'r', 'startAngle', 'endAngle']; if (keys.find(function (key) { return typeof shape[key] !== 'number' })) { console.error('Arc shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref30, _ref31) { const ctx = _ref30.ctx; const shape = _ref31.shape; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const r = shape.r; const startAngle = shape.startAngle; const endAngle = shape.endAngle; const clockWise = shape.clockWise; ctx.arc(rx, ry, r > 0 ? r : 0.001, startAngle, endAngle, !clockWise); ctx.stroke(); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref32) { const shape = _ref32.shape; const style = _ref32.style; const rx = shape.rx; const ry = shape.ry; const r = shape.r; const startAngle = shape.startAngle; const endAngle = shape.endAngle; const clockWise = shape.clockWise; const lineWidth = style.lineWidth; const halfLineWidth = lineWidth / 2; const insideRadius = r - halfLineWidth; const outsideRadius = r + halfLineWidth; return !(0, _util.checkPointIsInSector)(position, rx, ry, insideRadius, startAngle, endAngle, clockWise) && (0, _util.checkPointIsInSector)(position, rx, ry, outsideRadius, startAngle, endAngle, clockWise) }, setGraphCenter: function setGraphCenter (e, _ref33) { const shape = _ref33.shape; const style = _ref33.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref34, _ref35) { const movementX = _ref34.movementX; const movementY = _ref34.movementY; const shape = _ref35.shape; this.attr('shape', { rx: shape.rx + movementX, ry: shape.ry + movementY }) } }; exports.arc = arc; const sector = { shape: { rx: 0, ry: 0, r: 0, startAngle: 0, endAngle: 0, clockWise: true }, validator: function validator (_ref36) { const shape = _ref36.shape; const keys = ['rx', 'ry', 'r', 'startAngle', 'endAngle']; if (keys.find(function (key) { return typeof shape[key] !== 'number' })) { console.error('Sector shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref37, _ref38) { const ctx = _ref37.ctx; const shape = _ref38.shape; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const r = shape.r; const startAngle = shape.startAngle; const endAngle = shape.endAngle; const clockWise = shape.clockWise; ctx.arc(rx, ry, r > 0 ? r : 0.01, startAngle, endAngle, !clockWise); ctx.lineTo(rx, ry); ctx.closePath(); ctx.stroke(); ctx.fill() }, hoverCheck: function hoverCheck (position, _ref39) { const shape = _ref39.shape; const rx = shape.rx; const ry = shape.ry; const r = shape.r; const startAngle = shape.startAngle; const endAngle = shape.endAngle; const clockWise = shape.clockWise; return (0, _util.checkPointIsInSector)(position, rx, ry, r, startAngle, endAngle, clockWise) }, setGraphCenter: function setGraphCenter (e, _ref40) { const shape = _ref40.shape; const style = _ref40.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref41, _ref42) { const movementX = _ref41.movementX; const movementY = _ref41.movementY; const shape = _ref42.shape; const rx = shape.rx; const ry = shape.ry; this.attr('shape', { rx: rx + movementX, ry: ry + movementY }) } }; exports.sector = sector; const regPolygon = { shape: { rx: 0, ry: 0, r: 0, side: 0 }, validator: function validator (_ref43) { const shape = _ref43.shape; const side = shape.side; const keys = ['rx', 'ry', 'r', 'side']; if (keys.find(function (key) { return typeof shape[key] !== 'number' })) { console.error('RegPolygon shape configuration is abnormal!'); return false } if (side < 3) { console.error('RegPolygon at least trigon!'); return false } return true }, draw: function draw (_ref44, _ref45) { const ctx = _ref44.ctx; const shape = _ref45.shape; const cache = _ref45.cache; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const r = shape.r; const side = shape.side; if (!cache.points || cache.rx !== rx || cache.ry !== ry || cache.r !== r || cache.side !== side) { const _points = (0, _util.getRegularPolygonPoints)(rx, ry, r, side); Object.assign(cache, { points: _points, rx: rx, ry: ry, r: r, side: side }) } const points = cache.points; (0, _canvas.drawPolylinePath)(ctx, points); ctx.closePath(); ctx.stroke(); ctx.fill() }, hoverCheck: function hoverCheck (position, _ref46) { const cache = _ref46.cache; const points = cache.points; return (0, _util.checkPointIsInPolygon)(position, points) }, setGraphCenter: function setGraphCenter (e, _ref47) { const shape = _ref47.shape; const style = _ref47.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref48, _ref49) { const movementX = _ref48.movementX; const movementY = _ref48.movementY; const shape = _ref49.shape; const cache = _ref49.cache; const rx = shape.rx; const ry = shape.ry; cache.rx += movementX; cache.ry += movementY; this.attr('shape', { rx: rx + movementX, ry: ry + movementY }); cache.points = cache.points.map(function (_ref50) { const _ref51 = (0, _slicedToArray2.default)(_ref50, 2); const x = _ref51[0]; const y = _ref51[1]; return [x + movementX, y + movementY] }) } }; exports.regPolygon = regPolygon; const polyline = { shape: { points: [], close: false }, validator: function validator (_ref52) { const shape = _ref52.shape; const points = shape.points; if (!(points instanceof Array)) { console.error('Polyline points should be an array!'); return false } return true }, draw: function draw (_ref53, _ref54) { const ctx = _ref53.ctx; const shape = _ref54.shape; const lineWidth = _ref54.style.lineWidth; ctx.beginPath(); let points = shape.points; const close = shape.close; if (lineWidth === 1)points = (0, _util.eliminateBlur)(points); (0, _canvas.drawPolylinePath)(ctx, points); if (close) { ctx.closePath(); ctx.fill(); ctx.stroke() } else { ctx.stroke() } }, hoverCheck: function hoverCheck (position, _ref55) { const shape = _ref55.shape; const style = _ref55.style; const points = shape.points; const close = shape.close; const lineWidth = style.lineWidth; if (close) { return (0, _util.checkPointIsInPolygon)(position, points) } else { return (0, _util.checkPointIsNearPolyline)(position, points, lineWidth) } }, setGraphCenter: function setGraphCenter (e, _ref56) { const shape = _ref56.shape; const style = _ref56.style; const points = shape.points; style.graphCenter = points[0] }, move: function move (_ref57, _ref58) { const movementX = _ref57.movementX; const movementY = _ref57.movementY; const shape = _ref58.shape; const points = shape.points; const moveAfterPoints = points.map(function (_ref59) { const _ref60 = (0, _slicedToArray2.default)(_ref59, 2); const x = _ref60[0]; const y = _ref60[1]; return [x + movementX, y + movementY] }); this.attr('shape', { points: moveAfterPoints }) } }; exports.polyline = polyline; const smoothline = { shape: { points: [], close: false }, validator: function validator (_ref61) { const shape = _ref61.shape; const points = shape.points; if (!(points instanceof Array)) { console.error('Smoothline points should be an array!'); return false } return true }, draw: function draw (_ref62, _ref63) { const ctx = _ref62.ctx; const shape = _ref63.shape; const cache = _ref63.cache; const points = shape.points; const close = shape.close; if (!cache.points || cache.points.toString() !== points.toString()) { const _bezierCurve = polylineToBezierCurve(points, close); const hoverPoints = bezierCurveToPolyline(_bezierCurve); Object.assign(cache, { points: (0, _util.deepClone)(points, true), bezierCurve: _bezierCurve, hoverPoints: hoverPoints }) } const bezierCurve = cache.bezierCurve; ctx.beginPath(); (0, _canvas.drawBezierCurvePath)(ctx, bezierCurve.slice(1), bezierCurve[0]); if (close) { ctx.closePath(); ctx.fill(); ctx.stroke() } else { ctx.stroke() } }, hoverCheck: function hoverCheck (position, _ref64) { const cache = _ref64.cache; const shape = _ref64.shape; const style = _ref64.style; const hoverPoints = cache.hoverPoints; const close = shape.close; const lineWidth = style.lineWidth; if (close) { return (0, _util.checkPointIsInPolygon)(position, hoverPoints) } else { return (0, _util.checkPointIsNearPolyline)(position, hoverPoints, lineWidth) } }, setGraphCenter: function setGraphCenter (e, _ref65) { const shape = _ref65.shape; const style = _ref65.style; const points = shape.points; style.graphCenter = points[0] }, move: function move (_ref66, _ref67) { const movementX = _ref66.movementX; const movementY = _ref66.movementY; const shape = _ref67.shape; const cache = _ref67.cache; const points = shape.points; const moveAfterPoints = points.map(function (_ref68) { const _ref69 = (0, _slicedToArray2.default)(_ref68, 2); const x = _ref69[0]; const y = _ref69[1]; return [x + movementX, y + movementY] }); cache.points = moveAfterPoints; const _cache$bezierCurve$ = (0, _slicedToArray2.default)(cache.bezierCurve[0], 2); const fx = _cache$bezierCurve$[0]; const fy = _cache$bezierCurve$[1]; const curves = cache.bezierCurve.slice(1); cache.bezierCurve = [[fx + movementX, fy + movementY]].concat((0, _toConsumableArray2.default)(curves.map(function (curve) { return curve.map(function (_ref70) { const _ref71 = (0, _slicedToArray2.default)(_ref70, 2); const x = _ref71[0]; const y = _ref71[1]; return [x + movementX, y + movementY] }) }))); cache.hoverPoints = cache.hoverPoints.map(function (_ref72) { const _ref73 = (0, _slicedToArray2.default)(_ref72, 2); const x = _ref73[0]; const y = _ref73[1]; return [x + movementX, y + movementY] }); this.attr('shape', { points: moveAfterPoints }) } }; exports.smoothline = smoothline; const bezierCurve = { shape: { points: [], close: false }, validator: function validator (_ref74) { const shape = _ref74.shape; const points = shape.points; if (!(points instanceof Array)) { console.error('BezierCurve points should be an array!'); return false } return true }, draw: function draw (_ref75, _ref76) { const ctx = _ref75.ctx; const shape = _ref76.shape; const cache = _ref76.cache; const points = shape.points; const close = shape.close; if (!cache.points || cache.points.toString() !== points.toString()) { const hoverPoints = bezierCurveToPolyline(points, 20); Object.assign(cache, { points: (0, _util.deepClone)(points, true), hoverPoints: hoverPoints }) }ctx.beginPath(); (0, _canvas.drawBezierCurvePath)(ctx, points.slice(1), points[0]); if (close) { ctx.closePath(); ctx.fill(); ctx.stroke() } else { ctx.stroke() } }, hoverCheck: function hoverCheck (position, _ref77) { const cache = _ref77.cache; const shape = _ref77.shape; const style = _ref77.style; const hoverPoints = cache.hoverPoints; const close = shape.close; const lineWidth = style.lineWidth; if (close) { return (0, _util.checkPointIsInPolygon)(position, hoverPoints) } else { return (0, _util.checkPointIsNearPolyline)(position, hoverPoints, lineWidth) } }, setGraphCenter: function setGraphCenter (e, _ref78) { const shape = _ref78.shape; const style = _ref78.style; const points = shape.points; style.graphCenter = points[0] }, move: function move (_ref79, _ref80) { const movementX = _ref79.movementX; const movementY = _ref79.movementY; const shape = _ref80.shape; const cache = _ref80.cache; const points = shape.points; const _points$ = (0, _slicedToArray2.default)(points[0], 2); const fx = _points$[0]; const fy = _points$[1]; const curves = points.slice(1); const bezierCurve = [[fx + movementX, fy + movementY]].concat((0, _toConsumableArray2.default)(curves.map(function (curve) { return curve.map(function (_ref81) { const _ref82 = (0, _slicedToArray2.default)(_ref81, 2); const x = _ref82[0]; const y = _ref82[1]; return [x + movementX, y + movementY] }) }))); cache.points = bezierCurve; cache.hoverPoints = cache.hoverPoints.map(function (_ref83) { const _ref84 = (0, _slicedToArray2.default)(_ref83, 2); const x = _ref84[0]; const y = _ref84[1]; return [x + movementX, y + movementY] }); this.attr('shape', { points: bezierCurve }) } }; exports.bezierCurve = bezierCurve; const text = { shape: { content: '', position: [], maxWidth: undefined, rowGap: 0 }, validator: function validator (_ref85) { const shape = _ref85.shape; const content = shape.content; const position = shape.position; const rowGap = shape.rowGap; if (typeof content !== 'string') { console.error('Text content should be a string!'); return false } if (!(position instanceof Array)) { console.error('Text position should be an array!'); return false } if (typeof rowGap !== 'number') { console.error('Text rowGap should be a number!'); return false } return true }, draw: function draw (_ref86, _ref87) { const ctx = _ref86.ctx; const shape = _ref87.shape; let content = shape.content; let position = shape.position; const maxWidth = shape.maxWidth; const rowGap = shape.rowGap; const textBaseline = ctx.textBaseline; const font = ctx.font; const fontSize = parseInt(font.replace(/\D/g, '')); const _position = position; const _position2 = (0, _slicedToArray2.default)(_position, 2); const x = _position2[0]; let y = _position2[1]; content = content.split('\n'); const rowNum = content.length; const lineHeight = fontSize + rowGap; const allHeight = rowNum * lineHeight - rowGap; let offset = 0; if (textBaseline === 'middle') { offset = allHeight / 2; y += fontSize / 2 } if (textBaseline === 'bottom') { offset = allHeight; y += fontSize }position = new Array(rowNum).fill(0).map(function (foo, i) { return [x, y + i * lineHeight - offset] }); ctx.beginPath(); content.forEach(function (text, i) { ctx.fillText.apply(ctx, [text].concat((0, _toConsumableArray2.default)(position[i]), [maxWidth])); ctx.strokeText.apply(ctx, [text].concat((0, _toConsumableArray2.default)(position[i]), [maxWidth])) }); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref88) { const shape = _ref88.shape; const style = _ref88.style; return false }, setGraphCenter: function setGraphCenter (e, _ref89) { const shape = _ref89.shape; const style = _ref89.style; const position = shape.position; style.graphCenter = (0, _toConsumableArray2.default)(position) }, move: function move (_ref90, _ref91) { const movementX = _ref90.movementX; const movementY = _ref90.movementY; const shape = _ref91.shape; const _shape$position = (0, _slicedToArray2.default)(shape.position, 2); const x = _shape$position[0]; const y = _shape$position[1]; this.attr('shape', { position: [x + movementX, y + movementY] }) } }; exports.text = text; const graphs = new Map([['circle', circle], ['ellipse', ellipse], ['rect', rect], ['ring', ring], ['arc', arc], ['sector', sector], ['regPolygon', regPolygon], ['polyline', polyline], ['smoothline', smoothline], ['bezierCurve', bezierCurve], ['text', text]]); const _default = graphs; exports.default = _default; function extendNewGraph (name, config) { if (!name || !config) { console.error('ExtendNewGraph Missing Parameters!'); return } if (!config.shape) { console.error('Required attribute of shape to extendNewGraph!'); return } if (!config.validator) { console.error('Required function of validator to extendNewGraph!'); return } if (!config.draw) { console.error('Required function of draw to extendNewGraph!'); return }graphs.set(name, config) } }, { '../plugin/canvas': 7, '../plugin/util': 8, '@babel/runtime/helpers/interopRequireDefault': 14, '@babel/runtime/helpers/slicedToArray': 19, '@babel/runtime/helpers/toConsumableArray': 20, '@jiaminghi/bezier-curve': 25 }], 6: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); Object.defineProperty(exports, 'CRender', { enumerable: true, get: function get () { return _crender.default } }); Object.defineProperty(exports, 'extendNewGraph', { enumerable: true, get: function get () { return _graphs.extendNewGraph } }); exports.default = void 0; var _crender = _interopRequireDefault(require('./class/crender.class')); var _graphs = require('./config/graphs'); const _default = _crender.default; exports.default = _default }, { './class/crender.class': 2, './config/graphs': 5, '@babel/runtime/helpers/interopRequireDefault': 14 }], 7: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.drawPolylinePath = drawPolylinePath; exports.drawBezierCurvePath = drawBezierCurvePath; exports.default = void 0; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); function drawPolylinePath (ctx, points) { const beginPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const closePath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; if (!ctx || points.length < 2) return false; if (beginPath)ctx.beginPath(); points.forEach(function (point, i) { return point && (i === 0 ? ctx.moveTo.apply(ctx, (0, _toConsumableArray2.default)(point)) : ctx.lineTo.apply(ctx, (0, _toConsumableArray2.default)(point))) }); if (closePath)ctx.closePath() } function drawBezierCurvePath (ctx, points) { const moveTo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const beginPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; const closePath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; if (!ctx || !points) return false; if (beginPath)ctx.beginPath(); if (moveTo)ctx.moveTo.apply(ctx, (0, _toConsumableArray2.default)(moveTo)); points.forEach(function (item) { return item && ctx.bezierCurveTo.apply(ctx, (0, _toConsumableArray2.default)(item[0]).concat((0, _toConsumableArray2.default)(item[1]), (0, _toConsumableArray2.default)(item[2]))) }); if (closePath)ctx.closePath() } const _default = { drawPolylinePath: drawPolylinePath, drawBezierCurvePath: drawBezierCurvePath }; exports.default = _default }, { '@babel/runtime/helpers/interopRequireDefault': 14, '@babel/runtime/helpers/toConsumableArray': 20 }], 8: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.deepClone = deepClone; exports.eliminateBlur = eliminateBlur; exports.checkPointIsInCircle = checkPointIsInCircle; exports.getTwoPointDistance = getTwoPointDistance; exports.checkPointIsInPolygon = checkPointIsInPolygon; exports.checkPointIsInSector = checkPointIsInSector; exports.checkPointIsNearPolyline = checkPointIsNearPolyline; exports.checkPointIsInRect = checkPointIsInRect; exports.getRotatePointPos = getRotatePointPos; exports.getScalePointPos = getScalePointPos; exports.getTranslatePointPos = getTranslatePointPos; exports.getDistanceBetweenPointAndLine = getDistanceBetweenPointAndLine; exports.getCircleRadianPoint = getCircleRadianPoint; exports.getRegularPolygonPoints = getRegularPolygonPoints; exports.default = void 0; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const abs = Math.abs; const sqrt = Math.sqrt; const sin = Math.sin; const cos = Math.cos; const max = Math.max; const min = Math.min; const PI = Math.PI; function deepClone (object) { const recursion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; if (!object) return object; const parse = JSON.parse; const stringify = JSON.stringify; if (!recursion) return parse(stringify(object)); const clonedObj = object instanceof Array ? [] : {}; if (object && (0, _typeof2.default)(object) === 'object') { for (const key in object) { if (object.hasOwnProperty(key)) { if (object[key] && (0, _typeof2.default)(object[key]) === 'object') { clonedObj[key] = deepClone(object[key], true) } else { clonedObj[key] = object[key] } } } } return clonedObj } function eliminateBlur (points) { return points.map(function (_ref) { const _ref2 = (0, _slicedToArray2.default)(_ref, 2); const x = _ref2[0]; const y = _ref2[1]; return [parseInt(x) + 0.5, parseInt(y) + 0.5] }) } function checkPointIsInCircle (point, rx, ry, r) { return getTwoPointDistance(point, [rx, ry]) <= r } function getTwoPointDistance (_ref3, _ref4) { const _ref5 = (0, _slicedToArray2.default)(_ref3, 2); const xa = _ref5[0]; const ya = _ref5[1]; const _ref6 = (0, _slicedToArray2.default)(_ref4, 2); const xb = _ref6[0]; const yb = _ref6[1]; const minusX = abs(xa - xb); const minusY = abs(ya - yb); return sqrt(minusX * minusX + minusY * minusY) } function checkPointIsInPolygon (point, polygon) { let counter = 0; const _point = (0, _slicedToArray2.default)(point, 2); const x = _point[0]; const y = _point[1]; const pointNum = polygon.length; for (let i = 1, p1 = polygon[0]; i <= pointNum; i++) { const p2 = polygon[i % pointNum]; if (x > min(p1[0], p2[0]) && x <= max(p1[0], p2[0])) { if (y <= max(p1[1], p2[1])) { if (p1[0] !== p2[0]) { const xinters = (x - p1[0]) * (p2[1] - p1[1]) / (p2[0] - p1[0]) + p1[1]; if (p1[1] === p2[1] || y <= xinters) { counter++ } } } }p1 = p2 } return counter % 2 === 1 } function checkPointIsInSector (point, rx, ry, r, startAngle, endAngle, clockWise) { if (!point) return false; if (getTwoPointDistance(point, [rx, ry]) > r) return false; if (!clockWise) { const _deepClone = deepClone([endAngle, startAngle]); const _deepClone2 = (0, _slicedToArray2.default)(_deepClone, 2); startAngle = _deepClone2[0]; endAngle = _deepClone2[1] } const reverseBE = startAngle > endAngle; if (reverseBE) { const _ref7 = [endAngle, startAngle]; startAngle = _ref7[0]; endAngle = _ref7[1] } const minus = endAngle - startAngle; if (minus >= PI * 2) return true; const _point2 = (0, _slicedToArray2.default)(point, 2); const x = _point2[0]; const y = _point2[1]; const _getCircleRadianPoint = getCircleRadianPoint(rx, ry, r, startAngle); const _getCircleRadianPoint2 = (0, _slicedToArray2.default)(_getCircleRadianPoint, 2); const bx = _getCircleRadianPoint2[0]; const by = _getCircleRadianPoint2[1]; const _getCircleRadianPoint3 = getCircleRadianPoint(rx, ry, r, endAngle); const _getCircleRadianPoint4 = (0, _slicedToArray2.default)(_getCircleRadianPoint3, 2); const ex = _getCircleRadianPoint4[0]; const ey = _getCircleRadianPoint4[1]; const vPoint = [x - rx, y - ry]; let vBArm = [bx - rx, by - ry]; let vEArm = [ex - rx, ey - ry]; const reverse = minus > PI; if (reverse) { const _deepClone3 = deepClone([vEArm, vBArm]); const _deepClone4 = (0, _slicedToArray2.default)(_deepClone3, 2); vBArm = _deepClone4[0]; vEArm = _deepClone4[1] } let inSector = isClockWise(vBArm, vPoint) && !isClockWise(vEArm, vPoint); if (reverse)inSector = !inSector; if (reverseBE)inSector = !inSector; return inSector } function isClockWise (vArm, vPoint) { const _vArm = (0, _slicedToArray2.default)(vArm, 2); const ax = _vArm[0]; const ay = _vArm[1]; const _vPoint = (0, _slicedToArray2.default)(vPoint, 2); const px = _vPoint[0]; const py = _vPoint[1]; return -ay * px + ax * py > 0 } function checkPointIsNearPolyline (point, polyline, lineWidth) { const halfLineWidth = lineWidth / 2; const moveUpPolyline = polyline.map(function (_ref8) { const _ref9 = (0, _slicedToArray2.default)(_ref8, 2); const x = _ref9[0]; const y = _ref9[1]; return [x, y - halfLineWidth] }); const moveDownPolyline = polyline.map(function (_ref10) { const _ref11 = (0, _slicedToArray2.default)(_ref10, 2); const x = _ref11[0]; const y = _ref11[1]; return [x, y + halfLineWidth] }); const polygon = [].concat((0, _toConsumableArray2.default)(moveUpPolyline), (0, _toConsumableArray2.default)(moveDownPolyline.reverse())); return checkPointIsInPolygon(point, polygon) } function checkPointIsInRect (_ref12, x, y, width, height) { const _ref13 = (0, _slicedToArray2.default)(_ref12, 2); const px = _ref13[0]; const py = _ref13[1]; if (px < x) return false; if (py < y) return false; if (px > x + width) return false; if (py > y + height) return false; return true } function getRotatePointPos () { let rotate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; const point = arguments.length > 1 ? arguments[1] : undefined; const origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0]; if (!point) return false; if (rotate % 360 === 0) return point; const _point3 = (0, _slicedToArray2.default)(point, 2); const x = _point3[0]; const y = _point3[1]; const _origin = (0, _slicedToArray2.default)(origin, 2); const ox = _origin[0]; const oy = _origin[1]; rotate *= PI / 180; return [(x - ox) * cos(rotate) - (y - oy) * sin(rotate) + ox, (x - ox) * sin(rotate) + (y - oy) * cos(rotate) + oy] } function getScalePointPos () { const scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [1, 1]; const point = arguments.length > 1 ? arguments[1] : undefined; const origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0]; if (!point) return false; if (scale === 1) return point; const _point4 = (0, _slicedToArray2.default)(point, 2); const x = _point4[0]; const y = _point4[1]; const _origin2 = (0, _slicedToArray2.default)(origin, 2); const ox = _origin2[0]; const oy = _origin2[1]; const _scale = (0, _slicedToArray2.default)(scale, 2); const xs = _scale[0]; const ys = _scale[1]; const relativePosX = x - ox; const relativePosY = y - oy; return [relativePosX * xs + ox, relativePosY * ys + oy] } function getTranslatePointPos (translate, point) { if (!translate || !point) return false; const _point5 = (0, _slicedToArray2.default)(point, 2); const x = _point5[0]; const y = _point5[1]; const _translate = (0, _slicedToArray2.default)(translate, 2); const tx = _translate[0]; const ty = _translate[1]; return [x + tx, y + ty] } function getDistanceBetweenPointAndLine (point, lineBegin, lineEnd) { if (!point || !lineBegin || !lineEnd) return false; const _point6 = (0, _slicedToArray2.default)(point, 2); const x = _point6[0]; const y = _point6[1]; const _lineBegin = (0, _slicedToArray2.default)(lineBegin, 2); const x1 = _lineBegin[0]; const y1 = _lineBegin[1]; const _lineEnd = (0, _slicedToArray2.default)(lineEnd, 2); const x2 = _lineEnd[0]; const y2 = _lineEnd[1]; const a = y2 - y1; const b = x1 - x2; const c = y1 * (x2 - x1) - x1 * (y2 - y1); const molecule = abs(a * x + b * y + c); const denominator = sqrt(a * a + b * b); return molecule / denominator } function getCircleRadianPoint (x, y, radius, radian) { return [x + cos(radian) * radius, y + sin(radian) * radius] } function getRegularPolygonPoints (rx, ry, r, side) { const minus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : PI * -0.5; const radianGap = PI * 2 / side; const radians = new Array(side).fill('').map(function (t, i) { return i * radianGap + minus }); return radians.map(function (radian) { return getCircleRadianPoint(rx, ry, r, radian) }) } const _default = { deepClone: deepClone, eliminateBlur: eliminateBlur, checkPointIsInCircle: checkPointIsInCircle, checkPointIsInPolygon: checkPointIsInPolygon, checkPointIsInSector: checkPointIsInSector, checkPointIsNearPolyline: checkPointIsNearPolyline, getTwoPointDistance: getTwoPointDistance, getRotatePointPos: getRotatePointPos, getScalePointPos: getScalePointPos, getTranslatePointPos: getTranslatePointPos, getCircleRadianPoint: getCircleRadianPoint, getRegularPolygonPoints: getRegularPolygonPoints, getDistanceBetweenPointAndLine: getDistanceBetweenPointAndLine }; exports.default = _default }, { '@babel/runtime/helpers/interopRequireDefault': 14, '@babel/runtime/helpers/slicedToArray': 19, '@babel/runtime/helpers/toConsumableArray': 20, '@babel/runtime/helpers/typeof': 21 }], 9: [function (require, module, exports) { function _arrayWithHoles (arr) { if (Array.isArray(arr)) return arr }module.exports = _arrayWithHoles }, {}], 10: [function (require, module, exports) { function _arrayWithoutHoles (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i] } return arr2 } }module.exports = _arrayWithoutHoles }, {}], 11: [function (require, module, exports) { function asyncGeneratorStep (gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value } catch (error) { reject(error); return } if (info.done) { resolve(value) } else { Promise.resolve(value).then(_next, _throw) } } function _asyncToGenerator (fn) { return function () { const self = this; const args = arguments; return new Promise(function (resolve, reject) { const gen = fn.apply(self, args); function _next (value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value) } function _throw (err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err) }_next(undefined) }) } }module.exports = _asyncToGenerator }, {}], 12: [function (require, module, exports) { function _classCallCheck (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function') } }module.exports = _classCallCheck }, {}], 13: [function (require, module, exports) { function _defineProperty (obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }) } else { obj[key] = value } return obj }module.exports = _defineProperty }, {}], 14: [function (require, module, exports) { function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { default: obj } }module.exports = _interopRequireDefault }, {}], 15: [function (require, module, exports) { function _iterableToArray (iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === '[object Arguments]') return Array.from(iter) }module.exports = _iterableToArray }, {}], 16: [function (require, module, exports) { function _iterableToArrayLimit (arr, i) { const _arr = []; let _n = true; let _d = false; let _e; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break } } catch (err) { _d = true; _e = err } finally { try { if (!_n && _i.return != null)_i.return() } finally { if (_d) throw _e } } return _arr }module.exports = _iterableToArrayLimit }, {}], 17: [function (require, module, exports) { function _nonIterableRest () { throw new TypeError('Invalid attempt to destructure non-iterable instance') }module.exports = _nonIterableRest }, {}], 18: [function (require, module, exports) { function _nonIterableSpread () { throw new TypeError('Invalid attempt to spread non-iterable instance') }module.exports = _nonIterableSpread }, {}], 19: [function (require, module, exports) { const arrayWithHoles = require('./arrayWithHoles'); const iterableToArrayLimit = require('./iterableToArrayLimit'); const nonIterableRest = require('./nonIterableRest'); function _slicedToArray (arr, i) { return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest() }module.exports = _slicedToArray }, { './arrayWithHoles': 9, './iterableToArrayLimit': 16, './nonIterableRest': 17 }], 20: [function (require, module, exports) { const arrayWithoutHoles = require('./arrayWithoutHoles'); const iterableToArray = require('./iterableToArray'); const nonIterableSpread = require('./nonIterableSpread'); function _toConsumableArray (arr) { return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread() }module.exports = _toConsumableArray }, { './arrayWithoutHoles': 10, './iterableToArray': 15, './nonIterableSpread': 18 }], 21: [function (require, module, exports) { function _typeof2 (obj) { if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') { _typeof2 = function _typeof2 (obj) { return typeof obj } } else { _typeof2 = function _typeof2 (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj } } return _typeof2(obj) } function _typeof (obj) { if (typeof Symbol === 'function' && _typeof2(Symbol.iterator) === 'symbol') { module.exports = _typeof = function _typeof (obj) { return _typeof2(obj) } } else { module.exports = _typeof = function _typeof (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : _typeof2(obj) } } return _typeof(obj) }module.exports = _typeof }, {}], 22: [function (require, module, exports) { module.exports = require('regenerator-runtime') }, { 'regenerator-runtime': 30 }], 23: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.bezierCurveToPolyline = bezierCurveToPolyline; exports.getBezierCurveLength = getBezierCurveLength; exports.default = void 0; function _slicedToArray (arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest() } function _nonIterableRest () { throw new TypeError('Invalid attempt to destructure non-iterable instance') } function _iterableToArrayLimit (arr, i) { const _arr = []; let _n = true; let _d = false; let _e; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break } } catch (err) { _d = true; _e = err } finally { try { if (!_n && _i.return != null)_i.return() } finally { if (_d) throw _e } } return _arr } function _arrayWithHoles (arr) { if (Array.isArray(arr)) return arr } function _toConsumableArray (arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread() } function _nonIterableSpread () { throw new TypeError('Invalid attempt to spread non-iterable instance') } function _iterableToArray (iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === '[object Arguments]') return Array.from(iter) } function _arrayWithoutHoles (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i] } return arr2 } } const sqrt = Math.sqrt; const pow = Math.pow; const ceil = Math.ceil; const abs = Math.abs; const defaultSegmentPointsNum = 50; function abstractBezierCurveToPolyline (bezierCurve) { const precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5; const segmentsNum = bezierCurve.length - 1; const startPoint = bezierCurve[0]; const endPoint = bezierCurve[segmentsNum][2]; const segments = bezierCurve.slice(1); const getSegmentTPointFuns = segments.map(function (seg, i) { const beginPoint = i === 0 ? startPoint : segments[i - 1][2]; return createGetBezierCurveTPointFun.apply(void 0, [beginPoint].concat(_toConsumableArray(seg))) }); const segmentPointsNum = new Array(segmentsNum).fill(defaultSegmentPointsNum); const segmentPoints = getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum); const result = calcUniformPointsByIteration(segmentPoints, getSegmentTPointFuns, segments, precision); result.segmentPoints.push(endPoint); return result } function createGetBezierCurveTPointFun (beginPoint, controlPoint1, controlPoint2, endPoint) { return function (t) { const tSubed1 = 1 - t; const tSubed1Pow3 = pow(tSubed1, 3); const tSubed1Pow2 = pow(tSubed1, 2); const tPow3 = pow(t, 3); const tPow2 = pow(t, 2); return [beginPoint[0] * tSubed1Pow3 + 3 * controlPoint1[0] * t * tSubed1Pow2 + 3 * controlPoint2[0] * tPow2 * tSubed1 + endPoint[0] * tPow3, beginPoint[1] * tSubed1Pow3 + 3 * controlPoint1[1] * t * tSubed1Pow2 + 3 * controlPoint2[1] * tPow2 * tSubed1 + endPoint[1] * tPow3] } } function getTwoPointDistance (_ref, _ref2) { const _ref3 = _slicedToArray(_ref, 2); const ax = _ref3[0]; const ay = _ref3[1]; const _ref4 = _slicedToArray(_ref2, 2); const bx = _ref4[0]; const by = _ref4[1]; return sqrt(pow(ax - bx, 2) + pow(ay - by, 2)) } function getNumsSum (nums) { return nums.reduce(function (sum, num) { return sum + num }, 0) } function getSegmentPointsDistance (segmentPoints) { return segmentPoints.map(function (points, i) { return new Array(points.length - 1).fill(0).map(function (temp, j) { return getTwoPointDistance(points[j], points[j + 1]) }) }) } function getSegmentPointsByNum (getSegmentTPointFuns, segmentPointsNum) { return getSegmentTPointFuns.map(function (getSegmentTPointFun, i) { const tGap = 1 / segmentPointsNum[i]; return new Array(segmentPointsNum[i]).fill('').map(function (foo, j) { return getSegmentTPointFun(j * tGap) }) }) } function getAllDeviations (segmentPointsDistance, avgLength) { return segmentPointsDistance.map(function (seg) { return seg.map(function (s) { return abs(s - avgLength) }) }).map(function (seg) { return getNumsSum(seg) }).reduce(function (total, v) { return total + v }, 0) } function calcUniformPointsByIteration (segmentPoints, getSegmentTPointFuns, segments, precision) { let rounds = 4; let cycles = 1; const _loop = function _loop () { let totalPointsNum = segmentPoints.reduce(function (total, seg) { return total + seg.length }, 0); segmentPoints.forEach(function (seg, i) { return seg.push(segments[i][2]) }); let segmentPointsDistance = getSegmentPointsDistance(segmentPoints); let lineSegmentNum = segmentPointsDistance.reduce(function (total, seg) { return total + seg.length }, 0); let segmentlength = segmentPointsDistance.map(function (seg) { return getNumsSum(seg) }); let totalLength = getNumsSum(segmentlength); let avgLength = totalLength / lineSegmentNum; const allDeviations = getAllDeviations(segmentPointsDistance, avgLength); if (allDeviations <= precision) return 'break'; totalPointsNum = ceil(avgLength / precision * totalPointsNum * 1.1); const segmentPointsNum = segmentlength.map(function (length) { return ceil(length / totalLength * totalPointsNum) }); segmentPoints = getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum); totalPointsNum = segmentPoints.reduce(function (total, seg) { return total + seg.length }, 0); const segmentPointsForLength = JSON.parse(JSON.stringify(segmentPoints)); segmentPointsForLength.forEach(function (seg, i) { return seg.push(segments[i][2]) }); segmentPointsDistance = getSegmentPointsDistance(segmentPointsForLength); lineSegmentNum = segmentPointsDistance.reduce(function (total, seg) { return total + seg.length }, 0); segmentlength = segmentPointsDistance.map(function (seg) { return getNumsSum(seg) }); totalLength = getNumsSum(segmentlength); avgLength = totalLength / lineSegmentNum; const stepSize = 1 / totalPointsNum / 10; getSegmentTPointFuns.forEach(function (getSegmentTPointFun, i) { const currentSegmentPointsNum = segmentPointsNum[i]; const t = new Array(currentSegmentPointsNum).fill('').map(function (foo, j) { return j / segmentPointsNum[i] }); for (let r = 0; r < rounds; r++) { const distance = getSegmentPointsDistance([segmentPoints[i]])[0]; const deviations = distance.map(function (d) { return d - avgLength }); let offset = 0; for (let j = 0; j < currentSegmentPointsNum; j++) { if (j === 0) return; offset += deviations[j - 1]; t[j] -= stepSize * offset; if (t[j] > 1)t[j] = 1; if (t[j] < 0)t[j] = 0; segmentPoints[i][j] = getSegmentTPointFun(t[j]) } } }); rounds *= 4; cycles++ }; do { const _ret = _loop(); if (_ret === 'break') break } while (rounds <= 1025); segmentPoints = segmentPoints.reduce(function (all, seg) { return all.concat(seg) }, []); return { segmentPoints: segmentPoints, cycles: cycles, rounds: rounds } } function bezierCurveToPolyline (bezierCurve) { const precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5; if (!bezierCurve) { console.error('bezierCurveToPolyline: Missing parameters!'); return false } if (!(bezierCurve instanceof Array)) { console.error('bezierCurveToPolyline: Parameter bezierCurve must be an array!'); return false } if (typeof precision !== 'number') { console.error('bezierCurveToPolyline: Parameter precision must be a number!'); return false } const _abstractBezierCurveT = abstractBezierCurveToPolyline(bezierCurve, precision); const segmentPoints = _abstractBezierCurveT.segmentPoints; return segmentPoints } function getBezierCurveLength (bezierCurve) { const precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5; if (!bezierCurve) { console.error('getBezierCurveLength: Missing parameters!'); return false } if (!(bezierCurve instanceof Array)) { console.error('getBezierCurveLength: Parameter bezierCurve must be an array!'); return false } if (typeof precision !== 'number') { console.error('getBezierCurveLength: Parameter precision must be a number!'); return false } const _abstractBezierCurveT2 = abstractBezierCurveToPolyline(bezierCurve, precision); const segmentPoints = _abstractBezierCurveT2.segmentPoints; const pointsDistance = getSegmentPointsDistance([segmentPoints])[0]; const length = getNumsSum(pointsDistance); return length } const _default = bezierCurveToPolyline; exports.default = _default }, {}], 24: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; function _slicedToArray (arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest() } function _nonIterableRest () { throw new TypeError('Invalid attempt to destructure non-iterable instance') } function _iterableToArrayLimit (arr, i) { const _arr = []; let _n = true; let _d = false; let _e; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break } } catch (err) { _d = true; _e = err } finally { try { if (!_n && _i.return != null)_i.return() } finally { if (_d) throw _e } } return _arr } function _arrayWithHoles (arr) { if (Array.isArray(arr)) return arr } function _toConsumableArray (arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread() } function _nonIterableSpread () { throw new TypeError('Invalid attempt to spread non-iterable instance') } function _iterableToArray (iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === '[object Arguments]') return Array.from(iter) } function _arrayWithoutHoles (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i] } return arr2 } } function polylineToBezierCurve (polyline) { const close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; const offsetA = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.25; const offsetB = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.25; if (!(polyline instanceof Array)) { console.error('polylineToBezierCurve: Parameter polyline must be an array!'); return false } if (polyline.length <= 2) { console.error('polylineToBezierCurve: Converting to a curve requires at least 3 points!'); return false } const startPoint = polyline[0]; const bezierCurveLineNum = polyline.length - 1; const bezierCurvePoints = new Array(bezierCurveLineNum).fill(0).map(function (foo, i) { return [].concat(_toConsumableArray(getBezierCurveLineControlPoints(polyline, i, close, offsetA, offsetB)), [polyline[i + 1]]) }); if (close)closeBezierCurve(bezierCurvePoints, startPoint); bezierCurvePoints.unshift(polyline[0]); return bezierCurvePoints } function getBezierCurveLineControlPoints (polyline, index) { const close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const offsetA = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.25; const offsetB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.25; const pointNum = polyline.length; if (pointNum < 3 || index >= pointNum) return; let beforePointIndex = index - 1; if (beforePointIndex < 0)beforePointIndex = close ? pointNum + beforePointIndex : 0; let afterPointIndex = index + 1; if (afterPointIndex >= pointNum)afterPointIndex = close ? afterPointIndex - pointNum : pointNum - 1; let afterNextPointIndex = index + 2; if (afterNextPointIndex >= pointNum)afterNextPointIndex = close ? afterNextPointIndex - pointNum : pointNum - 1; const pointBefore = polyline[beforePointIndex]; const pointMiddle = polyline[index]; const pointAfter = polyline[afterPointIndex]; const pointAfterNext = polyline[afterNextPointIndex]; return [[pointMiddle[0] + offsetA * (pointAfter[0] - pointBefore[0]), pointMiddle[1] + offsetA * (pointAfter[1] - pointBefore[1])], [pointAfter[0] - offsetB * (pointAfterNext[0] - pointMiddle[0]), pointAfter[1] - offsetB * (pointAfterNext[1] - pointMiddle[1])]] } function closeBezierCurve (bezierCurve, startPoint) { const firstSubCurve = bezierCurve[0]; const lastSubCurve = bezierCurve.slice(-1)[0]; bezierCurve.push([getSymmetryPoint(lastSubCurve[1], lastSubCurve[2]), getSymmetryPoint(firstSubCurve[0], startPoint), startPoint]); return bezierCurve } function getSymmetryPoint (point, centerPoint) { const _point = _slicedToArray(point, 2); const px = _point[0]; const py = _point[1]; const _centerPoint = _slicedToArray(centerPoint, 2); const cx = _centerPoint[0]; const cy = _centerPoint[1]; const minusX = cx - px; const minusY = cy - py; return [cx + minusX, cy + minusY] } const _default = polylineToBezierCurve; exports.default = _default }, {}], 25: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); Object.defineProperty(exports, 'bezierCurveToPolyline', { enumerable: true, get: function get () { return _bezierCurveToPolyline.bezierCurveToPolyline } }); Object.defineProperty(exports, 'getBezierCurveLength', { enumerable: true, get: function get () { return _bezierCurveToPolyline.getBezierCurveLength } }); Object.defineProperty(exports, 'polylineToBezierCurve', { enumerable: true, get: function get () { return _polylineToBezierCurve.default } }); exports.default = void 0; var _bezierCurveToPolyline = require('./core/bezierCurveToPolyline'); var _polylineToBezierCurve = _interopRequireDefault(require('./core/polylineToBezierCurve')); function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { default: obj } } const _default = { bezierCurveToPolyline: _bezierCurveToPolyline.bezierCurveToPolyline, getBezierCurveLength: _bezierCurveToPolyline.getBezierCurveLength, polylineToBezierCurve: _polylineToBezierCurve.default }; exports.default = _default }, { './core/bezierCurveToPolyline': 23, './core/polylineToBezierCurve': 24 }], 26: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _default = new Map([['transparent', 'rgba(0,0,0,0)'], ['black', '#000000'], ['silver', '#C0C0C0'], ['gray', '#808080'], ['white', '#FFFFFF'], ['maroon', '#800000'], ['red', '#FF0000'], ['purple', '#800080'], ['fuchsia', '#FF00FF'], ['green', '#008000'], ['lime', '#00FF00'], ['olive', '#808000'], ['yellow', '#FFFF00'], ['navy', '#000080'], ['blue', '#0000FF'], ['teal', '#008080'], ['aqua', '#00FFFF'], ['aliceblue', '#f0f8ff'], ['antiquewhite', '#faebd7'], ['aquamarine', '#7fffd4'], ['azure', '#f0ffff'], ['beige', '#f5f5dc'], ['bisque', '#ffe4c4'], ['blanchedalmond', '#ffebcd'], ['blueviolet', '#8a2be2'], ['brown', '#a52a2a'], ['burlywood', '#deb887'], ['cadetblue', '#5f9ea0'], ['chartreuse', '#7fff00'], ['chocolate', '#d2691e'], ['coral', '#ff7f50'], ['cornflowerblue', '#6495ed'], ['cornsilk', '#fff8dc'], ['crimson', '#dc143c'], ['cyan', '#00ffff'], ['darkblue', '#00008b'], ['darkcyan', '#008b8b'], ['darkgoldenrod', '#b8860b'], ['darkgray', '#a9a9a9'], ['darkgreen', '#006400'], ['darkgrey', '#a9a9a9'], ['darkkhaki', '#bdb76b'], ['darkmagenta', '#8b008b'], ['darkolivegreen', '#556b2f'], ['darkorange', '#ff8c00'], ['darkorchid', '#9932cc'], ['darkred', '#8b0000'], ['darksalmon', '#e9967a'], ['darkseagreen', '#8fbc8f'], ['darkslateblue', '#483d8b'], ['darkslategray', '#2f4f4f'], ['darkslategrey', '#2f4f4f'], ['darkturquoise', '#00ced1'], ['darkviolet', '#9400d3'], ['deeppink', '#ff1493'], ['deepskyblue', '#00bfff'], ['dimgray', '#696969'], ['dimgrey', '#696969'], ['dodgerblue', '#1e90ff'], ['firebrick', '#b22222'], ['floralwhite', '#fffaf0'], ['forestgreen', '#228b22'], ['gainsboro', '#dcdcdc'], ['ghostwhite', '#f8f8ff'], ['gold', '#ffd700'], ['goldenrod', '#daa520'], ['greenyellow', '#adff2f'], ['grey', '#808080'], ['honeydew', '#f0fff0'], ['hotpink', '#ff69b4'], ['indianred', '#cd5c5c'], ['indigo', '#4b0082'], ['ivory', '#fffff0'], ['khaki', '#f0e68c'], ['lavender', '#e6e6fa'], ['lavenderblush', '#fff0f5'], ['lawngreen', '#7cfc00'], ['lemonchiffon', '#fffacd'], ['lightblue', '#add8e6'], ['lightcoral', '#f08080'], ['lightcyan', '#e0ffff'], ['lightgoldenrodyellow', '#fafad2'], ['lightgray', '#d3d3d3'], ['lightgreen', '#90ee90'], ['lightgrey', '#d3d3d3'], ['lightpink', '#ffb6c1'], ['lightsalmon', '#ffa07a'], ['lightseagreen', '#20b2aa'], ['lightskyblue', '#87cefa'], ['lightslategray', '#778899'], ['lightslategrey', '#778899'], ['lightsteelblue', '#b0c4de'], ['lightyellow', '#ffffe0'], ['limegreen', '#32cd32'], ['linen', '#faf0e6'], ['magenta', '#ff00ff'], ['mediumaquamarine', '#66cdaa'], ['mediumblue', '#0000cd'], ['mediumorchid', '#ba55d3'], ['mediumpurple', '#9370db'], ['mediumseagreen', '#3cb371'], ['mediumslateblue', '#7b68ee'], ['mediumspringgreen', '#00fa9a'], ['mediumturquoise', '#48d1cc'], ['mediumvioletred', '#c71585'], ['midnightblue', '#191970'], ['mintcream', '#f5fffa'], ['mistyrose', '#ffe4e1'], ['moccasin', '#ffe4b5'], ['navajowhite', '#ffdead'], ['oldlace', '#fdf5e6'], ['olivedrab', '#6b8e23'], ['orange', '#ffa500'], ['orangered', '#ff4500'], ['orchid', '#da70d6'], ['palegoldenrod', '#eee8aa'], ['palegreen', '#98fb98'], ['paleturquoise', '#afeeee'], ['palevioletred', '#db7093'], ['papayawhip', '#ffefd5'], ['peachpuff', '#ffdab9'], ['peru', '#cd853f'], ['pink', '#ffc0cb'], ['plum', '#dda0dd'], ['powderblue', '#b0e0e6'], ['rosybrown', '#bc8f8f'], ['royalblue', '#4169e1'], ['saddlebrown', '#8b4513'], ['salmon', '#fa8072'], ['sandybrown', '#f4a460'], ['seagreen', '#2e8b57'], ['seashell', '#fff5ee'], ['sienna', '#a0522d'], ['skyblue', '#87ceeb'], ['slateblue', '#6a5acd'], ['slategray', '#708090'], ['slategrey', '#708090'], ['snow', '#fffafa'], ['springgreen', '#00ff7f'], ['steelblue', '#4682b4'], ['tan', '#d2b48c'], ['thistle', '#d8bfd8'], ['tomato', '#ff6347'], ['turquoise', '#40e0d0'], ['violet', '#ee82ee'], ['wheat', '#f5deb3'], ['whitesmoke', '#f5f5f5'], ['yellowgreen', '#9acd32']]); exports.default = _default }, {}], 27: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.getRgbValue = getRgbValue; exports.getRgbaValue = getRgbaValue; exports.getOpacity = getOpacity; exports.toRgb = toRgb; exports.toHex = toHex; exports.getColorFromRgbValue = getColorFromRgbValue; exports.darken = darken; exports.lighten = lighten; exports.fade = fade; exports.default = void 0; const _keywords = _interopRequireDefault(require('./config/keywords')); function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { default: obj } } function _toConsumableArray (arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread() } function _nonIterableSpread () { throw new TypeError('Invalid attempt to spread non-iterable instance') } function _iterableToArray (iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === '[object Arguments]') return Array.from(iter) } function _arrayWithoutHoles (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i] } return arr2 } } const hexReg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/; const rgbReg = /^(rgb|rgba|RGB|RGBA)/; const rgbaReg = /^(rgba|RGBA)/; function validator (color) { const isHex = hexReg.test(color); const isRgb = rgbReg.test(color); if (isHex || isRgb) return color; color = getColorByKeyword(color); if (!color) { console.error('Color: Invalid color!'); return false } return color } function getColorByKeyword (keyword) { if (!keyword) { console.error('getColorByKeywords: Missing parameters!'); return false } if (!_keywords.default.has(keyword)) return false; return _keywords.default.get(keyword) } function getRgbValue (color) { if (!color) { console.error('getRgbValue: Missing parameters!'); return false }color = validator(color); if (!color) return false; const isHex = hexReg.test(color); const isRgb = rgbReg.test(color); const lowerColor = color.toLowerCase(); if (isHex) return getRgbValueFromHex(lowerColor); if (isRgb) return getRgbValueFromRgb(lowerColor) } function getRgbValueFromHex (color) { color = color.replace('#', ''); if (color.length === 3)color = Array.from(color).map(function (hexNum) { return hexNum + hexNum }).join(''); color = color.split(''); return new Array(3).fill(0).map(function (t, i) { return parseInt('0x'.concat(color[i * 2]).concat(color[i * 2 + 1])) }) } function getRgbValueFromRgb (color) { return color.replace(/rgb\(|rgba\(|\)/g, '').split(',').slice(0, 3).map(function (n) { return parseInt(n) }) } function getRgbaValue (color) { if (!color) { console.error('getRgbaValue: Missing parameters!'); return false } const colorValue = getRgbValue(color); if (!colorValue) return false; colorValue.push(getOpacity(color)); return colorValue } function getOpacity (color) { if (!color) { console.error('getOpacity: Missing parameters!'); return false }color = validator(color); if (!color) return false; const isRgba = rgbaReg.test(color); if (!isRgba) return 1; color = color.toLowerCase(); return Number(color.split(',').slice(-1)[0].replace(/[)|\s]/g, '')) } function toRgb (color, opacity) { if (!color) { console.error('toRgb: Missing parameters!'); return false } const rgbValue = getRgbValue(color); if (!rgbValue) return false; const addOpacity = typeof opacity === 'number'; if (addOpacity) return 'rgba(' + rgbValue.join(',') + ','.concat(opacity, ')'); return 'rgb(' + rgbValue.join(',') + ')' } function toHex (color) { if (!color) { console.error('toHex: Missing parameters!'); return false } if (hexReg.test(color)) return color; color = getRgbValue(color); if (!color) return false; return '#' + color.map(function (n) { return Number(n).toString(16) }).map(function (n) { return n === '0' ? '00' : n }).join('') } function getColorFromRgbValue (value) { if (!value) { console.error('getColorFromRgbValue: Missing parameters!'); return false } const valueLength = value.length; if (valueLength !== 3 && valueLength !== 4) { console.error('getColorFromRgbValue: Value is illegal!'); return false } let color = valueLength === 3 ? 'rgb(' : 'rgba('; color += value.join(',') + ')'; return color } function darken (color) { const percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; if (!color) { console.error('darken: Missing parameters!'); return false } let rgbaValue = getRgbaValue(color); if (!rgbaValue) return false; rgbaValue = rgbaValue.map(function (v, i) { return i === 3 ? v : v - Math.ceil(2.55 * percent) }).map(function (v) { return v < 0 ? 0 : v }); return getColorFromRgbValue(rgbaValue) } function lighten (color) { const percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; if (!color) { console.error('lighten: Missing parameters!'); return false } let rgbaValue = getRgbaValue(color); if (!rgbaValue) return false; rgbaValue = rgbaValue.map(function (v, i) { return i === 3 ? v : v + Math.ceil(2.55 * percent) }).map(function (v) { return v > 255 ? 255 : v }); return getColorFromRgbValue(rgbaValue) } function fade (color) { const percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100; if (!color) { console.error('fade: Missing parameters!'); return false } const rgbValue = getRgbValue(color); if (!rgbValue) return false; const rgbaValue = [].concat(_toConsumableArray(rgbValue), [percent / 100]); return getColorFromRgbValue(rgbaValue) } const _default = { fade: fade, toHex: toHex, toRgb: toRgb, darken: darken, lighten: lighten, getOpacity: getOpacity, getRgbValue: getRgbValue, getRgbaValue: getRgbaValue, getColorFromRgbValue: getColorFromRgbValue }; exports.default = _default }, { './config/keywords': 26 }], 28: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.default = exports.easeInOutBounce = exports.easeOutBounce = exports.easeInBounce = exports.easeInOutElastic = exports.easeOutElastic = exports.easeInElastic = exports.easeInOutBack = exports.easeOutBack = exports.easeInBack = exports.easeInOutQuint = exports.easeOutQuint = exports.easeInQuint = exports.easeInOutQuart = exports.easeOutQuart = exports.easeInQuart = exports.easeInOutCubic = exports.easeOutCubic = exports.easeInCubic = exports.easeInOutQuad = exports.easeOutQuad = exports.easeInQuad = exports.easeInOutSine = exports.easeOutSine = exports.easeInSine = exports.linear = void 0; const linear = [[[0, 1], '', [0.33, 0.67]], [[1, 0], [0.67, 0.33]]]; exports.linear = linear; const easeInSine = [[[0, 1]], [[0.538, 0.564], [0.169, 0.912], [0.88, 0.196]], [[1, 0]]]; exports.easeInSine = easeInSine; const easeOutSine = [[[0, 1]], [[0.444, 0.448], [0.169, 0.736], [0.718, 0.16]], [[1, 0]]]; exports.easeOutSine = easeOutSine; const easeInOutSine = [[[0, 1]], [[0.5, 0.5], [0.2, 1], [0.8, 0]], [[1, 0]]]; exports.easeInOutSine = easeInOutSine; const easeInQuad = [[[0, 1]], [[0.55, 0.584], [0.231, 0.904], [0.868, 0.264]], [[1, 0]]]; exports.easeInQuad = easeInQuad; const easeOutQuad = [[[0, 1]], [[0.413, 0.428], [0.065, 0.816], [0.76, 0.04]], [[1, 0]]]; exports.easeOutQuad = easeOutQuad; const easeInOutQuad = [[[0, 1]], [[0.5, 0.5], [0.3, 0.9], [0.7, 0.1]], [[1, 0]]]; exports.easeInOutQuad = easeInOutQuad; const easeInCubic = [[[0, 1]], [[0.679, 0.688], [0.366, 0.992], [0.992, 0.384]], [[1, 0]]]; exports.easeInCubic = easeInCubic; const easeOutCubic = [[[0, 1]], [[0.321, 0.312], [0.008, 0.616], [0.634, 0.008]], [[1, 0]]]; exports.easeOutCubic = easeOutCubic; const easeInOutCubic = [[[0, 1]], [[0.5, 0.5], [0.3, 1], [0.7, 0]], [[1, 0]]]; exports.easeInOutCubic = easeInOutCubic; const easeInQuart = [[[0, 1]], [[0.812, 0.74], [0.611, 0.988], [1.013, 0.492]], [[1, 0]]]; exports.easeInQuart = easeInQuart; const easeOutQuart = [[[0, 1]], [[0.152, 0.244], [0.001, 0.448], [0.285, -0.02]], [[1, 0]]]; exports.easeOutQuart = easeOutQuart; const easeInOutQuart = [[[0, 1]], [[0.5, 0.5], [0.4, 1], [0.6, 0]], [[1, 0]]]; exports.easeInOutQuart = easeInOutQuart; const easeInQuint = [[[0, 1]], [[0.857, 0.856], [0.714, 1], [1, 0.712]], [[1, 0]]]; exports.easeInQuint = easeInQuint; const easeOutQuint = [[[0, 1]], [[0.108, 0.2], [0.001, 0.4], [0.214, -0.012]], [[1, 0]]]; exports.easeOutQuint = easeOutQuint; const easeInOutQuint = [[[0, 1]], [[0.5, 0.5], [0.5, 1], [0.5, 0]], [[1, 0]]]; exports.easeInOutQuint = easeInOutQuint; const easeInBack = [[[0, 1]], [[0.667, 0.896], [0.38, 1.184], [0.955, 0.616]], [[1, 0]]]; exports.easeInBack = easeInBack; const easeOutBack = [[[0, 1]], [[0.335, 0.028], [0.061, 0.22], [0.631, -0.18]], [[1, 0]]]; exports.easeOutBack = easeOutBack; const easeInOutBack = [[[0, 1]], [[0.5, 0.5], [0.4, 1.4], [0.6, -0.4]], [[1, 0]]]; exports.easeInOutBack = easeInOutBack; const easeInElastic = [[[0, 1]], [[0.474, 0.964], [0.382, 0.988], [0.557, 0.952]], [[0.619, 1.076], [0.565, 1.088], [0.669, 1.08]], [[0.77, 0.916], [0.712, 0.924], [0.847, 0.904]], [[0.911, 1.304], [0.872, 1.316], [0.961, 1.34]], [[1, 0]]]; exports.easeInElastic = easeInElastic; const easeOutElastic = [[[0, 1]], [[0.073, -0.32], [0.034, -0.328], [0.104, -0.344]], [[0.191, 0.092], [0.11, 0.06], [0.256, 0.08]], [[0.31, -0.076], [0.26, -0.068], [0.357, -0.076]], [[0.432, 0.032], [0.362, 0.028], [0.683, -0.004]], [[1, 0]]]; exports.easeOutElastic = easeOutElastic; const easeInOutElastic = [[[0, 1]], [[0.21, 0.94], [0.167, 0.884], [0.252, 0.98]], [[0.299, 1.104], [0.256, 1.092], [0.347, 1.108]], [[0.5, 0.496], [0.451, 0.672], [0.548, 0.324]], [[0.696, -0.108], [0.652, -0.112], [0.741, -0.124]], [[0.805, 0.064], [0.756, 0.012], [0.866, 0.096]], [[1, 0]]]; exports.easeInOutElastic = easeInOutElastic; const easeInBounce = [[[0, 1]], [[0.148, 1], [0.075, 0.868], [0.193, 0.848]], [[0.326, 1], [0.276, 0.836], [0.405, 0.712]], [[0.6, 1], [0.511, 0.708], [0.671, 0.348]], [[1, 0]]]; exports.easeInBounce = easeInBounce; const easeOutBounce = [[[0, 1]], [[0.357, 0.004], [0.27, 0.592], [0.376, 0.252]], [[0.604, -0.004], [0.548, 0.312], [0.669, 0.184]], [[0.82, 0], [0.749, 0.184], [0.905, 0.132]], [[1, 0]]]; exports.easeOutBounce = easeOutBounce; const easeInOutBounce = [[[0, 1]], [[0.102, 1], [0.05, 0.864], [0.117, 0.86]], [[0.216, 0.996], [0.208, 0.844], [0.227, 0.808]], [[0.347, 0.996], [0.343, 0.8], [0.48, 0.292]], [[0.635, 0.004], [0.511, 0.676], [0.656, 0.208]], [[0.787, 0], [0.76, 0.2], [0.795, 0.144]], [[0.905, -0.004], [0.899, 0.164], [0.944, 0.144]], [[1, 0]]]; exports.easeInOutBounce = easeInOutBounce; const _default = new Map([['linear', linear], ['easeInSine', easeInSine], ['easeOutSine', easeOutSine], ['easeInOutSine', easeInOutSine], ['easeInQuad', easeInQuad], ['easeOutQuad', easeOutQuad], ['easeInOutQuad', easeInOutQuad], ['easeInCubic', easeInCubic], ['easeOutCubic', easeOutCubic], ['easeInOutCubic', easeInOutCubic], ['easeInQuart', easeInQuart], ['easeOutQuart', easeOutQuart], ['easeInOutQuart', easeInOutQuart], ['easeInQuint', easeInQuint], ['easeOutQuint', easeOutQuint], ['easeInOutQuint', easeInOutQuint], ['easeInBack', easeInBack], ['easeOutBack', easeOutBack], ['easeInOutBack', easeInOutBack], ['easeInElastic', easeInElastic], ['easeOutElastic', easeOutElastic], ['easeInOutElastic', easeInOutElastic], ['easeInBounce', easeInBounce], ['easeOutBounce', easeOutBounce], ['easeInOutBounce', easeInOutBounce]]); exports.default = _default }, {}], 29: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.transition = transition; exports.injectNewCurve = injectNewCurve; exports.default = void 0; const _curves = _interopRequireDefault(require('./config/curves')); function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { default: obj } } function _slicedToArray (arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest() } function _nonIterableRest () { throw new TypeError('Invalid attempt to destructure non-iterable instance') } function _iterableToArrayLimit (arr, i) { const _arr = []; let _n = true; let _d = false; let _e; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break } } catch (err) { _d = true; _e = err } finally { try { if (!_n && _i.return != null)_i.return() } finally { if (_d) throw _e } } return _arr } function _arrayWithHoles (arr) { if (Array.isArray(arr)) return arr } function _typeof (obj) { if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') { _typeof = function _typeof (obj) { return typeof obj } } else { _typeof = function _typeof (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj } } return _typeof(obj) } const defaultTransitionBC = 'linear'; function transition (tBC) { const startState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; const endState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null; const frameNum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30; const deep = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; if (!checkParams.apply(void 0, arguments)) return false; try { const bezierCurve = getBezierCurve(tBC); const frameStateProgress = getFrameStateProgress(bezierCurve, frameNum); if (!deep || typeof endState === 'number') return getTransitionState(startState, endState, frameStateProgress); return recursionTransitionState(startState, endState, frameStateProgress) } catch (_unused) { console.warn('Transition parameter may be abnormal!'); return [endState] } } function checkParams (tBC) { const startState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; const endState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const frameNum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30; if (!tBC || startState === false || endState === false || !frameNum) { console.error('transition: Missing Parameters!'); return false } if (_typeof(startState) !== _typeof(endState)) { console.error('transition: Inconsistent Status Types!'); return false } const stateType = _typeof(endState); if (stateType === 'string' || stateType === 'boolean' || !tBC.length) { console.error('transition: Unsupported Data Type of State!'); return false } if (!_curves.default.has(tBC) && !(tBC instanceof Array)) { console.warn('transition: Transition curve not found, default curve will be used!') } return true } function getBezierCurve (tBC) { let bezierCurve = ''; if (_curves.default.has(tBC)) { bezierCurve = _curves.default.get(tBC) } else if (tBC instanceof Array) { bezierCurve = tBC } else { bezierCurve = _curves.default.get(defaultTransitionBC) } return bezierCurve } function getFrameStateProgress (bezierCurve, frameNum) { const tMinus = 1 / (frameNum - 1); const tState = new Array(frameNum).fill(0).map(function (t, i) { return i * tMinus }); const frameState = tState.map(function (t) { return getFrameStateFromT(bezierCurve, t) }); return frameState } function getFrameStateFromT (bezierCurve, t) { const tBezierCurvePoint = getBezierCurvePointFromT(bezierCurve, t); const bezierCurvePointT = getBezierCurvePointTFromReT(tBezierCurvePoint, t); return getBezierCurveTState(tBezierCurvePoint, bezierCurvePointT) } function getBezierCurvePointFromT (bezierCurve, t) { const lastIndex = bezierCurve.length - 1; let begin = ''; let end = ''; bezierCurve.findIndex(function (item, i) { if (i === lastIndex) return; begin = item; end = bezierCurve[i + 1]; const currentMainPointX = begin[0][0]; const nextMainPointX = end[0][0]; return t >= currentMainPointX && t < nextMainPointX }); const p0 = begin[0]; const p1 = begin[2] || begin[0]; const p2 = end[1] || end[0]; const p3 = end[0]; return [p0, p1, p2, p3] } function getBezierCurvePointTFromReT (bezierCurve, t) { const reBeginX = bezierCurve[0][0]; const reEndX = bezierCurve[3][0]; const xMinus = reEndX - reBeginX; const tMinus = t - reBeginX; return tMinus / xMinus } function getBezierCurveTState (_ref, t) { const _ref2 = _slicedToArray(_ref, 4); const _ref2$ = _slicedToArray(_ref2[0], 2); const p0 = _ref2$[1]; const _ref2$2 = _slicedToArray(_ref2[1], 2); const p1 = _ref2$2[1]; const _ref2$3 = _slicedToArray(_ref2[2], 2); const p2 = _ref2$3[1]; const _ref2$4 = _slicedToArray(_ref2[3], 2); const p3 = _ref2$4[1]; const pow = Math.pow; const tMinus = 1 - t; const result1 = p0 * pow(tMinus, 3); const result2 = 3 * p1 * t * pow(tMinus, 2); const result3 = 3 * p2 * pow(t, 2) * tMinus; const result4 = p3 * pow(t, 3); return 1 - (result1 + result2 + result3 + result4) } function getTransitionState (begin, end, frameState) { let stateType = 'object'; if (typeof begin === 'number')stateType = 'number'; if (begin instanceof Array)stateType = 'array'; if (stateType === 'number') return getNumberTransitionState(begin, end, frameState); if (stateType === 'array') return getArrayTransitionState(begin, end, frameState); if (stateType === 'object') return getObjectTransitionState(begin, end, frameState); return frameState.map(function (t) { return end }) } function getNumberTransitionState (begin, end, frameState) { const minus = end - begin; return frameState.map(function (s) { return begin + minus * s }) } function getArrayTransitionState (begin, end, frameState) { const minus = end.map(function (v, i) { if (typeof v !== 'number') return false; return v - begin[i] }); return frameState.map(function (s) { return minus.map(function (v, i) { if (v === false) return end[i]; return begin[i] + v * s }) }) } function getObjectTransitionState (begin, end, frameState) { const keys = Object.keys(end); const beginValue = keys.map(function (k) { return begin[k] }); const endValue = keys.map(function (k) { return end[k] }); const arrayState = getArrayTransitionState(beginValue, endValue, frameState); return arrayState.map(function (item) { const frameData = {}; item.forEach(function (v, i) { return frameData[keys[i]] = v }); return frameData }) } function recursionTransitionState (begin, end, frameState) { const state = getTransitionState(begin, end, frameState); const _loop = function _loop (key) { const bTemp = begin[key]; const eTemp = end[key]; if (_typeof(eTemp) !== 'object') return 'continue'; const data = recursionTransitionState(bTemp, eTemp, frameState); state.forEach(function (fs, i) { return fs[key] = data[i] }) }; for (const key in end) { const _ret = _loop(key); if (_ret === 'continue') continue } return state } function injectNewCurve (key, curve) { if (!key || !curve) { console.error('InjectNewCurve Missing Parameters!'); return }_curves.default.set(key, curve) } const _default = transition; exports.default = _default }, { './config/curves': 28 }], 30: [function (require, module, exports) { const runtime = (function (exports) { 'use strict'; const Op = Object.prototype; const hasOwn = Op.hasOwnProperty; let undefined; const $Symbol = typeof Symbol === 'function' ? Symbol : {}; const iteratorSymbol = $Symbol.iterator || '@@iterator'; const asyncIteratorSymbol = $Symbol.asyncIterator || '@@asyncIterator'; const toStringTagSymbol = $Symbol.toStringTag || '@@toStringTag'; function wrap (innerFn, outerFn, self, tryLocsList) { const protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator; const generator = Object.create(protoGenerator.prototype); const context = new Context(tryLocsList || []); generator._invoke = makeInvokeMethod(innerFn, self, context); return generator }exports.wrap = wrap; function tryCatch (fn, obj, arg) { try { return { type: 'normal', arg: fn.call(obj, arg) } } catch (err) { return { type: 'throw', arg: err } } } const GenStateSuspendedStart = 'suspendedStart'; const GenStateSuspendedYield = 'suspendedYield'; const GenStateExecuting = 'executing'; const GenStateCompleted = 'completed'; const ContinueSentinel = {}; function Generator () {} function GeneratorFunction () {} function GeneratorFunctionPrototype () {} let IteratorPrototype = {}; IteratorPrototype[iteratorSymbol] = function () { return this }; const getProto = Object.getPrototypeOf; const NativeIteratorPrototype = getProto && getProto(getProto(values([]))); if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) { IteratorPrototype = NativeIteratorPrototype } const Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = 'GeneratorFunction'; function defineIteratorMethods (prototype) { ['next', 'throw', 'return'].forEach(function (method) { prototype[method] = function (arg) { return this._invoke(method, arg) } }) }exports.isGeneratorFunction = function (genFun) { const ctor = typeof genFun === 'function' && genFun.constructor; return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === 'GeneratorFunction' : false }; exports.mark = function (genFun) { if (Object.setPrototypeOf) { Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) } else { genFun.__proto__ = GeneratorFunctionPrototype; if (!(toStringTagSymbol in genFun)) { genFun[toStringTagSymbol] = 'GeneratorFunction' } }genFun.prototype = Object.create(Gp); return genFun }; exports.awrap = function (arg) { return { __await: arg } }; function AsyncIterator (generator) { function invoke (method, arg, resolve, reject) { const record = tryCatch(generator[method], generator, arg); if (record.type === 'throw') { reject(record.arg) } else { const result = record.arg; const value = result.value; if (value && typeof value === 'object' && hasOwn.call(value, '__await')) { return Promise.resolve(value.__await).then(function (value) { invoke('next', value, resolve, reject) }, function (err) { invoke('throw', err, resolve, reject) }) } return Promise.resolve(value).then(function (unwrapped) { result.value = unwrapped; resolve(result) }, function (error) { return invoke('throw', error, resolve, reject) }) } } let previousPromise; function enqueue (method, arg) { function callInvokeWithMethodAndArg () { return new Promise(function (resolve, reject) { invoke(method, arg, resolve, reject) }) } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg() } this._invoke = enqueue }defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () { return this }; exports.AsyncIterator = AsyncIterator; exports.async = function (innerFn, outerFn, self, tryLocsList) { const iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList)); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next() }) }; function makeInvokeMethod (innerFn, self, context) { let state = GenStateSuspendedStart; return function invoke (method, arg) { if (state === GenStateExecuting) { throw new Error('Generator is already running') } if (state === GenStateCompleted) { if (method === 'throw') { throw arg } return doneResult() }context.method = method; context.arg = arg; while (true) { const delegate = context.delegate; if (delegate) { const delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult } } if (context.method === 'next') { context.sent = context._sent = context.arg } else if (context.method === 'throw') { if (state === GenStateSuspendedStart) { state = GenStateCompleted; throw context.arg }context.dispatchException(context.arg) } else if (context.method === 'return') { context.abrupt('return', context.arg) }state = GenStateExecuting; const record = tryCatch(innerFn, self, context); if (record.type === 'normal') { state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) { continue } return { value: record.arg, done: context.done } } else if (record.type === 'throw') { state = GenStateCompleted; context.method = 'throw'; context.arg = record.arg } } } } function maybeInvokeDelegate (delegate, context) { const method = delegate.iterator[context.method]; if (method === undefined) { context.delegate = null; if (context.method === 'throw') { if (delegate.iterator.return) { context.method = 'return'; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === 'throw') { return ContinueSentinel } }context.method = 'throw'; context.arg = new TypeError("The iterator does not provide a 'throw' method") } return ContinueSentinel } const record = tryCatch(method, delegate.iterator, context.arg); if (record.type === 'throw') { context.method = 'throw'; context.arg = record.arg; context.delegate = null; return ContinueSentinel } const info = record.arg; if (!info) { context.method = 'throw'; context.arg = new TypeError('iterator result is not an object'); context.delegate = null; return ContinueSentinel } if (info.done) { context[delegate.resultName] = info.value; context.next = delegate.nextLoc; if (context.method !== 'return') { context.method = 'next'; context.arg = undefined } } else { return info }context.delegate = null; return ContinueSentinel }defineIteratorMethods(Gp); Gp[toStringTagSymbol] = 'Generator'; Gp[iteratorSymbol] = function () { return this }; Gp.toString = function () { return '[object Generator]' }; function pushTryEntry (locs) { const entry = { tryLoc: locs[0] }; if (1 in locs) { entry.catchLoc = locs[1] } if (2 in locs) { entry.finallyLoc = locs[2]; entry.afterLoc = locs[3] } this.tryEntries.push(entry) } function resetTryEntry (entry) { const record = entry.completion || {}; record.type = 'normal'; delete record.arg; entry.completion = record } function Context (tryLocsList) { this.tryEntries = [{ tryLoc: 'root' }]; tryLocsList.forEach(pushTryEntry, this); this.reset(true) }exports.keys = function (object) { const keys = []; for (const key in object) { keys.push(key) }keys.reverse(); return function next () { while (keys.length) { const key = keys.pop(); if (key in object) { next.value = key; next.done = false; return next } }next.done = true; return next } }; function values (iterable) { if (iterable) { const iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) { return iteratorMethod.call(iterable) } if (typeof iterable.next === 'function') { return iterable } if (!isNaN(iterable.length)) { let i = -1; const next = function next () { while (++i < iterable.length) { if (hasOwn.call(iterable, i)) { next.value = iterable[i]; next.done = false; return next } }next.value = undefined; next.done = true; return next }; return next.next = next } } return { next: doneResult } }exports.values = values; function doneResult () { return { value: undefined, done: true } }Context.prototype = { constructor: Context, reset: function (skipTempReset) { this.prev = 0; this.next = 0; this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = 'next'; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) { for (const name in this) { if (name.charAt(0) === 't' && hasOwn.call(this, name) && !isNaN(+name.slice(1))) { this[name] = undefined } } } }, stop: function () { this.done = true; const rootEntry = this.tryEntries[0]; const rootRecord = rootEntry.completion; if (rootRecord.type === 'throw') { throw rootRecord.arg } return this.rval }, dispatchException: function (exception) { if (this.done) { throw exception } const context = this; function handle (loc, caught) { record.type = 'throw'; record.arg = exception; context.next = loc; if (caught) { context.method = 'next'; context.arg = undefined } return !!caught } for (let i = this.tryEntries.length - 1; i >= 0; --i) { const entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === 'root') { return handle('end') } if (entry.tryLoc <= this.prev) { const hasCatch = hasOwn.call(entry, 'catchLoc'); const hasFinally = hasOwn.call(entry, 'finallyLoc'); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) { return handle(entry.catchLoc, true) } else if (this.prev < entry.finallyLoc) { return handle(entry.finallyLoc) } } else if (hasCatch) { if (this.prev < entry.catchLoc) { return handle(entry.catchLoc, true) } } else if (hasFinally) { if (this.prev < entry.finallyLoc) { return handle(entry.finallyLoc) } } else { throw new Error('try statement without catch or finally') } } } }, abrupt: function (type, arg) { for (let i = this.tryEntries.length - 1; i >= 0; --i) { const entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, 'finallyLoc') && this.prev < entry.finallyLoc) { var finallyEntry = entry; break } } if (finallyEntry && (type === 'break' || type === 'continue') && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) { finallyEntry = null } const record = finallyEntry ? finallyEntry.completion : {}; record.type = type; record.arg = arg; if (finallyEntry) { this.method = 'next'; this.next = finallyEntry.finallyLoc; return ContinueSentinel } return this.complete(record) }, complete: function (record, afterLoc) { if (record.type === 'throw') { throw record.arg } if (record.type === 'break' || record.type === 'continue') { this.next = record.arg } else if (record.type === 'return') { this.rval = this.arg = record.arg; this.method = 'return'; this.next = 'end' } else if (record.type === 'normal' && afterLoc) { this.next = afterLoc } return ContinueSentinel }, finish: function (finallyLoc) { for (let i = this.tryEntries.length - 1; i >= 0; --i) { const entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) { this.complete(entry.completion, entry.afterLoc); resetTryEntry(entry); return ContinueSentinel } } }, catch: function (tryLoc) { for (let i = this.tryEntries.length - 1; i >= 0; --i) { const entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { const record = entry.completion; if (record.type === 'throw') { var thrown = record.arg; resetTryEntry(entry) } return thrown } } throw new Error('illegal catch attempt') }, delegateYield: function (iterable, resultName, nextLoc) { this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }; if (this.method === 'next') { this.arg = undefined } return ContinueSentinel } }; return exports }(typeof module === 'object' ? module.exports : {})); try { regeneratorRuntime = runtime } catch (accidentalStrictMode) { Function('r', 'regeneratorRuntime = r')(runtime) } }, {}] }, {}, [1])
