(function () { function r (e, n, t) { function o (i, f) { if (!n[i]) { if (!e[i]) { const c = typeof require === 'function' && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); const a = new Error("Cannot find module '" + i + "'"); throw a.code = 'MODULE_NOT_FOUND', a } const p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { const n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = typeof require === 'function' && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({ 1: [function (require, module, exports) { const Charts = require('../lib/index'); window.Charts = Charts }, { '../lib/index': 29 }], 2: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _classCallCheck2 = _interopRequireDefault(require('@babel/runtime/helpers/classCallCheck')); require('../extend/index'); const _cRender = _interopRequireDefault(require('@jiaminghi/c-render')); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _core = require('../core'); const Charts = function Charts (dom) { (0, _classCallCheck2.default)(this, Charts); if (!dom) { console.error('Charts Missing parameters!'); return false } const clientWidth = dom.clientWidth; const clientHeight = dom.clientHeight; const canvas = document.createElement('canvas'); canvas.setAttribute('width', clientWidth); canvas.setAttribute('height', clientHeight); dom.appendChild(canvas); const attribute = { container: dom, canvas: canvas, render: new _cRender.default(canvas), option: null }; Object.assign(this, attribute) }; exports.default = Charts; Charts.prototype.setOption = function (option) { const animationEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; if (!option || (0, _typeof2.default)(option) !== 'object') { console.error('setOption Missing parameters!'); return false } if (animationEnd) this.render.graphs.forEach(function (graph) { return graph.animationEnd() }); const optionCloned = (0, _util.deepClone)(option, true); (0, _core.mergeColor)(this, optionCloned); (0, _core.grid)(this, optionCloned); (0, _core.axis)(this, optionCloned); (0, _core.radarAxis)(this, optionCloned); (0, _core.title)(this, optionCloned); (0, _core.bar)(this, optionCloned); (0, _core.line)(this, optionCloned); (0, _core.pie)(this, optionCloned); (0, _core.radar)(this, optionCloned); (0, _core.gauge)(this, optionCloned); (0, _core.legend)(this, optionCloned); this.option = option; this.render.launchAnimation() }; Charts.prototype.resize = function () { const container = this.container; const canvas = this.canvas; const render = this.render; const option = this.option; const clientWidth = container.clientWidth; const clientHeight = container.clientHeight; canvas.setAttribute('width', clientWidth); canvas.setAttribute('height', clientHeight); render.area = [clientWidth, clientHeight]; this.setOption(option) } }, { '../core': 20, '../extend/index': 28, '@babel/runtime/helpers/classCallCheck': 34, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/typeof': 43, '@jiaminghi/c-render': 52, '@jiaminghi/c-render/lib/plugin/util': 54 }], 3: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.doUpdate = doUpdate; exports.Updater = void 0; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _classCallCheck2 = _interopRequireDefault(require('@babel/runtime/helpers/classCallCheck')); const Updater = function Updater (config, series) { (0, _classCallCheck2.default)(this, Updater); const chart = config.chart; const key = config.key; const getGraphConfig = config.getGraphConfig; if (typeof getGraphConfig !== 'function') { console.warn('Updater need function getGraphConfig!'); return } if (!chart[key]) this.graphs = chart[key] = []; Object.assign(this, config); this.update(series) }; exports.Updater = Updater; Updater.prototype.update = function (series) { const _this = this; const graphs = this.graphs; const beforeUpdate = this.beforeUpdate; delRedundanceGraph(this, series); if (!series.length) return; const beforeUpdateType = (0, _typeof2.default)(beforeUpdate); series.forEach(function (seriesItem, i) { if (beforeUpdateType === 'function')beforeUpdate(graphs, seriesItem, i, _this); const cache = graphs[i]; if (cache) { changeGraphs(cache, seriesItem, i, _this) } else { addGraphs(graphs, seriesItem, i, _this) } }) }; function delRedundanceGraph (updater, series) { const graphs = updater.graphs; const render = updater.chart.render; const cacheGraphNum = graphs.length; const needGraphNum = series.length; if (cacheGraphNum > needGraphNum) { const needDelGraphs = graphs.splice(needGraphNum); needDelGraphs.forEach(function (item) { return item.forEach(function (g) { return render.delGraph(g) }) }) } } function changeGraphs (cache, seriesItem, i, updater) { const getGraphConfig = updater.getGraphConfig; const render = updater.chart.render; const beforeChange = updater.beforeChange; const configs = getGraphConfig(seriesItem, updater); balanceGraphsNum(cache, configs, render); cache.forEach(function (graph, j) { const config = configs[j]; if (typeof beforeChange === 'function')beforeChange(graph, config); updateGraphConfigByKey(graph, config) }) } function balanceGraphsNum (graphs, graphConfig, render) { const cacheGraphNum = graphs.length; const needGraphNum = graphConfig.length; if (needGraphNum > cacheGraphNum) { const lastCacheGraph = graphs.slice(-1)[0]; const needAddGraphNum = needGraphNum - cacheGraphNum; const needAddGraphs = new Array(needAddGraphNum).fill(0).map(function (foo) { return render.clone(lastCacheGraph) }); graphs.push.apply(graphs, (0, _toConsumableArray2.default)(needAddGraphs)) } else if (needGraphNum < cacheGraphNum) { const needDelCache = graphs.splice(needGraphNum); needDelCache.forEach(function (g) { return render.delGraph(g) }) } } function addGraphs (graphs, seriesItem, i, updater) { const getGraphConfig = updater.getGraphConfig; const getStartGraphConfig = updater.getStartGraphConfig; const chart = updater.chart; const render = chart.render; let startConfigs = null; if (typeof getStartGraphConfig === 'function')startConfigs = getStartGraphConfig(seriesItem, updater); const configs = getGraphConfig(seriesItem, updater); if (!configs.length) return; if (startConfigs) { graphs[i] = startConfigs.map(function (config) { return render.add(config) }); graphs[i].forEach(function (graph, i) { const config = configs[i]; updateGraphConfigByKey(graph, config) }) } else { graphs[i] = configs.map(function (config) { return render.add(config) }) } const afterAddGraph = updater.afterAddGraph; if (typeof afterAddGraph === 'function')afterAddGraph(graphs[i]) } function updateGraphConfigByKey (graph, config) { const keys = Object.keys(config); keys.forEach(function (key) { if (key === 'shape' || key === 'style') { graph.animation(key, config[key], true) } else { graph[key] = config[key] } }) } function doUpdate () { const _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; const chart = _ref.chart; const series = _ref.series; const key = _ref.key; const getGraphConfig = _ref.getGraphConfig; const getStartGraphConfig = _ref.getStartGraphConfig; const beforeChange = _ref.beforeChange; const beforeUpdate = _ref.beforeUpdate; const afterAddGraph = _ref.afterAddGraph; if (chart[key]) { chart[key].update(series) } else { chart[key] = new Updater({ chart: chart, key: key, getGraphConfig: getGraphConfig, getStartGraphConfig: getStartGraphConfig, beforeChange: beforeChange, beforeUpdate: beforeUpdate, afterAddGraph: afterAddGraph }, series) } } }, { '@babel/runtime/helpers/classCallCheck': 34, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/toConsumableArray': 42, '@babel/runtime/helpers/typeof': 43 }], 4: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.yAxisConfig = exports.xAxisConfig = void 0; const xAxisConfig = { name: '', show: true, position: 'bottom', nameGap: 15, nameLocation: 'end', nameTextStyle: { fill: '#333', fontSize: 10 }, min: '20%', max: '20%', interval: null, minInterval: null, maxInterval: null, boundaryGap: null, splitNumber: 5, axisLine: { show: true, style: { stroke: '#333', lineWidth: 1 } }, axisTick: { show: true, style: { stroke: '#333', lineWidth: 1 } }, axisLabel: { show: true, formatter: null, style: { fill: '#333', fontSize: 10, rotate: 0 } }, splitLine: { show: false, style: { stroke: '#d4d4d4', lineWidth: 1 } }, rLevel: -20, animationCurve: 'easeOutCubic', animationFrame: 50 }; exports.xAxisConfig = xAxisConfig; const yAxisConfig = { name: '', show: true, position: 'left', nameGap: 15, nameLocation: 'end', nameTextStyle: { fill: '#333', fontSize: 10 }, min: '20%', max: '20%', interval: null, minInterval: null, maxInterval: null, boundaryGap: null, splitNumber: 5, axisLine: { show: true, style: { stroke: '#333', lineWidth: 1 } }, axisTick: { show: true, style: { stroke: '#333', lineWidth: 1 } }, axisLabel: { show: true, formatter: null, style: { fill: '#333', fontSize: 10, rotate: 0 } }, splitLine: { show: true, style: { stroke: '#d4d4d4', lineWidth: 1 } }, rLevel: -20, animationCurve: 'easeOutCubic', animationFrame: 50 }; exports.yAxisConfig = yAxisConfig }, {}], 5: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.barConfig = void 0; const barConfig = { show: true, name: '', stack: '', shapeType: 'normal', echelonOffset: 10, barWidth: 'auto', barGap: '30%', barCategoryGap: '20%', xAxisIndex: 0, yAxisIndex: 0, data: [], backgroundBar: { show: false, width: 'auto', style: { fill: 'rgba(200, 200, 200, .4)' } }, label: { show: false, position: 'top', offset: [0, -10], formatter: null, style: { fontSize: 10 } }, gradient: { color: [], local: true }, barStyle: {}, independentColor: false, independentColors: [], rLevel: 0, animationCurve: 'easeOutCubic', animationFrame: 50 }; exports.barConfig = barConfig }, {}], 6: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.colorConfig = void 0; const colorConfig = ['#37a2da', '#32c5e9', '#67e0e3', '#9fe6b8', '#ffdb5c', '#ff9f7f', '#fb7293', '#e062ae', '#e690d1', '#e7bcf3', '#9d96f5', '#8378ea', '#96bfff']; exports.colorConfig = colorConfig }, {}], 7: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.gaugeConfig = void 0; const gaugeConfig = { show: true, name: '', radius: '60%', center: ['50%', '50%'], startAngle: -(Math.PI / 4) * 5, endAngle: Math.PI / 4, min: 0, max: 100, splitNum: 5, arcLineWidth: 15, data: [], dataItemStyle: {}, axisTick: { show: true, tickLength: 6, style: { stroke: '#999', lineWidth: 1 } }, axisLabel: { show: true, data: [], formatter: null, labelGap: 5, style: {} }, pointer: { show: true, valueIndex: 0, style: { scale: [1, 1], fill: '#fb7293' } }, details: { show: false, formatter: null, offset: [0, 0], valueToFixed: 0, position: 'center', style: { fontSize: 20, fontWeight: 'bold', textAlign: 'center', textBaseline: 'middle' } }, backgroundArc: { show: true, style: { stroke: '#e0e0e0' } }, rLevel: 10, animationCurve: 'easeOutCubic', animationFrame: 50 }; exports.gaugeConfig = gaugeConfig }, {}], 8: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.gridConfig = void 0; const gridConfig = { left: '10%', right: '10%', top: 60, bottom: 60, style: { fill: 'rgba(0, 0, 0, 0)' }, rLevel: -30, animationCurve: 'easeOutCubic', animationFrame: 30 }; exports.gridConfig = gridConfig }, {}], 9: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.changeDefaultConfig = changeDefaultConfig; Object.defineProperty(exports, 'colorConfig', { enumerable: true, get: function get () { return _color.colorConfig } }); Object.defineProperty(exports, 'gridConfig', { enumerable: true, get: function get () { return _grid.gridConfig } }); Object.defineProperty(exports, 'xAxisConfig', { enumerable: true, get: function get () { return _axis.xAxisConfig } }); Object.defineProperty(exports, 'yAxisConfig', { enumerable: true, get: function get () { return _axis.yAxisConfig } }); Object.defineProperty(exports, 'titleConfig', { enumerable: true, get: function get () { return _title.titleConfig } }); Object.defineProperty(exports, 'lineConfig', { enumerable: true, get: function get () { return _line.lineConfig } }); Object.defineProperty(exports, 'barConfig', { enumerable: true, get: function get () { return _bar.barConfig } }); Object.defineProperty(exports, 'pieConfig', { enumerable: true, get: function get () { return _pie.pieConfig } }); Object.defineProperty(exports, 'radarAxisConfig', { enumerable: true, get: function get () { return _radarAxis.radarAxisConfig } }); Object.defineProperty(exports, 'radarConfig', { enumerable: true, get: function get () { return _radar.radarConfig } }); Object.defineProperty(exports, 'gaugeConfig', { enumerable: true, get: function get () { return _gauge.gaugeConfig } }); Object.defineProperty(exports, 'legendConfig', { enumerable: true, get: function get () { return _legend.legendConfig } }); exports.keys = void 0; var _color = require('./color'); var _grid = require('./grid'); var _axis = require('./axis'); var _title = require('./title'); var _line = require('./line'); var _bar = require('./bar'); var _pie = require('./pie'); var _radarAxis = require('./radarAxis'); var _radar = require('./radar'); var _gauge = require('./gauge'); var _legend = require('./legend'); const _util = require('../util'); const allConfig = { colorConfig: _color.colorConfig, gridConfig: _grid.gridConfig, xAxisConfig: _axis.xAxisConfig, yAxisConfig: _axis.yAxisConfig, titleConfig: _title.titleConfig, lineConfig: _line.lineConfig, barConfig: _bar.barConfig, pieConfig: _pie.pieConfig, radarAxisConfig: _radarAxis.radarAxisConfig, radarConfig: _radar.radarConfig, gaugeConfig: _gauge.gaugeConfig, legendConfig: _legend.legendConfig }; function changeDefaultConfig (key, config) { if (!allConfig[''.concat(key, 'Config')]) { console.warn('Change default config Error - Invalid key!'); return }(0, _util.deepMerge)(allConfig[''.concat(key, 'Config')], config) } const keys = ['color', 'title', 'legend', 'xAxis', 'yAxis', 'grid', 'radarAxis', 'line', 'bar', 'pie', 'radar', 'gauge']; exports.keys = keys }, { '../util': 30, './axis': 4, './bar': 5, './color': 6, './gauge': 7, './grid': 8, './legend': 10, './line': 11, './pie': 12, './radar': 13, './radarAxis': 14, './title': 15 }], 10: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.legendConfig = void 0; const legendConfig = { show: true, orient: 'horizontal', left: 'auto', right: 'auto', top: 'auto', bottom: 'auto', itemGap: 10, iconWidth: 25, iconHeight: 10, selectAble: true, data: [], textStyle: { fontFamily: 'Arial', fontSize: 13, fill: '#000' }, iconStyle: {}, textUnselectedStyle: { fontFamily: 'Arial', fontSize: 13, fill: '#999' }, iconUnselectedStyle: { fill: '#999' }, rLevel: 20, animationCurve: 'easeOutCubic', animationFrame: 50 }; exports.legendConfig = legendConfig }, {}], 11: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.lineConfig = void 0; const lineConfig = { show: true, name: '', stack: '', smooth: false, xAxisIndex: 0, yAxisIndex: 0, data: [], lineStyle: { lineWidth: 1 }, linePoint: { show: true, radius: 2, style: { fill: '#fff', lineWidth: 1 } }, lineArea: { show: false, gradient: [], style: { opacity: 0.5 } }, label: { show: false, position: 'top', offset: [0, -10], formatter: null, style: { fontSize: 10 } }, rLevel: 10, animationCurve: 'easeOutCubic', animationFrame: 50 }; exports.lineConfig = lineConfig }, {}], 12: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.pieConfig = void 0; const pieConfig = { show: true, name: '', radius: '50%', center: ['50%', '50%'], startAngle: -Math.PI / 2, roseType: false, roseSort: true, roseIncrement: 'auto', data: [], insideLabel: { show: false, formatter: '{percent}%', style: { fontSize: 10, fill: '#fff', textAlign: 'center', textBaseline: 'middle' } }, outsideLabel: { show: true, formatter: '{name}', style: { fontSize: 11 }, labelLineBendGap: '20%', labelLineEndLength: 50, labelLineStyle: { lineWidth: 1 } }, pieStyle: {}, percentToFixed: 0, rLevel: 10, animationDelayGap: 60, animationCurve: 'easeOutCubic', startAnimationCurve: 'easeOutBack', animationFrame: 50 }; exports.pieConfig = pieConfig }, {}], 13: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.radarConfig = void 0; const radarConfig = { show: true, name: '', data: [], radarStyle: { lineWidth: 1 }, point: { show: true, radius: 2, style: { fill: '#fff' } }, label: { show: true, offset: [0, 0], labelGap: 5, formatter: null, style: { fontSize: 10 } }, rLevel: 10, animationCurve: 'easeOutCubic', animationFrane: 50 }; exports.radarConfig = radarConfig }, {}], 14: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.radarAxisConfig = void 0; const radarAxisConfig = { show: true, center: ['50%', '50%'], radius: '65%', startAngle: -Math.PI / 2, splitNum: 5, polygon: false, axisLabel: { show: true, labelGap: 15, color: [], style: { fill: '#333' } }, axisLine: { show: true, color: [], style: { stroke: '#999', lineWidth: 1 } }, splitLine: { show: true, color: [], style: { stroke: '#d4d4d4', lineWidth: 1 } }, splitArea: { show: false, color: ['#f5f5f5', '#e6e6e6'], style: {} }, rLevel: -10, animationCurve: 'easeOutCubic', animationFrane: 50 }; exports.radarAxisConfig = radarAxisConfig }, {}], 15: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.titleConfig = void 0; const titleConfig = { show: true, text: '', offset: [0, -20], style: { fill: '#333', fontSize: 17, fontWeight: 'bold', textAlign: 'center', textBaseline: 'bottom' }, rLevel: 20, animationCurve: 'easeOutCubic', animationFrame: 50 }; exports.titleConfig = titleConfig }, {}], 16: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.axis = axis; const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _updater = require('../class/updater.class'); const _config = require('../config'); const _util = require('../util'); const _util2 = require('@jiaminghi/c-render/lib/plugin/util'); function ownKeys (object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly)symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread (target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } const axisConfig = { xAxisConfig: _config.xAxisConfig, yAxisConfig: _config.yAxisConfig }; const min = Math.min; const max = Math.max; const abs = Math.abs; const pow = Math.pow; function axis (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; const xAxis = option.xAxis; const yAxis = option.yAxis; const series = option.series; let allAxis = []; if (xAxis && yAxis && series) { allAxis = getAllAxis(xAxis, yAxis); allAxis = mergeDefaultAxisConfig(allAxis); allAxis = allAxis.filter(function (_ref) { const show = _ref.show; return show }); allAxis = mergeDefaultBoundaryGap(allAxis); allAxis = calcAxisLabelData(allAxis, series); allAxis = setAxisPosition(allAxis); allAxis = calcAxisLinePosition(allAxis, chart); allAxis = calcAxisTickPosition(allAxis, chart); allAxis = calcAxisNamePosition(allAxis, chart); allAxis = calcSplitLinePosition(allAxis, chart) }(0, _updater.doUpdate)({ chart: chart, series: allAxis, key: 'axisLine', getGraphConfig: getLineConfig }); (0, _updater.doUpdate)({ chart: chart, series: allAxis, key: 'axisTick', getGraphConfig: getTickConfig }); (0, _updater.doUpdate)({ chart: chart, series: allAxis, key: 'axisLabel', getGraphConfig: getLabelConfig }); (0, _updater.doUpdate)({ chart: chart, series: allAxis, key: 'axisName', getGraphConfig: getNameConfig }); (0, _updater.doUpdate)({ chart: chart, series: allAxis, key: 'splitLine', getGraphConfig: getSplitLineConfig }); chart.axisData = allAxis } function getAllAxis (xAxis, yAxis) { let allXAxis = []; let allYAxis = []; if (xAxis instanceof Array) { let _allXAxis; (_allXAxis = allXAxis).push.apply(_allXAxis, (0, _toConsumableArray2.default)(xAxis)) } else { allXAxis.push(xAxis) } if (yAxis instanceof Array) { let _allYAxis; (_allYAxis = allYAxis).push.apply(_allYAxis, (0, _toConsumableArray2.default)(yAxis)) } else { allYAxis.push(yAxis) }allXAxis.splice(2); allYAxis.splice(2); allXAxis = allXAxis.map(function (axis, i) { return _objectSpread({}, axis, { index: i, axis: 'x' }) }); allYAxis = allYAxis.map(function (axis, i) { return _objectSpread({}, axis, { index: i, axis: 'y' }) }); return [].concat((0, _toConsumableArray2.default)(allXAxis), (0, _toConsumableArray2.default)(allYAxis)) } function mergeDefaultAxisConfig (allAxis) { let xAxis = allAxis.filter(function (_ref2) { const axis = _ref2.axis; return axis === 'x' }); let yAxis = allAxis.filter(function (_ref3) { const axis = _ref3.axis; return axis === 'y' }); xAxis = xAxis.map(function (axis) { return (0, _util.deepMerge)((0, _util2.deepClone)(_config.xAxisConfig), axis) }); yAxis = yAxis.map(function (axis) { return (0, _util.deepMerge)((0, _util2.deepClone)(_config.yAxisConfig), axis) }); return [].concat((0, _toConsumableArray2.default)(xAxis), (0, _toConsumableArray2.default)(yAxis)) } function mergeDefaultBoundaryGap (allAxis) { const valueAxis = allAxis.filter(function (_ref4) { const data = _ref4.data; return data === 'value' }); const labelAxis = allAxis.filter(function (_ref5) { const data = _ref5.data; return data !== 'value' }); valueAxis.forEach(function (axis) { if (typeof axis.boundaryGap === 'boolean') return; axis.boundaryGap = false }); labelAxis.forEach(function (axis) { if (typeof axis.boundaryGap === 'boolean') return; axis.boundaryGap = true }); return [].concat((0, _toConsumableArray2.default)(valueAxis), (0, _toConsumableArray2.default)(labelAxis)) } function calcAxisLabelData (allAxis, series) { let valueAxis = allAxis.filter(function (_ref6) { const data = _ref6.data; return data === 'value' }); let labelAxis = allAxis.filter(function (_ref7) { const data = _ref7.data; return data instanceof Array }); valueAxis = calcValueAxisLabelData(valueAxis, series); labelAxis = calcLabelAxisLabelData(labelAxis); return [].concat((0, _toConsumableArray2.default)(valueAxis), (0, _toConsumableArray2.default)(labelAxis)) } function calcValueAxisLabelData (valueAxis, series) { return valueAxis.map(function (axis) { const minMaxValue = getValueAxisMaxMinValue(axis, series); const _getTrueMinMax = getTrueMinMax(axis, minMaxValue); const _getTrueMinMax2 = (0, _slicedToArray2.default)(_getTrueMinMax, 2); const min = _getTrueMinMax2[0]; const max = _getTrueMinMax2[1]; const interval = getValueInterval(min, max, axis); const formatter = axis.axisLabel.formatter; let label = []; if (minMaxValue[0] === minMaxValue[1]) { label = minMaxValue } else if (min < 0 && max > 0) { label = getValueAxisLabelFromZero(min, max, interval) } else { label = getValueAxisLabelFromMin(min, max, interval) }label = label.map(function (l) { return parseFloat(l.toFixed(2)) }); return _objectSpread({}, axis, { maxValue: label.slice(-1)[0], minValue: label[0], label: getAfterFormatterLabel(label, formatter) }) }) } function getValueAxisMaxMinValue (axis, series) { series = series.filter(function (_ref8) { const show = _ref8.show; const type = _ref8.type; if (show === false) return false; if (type === 'pie') return false; return true }); if (series.length === 0) return [0, 0]; const index = axis.index; const axisType = axis.axis; series = mergeStackData(series); const axisName = axisType + 'Axis'; let valueSeries = series.filter(function (s) { return s[axisName] === index }); if (!valueSeries.length)valueSeries = series; return getSeriesMinMaxValue(valueSeries) } function getSeriesMinMaxValue (series) { if (!series) return; const minValue = Math.min.apply(Math, (0, _toConsumableArray2.default)(series.map(function (_ref9) { const data = _ref9.data; return Math.min.apply(Math, (0, _toConsumableArray2.default)((0, _util.filterNonNumber)(data))) }))); const maxValue = Math.max.apply(Math, (0, _toConsumableArray2.default)(series.map(function (_ref10) { const data = _ref10.data; return Math.max.apply(Math, (0, _toConsumableArray2.default)((0, _util.filterNonNumber)(data))) }))); return [minValue, maxValue] } function mergeStackData (series) { const seriesCloned = (0, _util2.deepClone)(series, true); series.forEach(function (item, i) { const data = (0, _util.mergeSameStackData)(item, series); seriesCloned[i].data = data }); return seriesCloned } function getTrueMinMax (_ref11, _ref12) { let min = _ref11.min; let max = _ref11.max; const axis = _ref11.axis; const _ref13 = (0, _slicedToArray2.default)(_ref12, 2); const minValue = _ref13[0]; const maxValue = _ref13[1]; let minType = (0, _typeof2.default)(min); let maxType = (0, _typeof2.default)(max); if (!testMinMaxType(min)) { min = axisConfig[axis + 'AxisConfig'].min; minType = 'string' } if (!testMinMaxType(max)) { max = axisConfig[axis + 'AxisConfig'].max; maxType = 'string' } if (minType === 'string') { min = parseInt(minValue - abs(minValue * parseFloat(min) / 100)); const lever = getValueLever(min); min = parseFloat((min / lever - 0.1).toFixed(1)) * lever } if (maxType === 'string') { max = parseInt(maxValue + abs(maxValue * parseFloat(max) / 100)); const _lever = getValueLever(max); max = parseFloat((max / _lever + 0.1).toFixed(1)) * _lever } return [min, max] } function getValueLever (value) { const valueString = abs(value).toString(); const valueLength = valueString.length; const firstZeroIndex = valueString.replace(/0*$/g, '').indexOf('0'); let pow10Num = valueLength - 1; if (firstZeroIndex !== -1)pow10Num -= firstZeroIndex; return pow(10, pow10Num) } function testMinMaxType (val) { const valType = (0, _typeof2.default)(val); const isValidString = valType === 'string' && /^\d+%$/.test(val); const isValidNumber = valType === 'number'; return isValidString || isValidNumber } function getValueAxisLabelFromZero (min, max, interval) { const negative = []; const positive = []; let currentNegative = 0; let currentPositive = 0; do { negative.push(currentNegative -= interval) } while (currentNegative > min); do { positive.push(currentPositive += interval) } while (currentPositive < max); return [].concat((0, _toConsumableArray2.default)(negative.reverse()), [0], (0, _toConsumableArray2.default)(positive)) } function getValueAxisLabelFromMin (min, max, interval) { const label = [min]; let currentValue = min; do { label.push(currentValue += interval) } while (currentValue < max); return label } function getAfterFormatterLabel (label, formatter) { if (!formatter) return label; if (typeof formatter === 'string')label = label.map(function (l) { return formatter.replace('{value}', l) }); if (typeof formatter === 'function')label = label.map(function (value, index) { return formatter({ value: value, index: index }) }); return label } function calcLabelAxisLabelData (labelAxis) { return labelAxis.map(function (axis) { const data = axis.data; const formatter = axis.axisLabel.formatter; return _objectSpread({}, axis, { label: getAfterFormatterLabel(data, formatter) }) }) } function getValueInterval (min, max, axis) { let interval = axis.interval; let minInterval = axis.minInterval; let maxInterval = axis.maxInterval; let splitNumber = axis.splitNumber; const axisType = axis.axis; const config = axisConfig[axisType + 'AxisConfig']; if (typeof interval !== 'number')interval = config.interval; if (typeof minInterval !== 'number')minInterval = config.minInterval; if (typeof maxInterval !== 'number')maxInterval = config.maxInterval; if (typeof splitNumber !== 'number')splitNumber = config.splitNumber; if (typeof interval === 'number') return interval; let valueInterval = parseInt((max - min) / (splitNumber - 1)); if (valueInterval.toString().length > 1)valueInterval = parseInt(valueInterval.toString().replace(/\d$/, '0')); if (valueInterval === 0)valueInterval = 1; if (typeof minInterval === 'number' && valueInterval < minInterval) return minInterval; if (typeof maxInterval === 'number' && valueInterval > maxInterval) return maxInterval; return valueInterval } function setAxisPosition (allAxis) { const xAxis = allAxis.filter(function (_ref14) { const axis = _ref14.axis; return axis === 'x' }); const yAxis = allAxis.filter(function (_ref15) { const axis = _ref15.axis; return axis === 'y' }); if (xAxis[0] && !xAxis[0].position)xAxis[0].position = _config.xAxisConfig.position; if (xAxis[1] && !xAxis[1].position) { xAxis[1].position = xAxis[0].position === 'bottom' ? 'top' : 'bottom' } if (yAxis[0] && !yAxis[0].position)yAxis[0].position = _config.yAxisConfig.position; if (yAxis[1] && !yAxis[1].position) { yAxis[1].position = yAxis[0].position === 'left' ? 'right' : 'left' } return [].concat((0, _toConsumableArray2.default)(xAxis), (0, _toConsumableArray2.default)(yAxis)) } function calcAxisLinePosition (allAxis, chart) { const _chart$gridArea = chart.gridArea; const x = _chart$gridArea.x; const y = _chart$gridArea.y; const w = _chart$gridArea.w; const h = _chart$gridArea.h; allAxis = allAxis.map(function (axis) { const position = axis.position; let linePosition = []; if (position === 'left') { linePosition = [[x, y], [x, y + h]].reverse() } else if (position === 'right') { linePosition = [[x + w, y], [x + w, y + h]].reverse() } else if (position === 'top') { linePosition = [[x, y], [x + w, y]] } else if (position === 'bottom') { linePosition = [[x, y + h], [x + w, y + h]] } return _objectSpread({}, axis, { linePosition: linePosition }) }); return allAxis } function calcAxisTickPosition (allAxis, chart) { return allAxis.map(function (axisItem) { const axis = axisItem.axis; const linePosition = axisItem.linePosition; const position = axisItem.position; const label = axisItem.label; let boundaryGap = axisItem.boundaryGap; if (typeof boundaryGap !== 'boolean')boundaryGap = axisConfig[axis + 'AxisConfig'].boundaryGap; const labelNum = label.length; const _linePosition = (0, _slicedToArray2.default)(linePosition, 2); const _linePosition$ = (0, _slicedToArray2.default)(_linePosition[0], 2); const startX = _linePosition$[0]; const startY = _linePosition$[1]; const _linePosition$2 = (0, _slicedToArray2.default)(_linePosition[1], 2); const endX = _linePosition$2[0]; const endY = _linePosition$2[1]; const gapLength = axis === 'x' ? endX - startX : endY - startY; const gap = gapLength / (boundaryGap ? labelNum : labelNum - 1); const tickPosition = new Array(labelNum).fill(0).map(function (foo, i) { if (axis === 'x') { return [startX + gap * (boundaryGap ? i + 0.5 : i), startY] } return [startX, startY + gap * (boundaryGap ? i + 0.5 : i)] }); const tickLinePosition = getTickLinePosition(axis, boundaryGap, position, tickPosition, gap); return _objectSpread({}, axisItem, { tickPosition: tickPosition, tickLinePosition: tickLinePosition, tickGap: gap }) }) } function getTickLinePosition (axisType, boundaryGap, position, tickPosition, gap) { let index = axisType === 'x' ? 1 : 0; let plus = 5; if (axisType === 'x' && position === 'top')plus = -5; if (axisType === 'y' && position === 'left')plus = -5; const tickLinePosition = tickPosition.map(function (lineStart) { const lineEnd = (0, _util2.deepClone)(lineStart); lineEnd[index] += plus; return [(0, _util2.deepClone)(lineStart), lineEnd] }); if (!boundaryGap) return tickLinePosition; index = axisType === 'x' ? 0 : 1; plus = gap / 2; tickLinePosition.forEach(function (_ref16) { const _ref17 = (0, _slicedToArray2.default)(_ref16, 2); const lineStart = _ref17[0]; const lineEnd = _ref17[1]; lineStart[index] += plus; lineEnd[index] += plus }); return tickLinePosition } function calcAxisNamePosition (allAxis, chart) { return allAxis.map(function (axisItem) { const nameGap = axisItem.nameGap; const nameLocation = axisItem.nameLocation; const position = axisItem.position; const linePosition = axisItem.linePosition; const _linePosition2 = (0, _slicedToArray2.default)(linePosition, 2); const lineStart = _linePosition2[0]; const lineEnd = _linePosition2[1]; let namePosition = (0, _toConsumableArray2.default)(lineStart); if (nameLocation === 'end')namePosition = (0, _toConsumableArray2.default)(lineEnd); if (nameLocation === 'center') { namePosition[0] = (lineStart[0] + lineEnd[0]) / 2; namePosition[1] = (lineStart[1] + lineEnd[1]) / 2 } let index = 0; if (position === 'top' && nameLocation === 'center')index = 1; if (position === 'bottom' && nameLocation === 'center')index = 1; if (position === 'left' && nameLocation !== 'center')index = 1; if (position === 'right' && nameLocation !== 'center')index = 1; let plus = nameGap; if (position === 'top' && nameLocation !== 'end')plus *= -1; if (position === 'left' && nameLocation !== 'start')plus *= -1; if (position === 'bottom' && nameLocation === 'start')plus *= -1; if (position === 'right' && nameLocation === 'end')plus *= -1; namePosition[index] += plus; return _objectSpread({}, axisItem, { namePosition: namePosition }) }) } function calcSplitLinePosition (allAxis, chart) { const _chart$gridArea2 = chart.gridArea; const w = _chart$gridArea2.w; const h = _chart$gridArea2.h; return allAxis.map(function (axisItem) { const tickLinePosition = axisItem.tickLinePosition; const position = axisItem.position; const boundaryGap = axisItem.boundaryGap; let index = 0; let plus = w; if (position === 'top' || position === 'bottom')index = 1; if (position === 'top' || position === 'bottom')plus = h; if (position === 'right' || position === 'bottom')plus *= -1; const splitLinePosition = tickLinePosition.map(function (_ref18) { const _ref19 = (0, _slicedToArray2.default)(_ref18, 1); const startPoint = _ref19[0]; const endPoint = (0, _toConsumableArray2.default)(startPoint); endPoint[index] += plus; return [(0, _toConsumableArray2.default)(startPoint), endPoint] }); if (!boundaryGap)splitLinePosition.shift(); return _objectSpread({}, axisItem, { splitLinePosition: splitLinePosition }) }) } function getLineConfig (axisItem) { const animationCurve = axisItem.animationCurve; const animationFrame = axisItem.animationFrame; const rLevel = axisItem.rLevel; return [{ name: 'polyline', index: rLevel, visible: axisItem.axisLine.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getLineShape(axisItem), style: getLineStyle(axisItem) }] } function getLineShape (axisItem) { const linePosition = axisItem.linePosition; return { points: linePosition } } function getLineStyle (axisItem) { return axisItem.axisLine.style } function getTickConfig (axisItem) { const animationCurve = axisItem.animationCurve; const animationFrame = axisItem.animationFrame; const rLevel = axisItem.rLevel; const shapes = getTickShapes(axisItem); const style = getTickStyle(axisItem); return shapes.map(function (shape) { return { name: 'polyline', index: rLevel, visible: axisItem.axisTick.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: shape, style: style } }) } function getTickShapes (axisItem) { const tickLinePosition = axisItem.tickLinePosition; return tickLinePosition.map(function (points) { return { points: points } }) } function getTickStyle (axisItem) { return axisItem.axisTick.style } function getLabelConfig (axisItem) { const animationCurve = axisItem.animationCurve; const animationFrame = axisItem.animationFrame; const rLevel = axisItem.rLevel; const shapes = getLabelShapes(axisItem); const styles = getLabelStyle(axisItem, shapes); return shapes.map(function (shape, i) { return { name: 'text', index: rLevel, visible: axisItem.axisLabel.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: shape, style: styles[i], setGraphCenter: function setGraphCenter () { return void 0 } } }) } function getLabelShapes (axisItem) { const label = axisItem.label; const tickPosition = axisItem.tickPosition; const position = axisItem.position; return tickPosition.map(function (point, i) { return { position: getLabelRealPosition(point, position), content: label[i].toString() } }) } function getLabelRealPosition (points, position) { let index = 0; let plus = 10; if (position === 'top' || position === 'bottom')index = 1; if (position === 'top' || position === 'left')plus = -10; points = (0, _util2.deepClone)(points); points[index] += plus; return points } function getLabelStyle (axisItem, shapes) { const position = axisItem.position; let style = axisItem.axisLabel.style; const align = getAxisLabelRealAlign(position); style = (0, _util.deepMerge)(align, style); const styles = shapes.map(function (_ref20) { const position = _ref20.position; return _objectSpread({}, style, { graphCenter: position }) }); return styles } function getAxisLabelRealAlign (position) { if (position === 'left') return { textAlign: 'right', textBaseline: 'middle' }; if (position === 'right') return { textAlign: 'left', textBaseline: 'middle' }; if (position === 'top') return { textAlign: 'center', textBaseline: 'bottom' }; if (position === 'bottom') return { textAlign: 'center', textBaseline: 'top' } } function getNameConfig (axisItem) { const animationCurve = axisItem.animationCurve; const animationFrame = axisItem.animationFrame; const rLevel = axisItem.rLevel; return [{ name: 'text', index: rLevel, animationCurve: animationCurve, animationFrame: animationFrame, shape: getNameShape(axisItem), style: getNameStyle(axisItem) }] } function getNameShape (axisItem) { const name = axisItem.name; const namePosition = axisItem.namePosition; return { content: name, position: namePosition } } function getNameStyle (axisItem) { const nameLocation = axisItem.nameLocation; const position = axisItem.position; const style = axisItem.nameTextStyle; const align = getNameRealAlign(position, nameLocation); return (0, _util.deepMerge)(align, style) } function getNameRealAlign (position, location) { if (position === 'top' && location === 'start' || position === 'bottom' && location === 'start' || position === 'left' && location === 'center') return { textAlign: 'right', textBaseline: 'middle' }; if (position === 'top' && location === 'end' || position === 'bottom' && location === 'end' || position === 'right' && location === 'center') return { textAlign: 'left', textBaseline: 'middle' }; if (position === 'top' && location === 'center' || position === 'left' && location === 'end' || position === 'right' && location === 'end') return { textAlign: 'center', textBaseline: 'bottom' }; if (position === 'bottom' && location === 'center' || position === 'left' && location === 'start' || position === 'right' && location === 'start') return { textAlign: 'center', textBaseline: 'top' } } function getSplitLineConfig (axisItem) { const animationCurve = axisItem.animationCurve; const animationFrame = axisItem.animationFrame; const rLevel = axisItem.rLevel; const shapes = getSplitLineShapes(axisItem); const style = getSplitLineStyle(axisItem); return shapes.map(function (shape) { return { name: 'polyline', index: rLevel, visible: axisItem.splitLine.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: shape, style: style } }) } function getSplitLineShapes (axisItem) { const splitLinePosition = axisItem.splitLinePosition; return splitLinePosition.map(function (points) { return { points: points } }) } function getSplitLineStyle (axisItem) { return axisItem.splitLine.style } }, { '../class/updater.class': 3, '../config': 9, '../util': 30, '@babel/runtime/helpers/defineProperty': 35, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42, '@babel/runtime/helpers/typeof': 43, '@jiaminghi/c-render/lib/plugin/util': 54 }], 17: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.bar = bar; const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _updater = require('../class/updater.class'); const _config = require('../config'); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _util2 = require('../util'); function ownKeys (object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly)symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread (target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } function bar (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; const xAxis = option.xAxis; const yAxis = option.yAxis; const series = option.series; let bars = []; if (xAxis && yAxis && series) { bars = (0, _util2.initNeedSeries)(series, _config.barConfig, 'bar'); bars = setBarAxis(bars, chart); bars = setBarPositionData(bars, chart); bars = calcBarsPosition(bars, chart) }(0, _updater.doUpdate)({ chart: chart, series: bars.slice(-1), key: 'backgroundBar', getGraphConfig: getBackgroundBarConfig }); bars.reverse(); (0, _updater.doUpdate)({ chart: chart, series: bars, key: 'bar', getGraphConfig: getBarConfig, getStartGraphConfig: getStartBarConfig, beforeUpdate: beforeUpdateBar }); (0, _updater.doUpdate)({ chart: chart, series: bars, key: 'barLabel', getGraphConfig: getLabelConfig }) } function setBarAxis (bars, chart) { const axisData = chart.axisData; bars.forEach(function (bar) { let xAxisIndex = bar.xAxisIndex; let yAxisIndex = bar.yAxisIndex; if (typeof xAxisIndex !== 'number')xAxisIndex = 0; if (typeof yAxisIndex !== 'number')yAxisIndex = 0; const xAxis = axisData.find(function (_ref) { const axis = _ref.axis; const index = _ref.index; return ''.concat(axis).concat(index) === 'x'.concat(xAxisIndex) }); const yAxis = axisData.find(function (_ref2) { const axis = _ref2.axis; const index = _ref2.index; return ''.concat(axis).concat(index) === 'y'.concat(yAxisIndex) }); const axis = [xAxis, yAxis]; const valueAxisIndex = axis.findIndex(function (_ref3) { const data = _ref3.data; return data === 'value' }); bar.valueAxis = axis[valueAxisIndex]; bar.labelAxis = axis[1 - valueAxisIndex] }); return bars } function setBarPositionData (bars, chart) { const labelBarGroup = groupBarByLabelAxis(bars); labelBarGroup.forEach(function (group) { setBarIndex(group); setBarNum(group); setBarCategoryWidth(group, chart); setBarWidthAndGap(group); setBarAllWidthAndGap(group) }); return bars } function setBarIndex (bars) { let stacks = getBarStack(bars); stacks = stacks.map(function (stack) { return { stack: stack, index: -1 } }); let currentIndex = 0; bars.forEach(function (bar) { const stack = bar.stack; if (!stack) { bar.barIndex = currentIndex; currentIndex++ } else { const stackData = stacks.find(function (_ref4) { const s = _ref4.stack; return s === stack }); if (stackData.index === -1) { stackData.index = currentIndex; currentIndex++ }bar.barIndex = stackData.index } }) } function groupBarByLabelAxis (bars) { let labelAxis = bars.map(function (_ref5) { const _ref5$labelAxis = _ref5.labelAxis; const axis = _ref5$labelAxis.axis; const index = _ref5$labelAxis.index; return axis + index }); labelAxis = (0, _toConsumableArray2.default)(new Set(labelAxis)); return labelAxis.map(function (axisIndex) { return bars.filter(function (_ref6) { const _ref6$labelAxis = _ref6.labelAxis; const axis = _ref6$labelAxis.axis; const index = _ref6$labelAxis.index; return axis + index === axisIndex }) }) } function getBarStack (bars) { const stacks = []; bars.forEach(function (_ref7) { const stack = _ref7.stack; if (stack)stacks.push(stack) }); return (0, _toConsumableArray2.default)(new Set(stacks)) } function setBarNum (bars) { const barNum = (0, _toConsumableArray2.default)(new Set(bars.map(function (_ref8) { const barIndex = _ref8.barIndex; return barIndex }))).length; bars.forEach(function (bar) { return bar.barNum = barNum }) } function setBarCategoryWidth (bars) { const lastBar = bars.slice(-1)[0]; const barCategoryGap = lastBar.barCategoryGap; const tickGap = lastBar.labelAxis.tickGap; let barCategoryWidth = 0; if (typeof barCategoryGap === 'number') { barCategoryWidth = barCategoryGap } else { barCategoryWidth = (1 - parseInt(barCategoryGap) / 100) * tickGap }bars.forEach(function (bar) { return bar.barCategoryWidth = barCategoryWidth }) } function setBarWidthAndGap (bars) { const _bars$slice$ = bars.slice(-1)[0]; const barCategoryWidth = _bars$slice$.barCategoryWidth; const barWidth = _bars$slice$.barWidth; const barGap = _bars$slice$.barGap; const barNum = _bars$slice$.barNum; let widthAndGap = []; if (typeof barWidth === 'number' || barWidth !== 'auto') { widthAndGap = getBarWidthAndGapWithPercentOrNumber(barCategoryWidth, barWidth, barGap, barNum) } else if (barWidth === 'auto') { widthAndGap = getBarWidthAndGapWidthAuto(barCategoryWidth, barWidth, barGap, barNum) } const _widthAndGap = widthAndGap; const _widthAndGap2 = (0, _slicedToArray2.default)(_widthAndGap, 2); const width = _widthAndGap2[0]; const gap = _widthAndGap2[1]; bars.forEach(function (bar) { bar.barWidth = width; bar.barGap = gap }) } function getBarWidthAndGapWithPercentOrNumber (barCategoryWidth, barWidth, barGap) { let width = 0; let gap = 0; if (typeof barWidth === 'number') { width = barWidth } else { width = parseInt(barWidth) / 100 * barCategoryWidth } if (typeof barGap === 'number') { gap = barGap } else { gap = parseInt(barGap) / 100 * width } return [width, gap] } function getBarWidthAndGapWidthAuto (barCategoryWidth, barWidth, barGap, barNum) { let width = 0; let gap = 0; const barItemWidth = barCategoryWidth / barNum; if (typeof barGap === 'number') { gap = barGap; width = barItemWidth - gap } else { const percent = 10 + parseInt(barGap) / 10; if (percent === 0) { width = barItemWidth * 2; gap = -width } else { width = barItemWidth / percent * 10; gap = barItemWidth - width } } return [width, gap] } function setBarAllWidthAndGap (bars) { const _bars$slice$2 = bars.slice(-1)[0]; const barGap = _bars$slice$2.barGap; const barWidth = _bars$slice$2.barWidth; const barNum = _bars$slice$2.barNum; const barAllWidthAndGap = (barGap + barWidth) * barNum - barGap; bars.forEach(function (bar) { return bar.barAllWidthAndGap = barAllWidthAndGap }) } function calcBarsPosition (bars, chart) { bars = calcBarValueAxisCoordinate(bars); bars = calcBarLabelAxisCoordinate(bars); bars = eliminateNullBarLabelAxis(bars); bars = keepSameNumBetweenBarAndData(bars); return bars } function calcBarLabelAxisCoordinate (bars) { return bars.map(function (bar) { const labelAxis = bar.labelAxis; const barAllWidthAndGap = bar.barAllWidthAndGap; const barGap = bar.barGap; const barWidth = bar.barWidth; const barIndex = bar.barIndex; const tickGap = labelAxis.tickGap; const tickPosition = labelAxis.tickPosition; const axis = labelAxis.axis; const coordinateIndex = axis === 'x' ? 0 : 1; const barLabelAxisPos = tickPosition.map(function (tick, i) { const barCategoryStartPos = tickPosition[i][coordinateIndex] - tickGap / 2; const barItemsStartPos = barCategoryStartPos + (tickGap - barAllWidthAndGap) / 2; return barItemsStartPos + (barIndex + 0.5) * barWidth + barIndex * barGap }); return _objectSpread({}, bar, { barLabelAxisPos: barLabelAxisPos }) }) } function calcBarValueAxisCoordinate (bars) { return bars.map(function (bar) { let data = (0, _util2.mergeSameStackData)(bar, bars); data = eliminateNonNumberData(bar, data); const _bar$valueAxis = bar.valueAxis; const axis = _bar$valueAxis.axis; const minValue = _bar$valueAxis.minValue; const maxValue = _bar$valueAxis.maxValue; const linePosition = _bar$valueAxis.linePosition; const startPos = getValuePos(minValue, maxValue, minValue < 0 ? 0 : minValue, linePosition, axis); const endPos = data.map(function (v) { return getValuePos(minValue, maxValue, v, linePosition, axis) }); const barValueAxisPos = endPos.map(function (p) { return [startPos, p] }); return _objectSpread({}, bar, { barValueAxisPos: barValueAxisPos }) }) } function eliminateNonNumberData (barItem, barData) { const data = barItem.data; return barData.map(function (v, i) { return typeof data[i] === 'number' ? v : null }).filter(function (d) { return d !== null }) } function eliminateNullBarLabelAxis (bars) { return bars.map(function (bar) { const barLabelAxisPos = bar.barLabelAxisPos; const data = bar.data; data.forEach(function (d, i) { if (typeof d === 'number') return; barLabelAxisPos[i] = null }); return _objectSpread({}, bar, { barLabelAxisPos: barLabelAxisPos.filter(function (p) { return p !== null }) }) }) } function keepSameNumBetweenBarAndData (bars) { bars.forEach(function (bar) { const data = bar.data; const barLabelAxisPos = bar.barLabelAxisPos; const barValueAxisPos = bar.barValueAxisPos; const dataNum = data.filter(function (d) { return typeof d === 'number' }).length; const axisPosNum = barLabelAxisPos.length; if (axisPosNum > dataNum) { barLabelAxisPos.splice(dataNum); barValueAxisPos.splice(dataNum) } }); return bars } function getValuePos (min, max, value, linePosition, axis) { if (typeof value !== 'number') return null; const valueMinus = max - min; const coordinateIndex = axis === 'x' ? 0 : 1; const posMinus = linePosition[1][coordinateIndex] - linePosition[0][coordinateIndex]; let percent = (value - min) / valueMinus; if (valueMinus === 0)percent = 0; const pos = percent * posMinus; return pos + linePosition[0][coordinateIndex] } function getBackgroundBarConfig (barItem) { const animationCurve = barItem.animationCurve; const animationFrame = barItem.animationFrame; const rLevel = barItem.rLevel; const shapes = getBackgroundBarShapes(barItem); const style = getBackgroundBarStyle(barItem); return shapes.map(function (shape) { return { name: 'rect', index: rLevel, visible: barItem.backgroundBar.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: shape, style: style } }) } function getBackgroundBarShapes (barItem) { const labelAxis = barItem.labelAxis; const valueAxis = barItem.valueAxis; const tickPosition = labelAxis.tickPosition; const axis = valueAxis.axis; const linePosition = valueAxis.linePosition; const width = getBackgroundBarWidth(barItem); const haltWidth = width / 2; const posIndex = axis === 'x' ? 0 : 1; const centerPos = tickPosition.map(function (p) { return p[1 - posIndex] }); const _ref9 = [linePosition[0][posIndex], linePosition[1][posIndex]]; const start = _ref9[0]; const end = _ref9[1]; return centerPos.map(function (center) { if (axis === 'x') { return { x: start, y: center - haltWidth, w: end - start, h: width } } else { return { x: center - haltWidth, y: end, w: width, h: start - end } } }) } function getBackgroundBarWidth (barItem) { const barAllWidthAndGap = barItem.barAllWidthAndGap; const barCategoryWidth = barItem.barCategoryWidth; const backgroundBar = barItem.backgroundBar; const width = backgroundBar.width; if (typeof width === 'number') return width; if (width === 'auto') return barAllWidthAndGap; return parseInt(width) / 100 * barCategoryWidth } function getBackgroundBarStyle (barItem) { return barItem.backgroundBar.style } function getBarConfig (barItem) { const barLabelAxisPos = barItem.barLabelAxisPos; const animationCurve = barItem.animationCurve; const animationFrame = barItem.animationFrame; const rLevel = barItem.rLevel; const name = getBarName(barItem); return barLabelAxisPos.map(function (foo, i) { return { name: name, index: rLevel, animationCurve: animationCurve, animationFrame: animationFrame, shape: getBarShape(barItem, i), style: getBarStyle(barItem, i) } }) } function getBarName (barItem) { const shapeType = barItem.shapeType; if (shapeType === 'leftEchelon' || shapeType === 'rightEchelon') return 'polyline'; return 'rect' } function getBarShape (barItem, i) { const shapeType = barItem.shapeType; if (shapeType === 'leftEchelon') { return getLeftEchelonShape(barItem, i) } else if (shapeType === 'rightEchelon') { return getRightEchelonShape(barItem, i) } else { return getNormalBarShape(barItem, i) } } function getLeftEchelonShape (barItem, i) { const barValueAxisPos = barItem.barValueAxisPos; const barLabelAxisPos = barItem.barLabelAxisPos; const barWidth = barItem.barWidth; const echelonOffset = barItem.echelonOffset; const _barValueAxisPos$i = (0, _slicedToArray2.default)(barValueAxisPos[i], 2); const start = _barValueAxisPos$i[0]; const end = _barValueAxisPos$i[1]; const labelAxisPos = barLabelAxisPos[i]; const halfWidth = barWidth / 2; const valueAxis = barItem.valueAxis.axis; const points = []; if (valueAxis === 'x') { points[0] = [end, labelAxisPos - halfWidth]; points[1] = [end, labelAxisPos + halfWidth]; points[2] = [start, labelAxisPos + halfWidth]; points[3] = [start + echelonOffset, labelAxisPos - halfWidth]; if (end - start < echelonOffset)points.splice(3, 1) } else { points[0] = [labelAxisPos - halfWidth, end]; points[1] = [labelAxisPos + halfWidth, end]; points[2] = [labelAxisPos + halfWidth, start]; points[3] = [labelAxisPos - halfWidth, start - echelonOffset]; if (start - end < echelonOffset)points.splice(3, 1) } return { points: points, close: true } } function getRightEchelonShape (barItem, i) { const barValueAxisPos = barItem.barValueAxisPos; const barLabelAxisPos = barItem.barLabelAxisPos; const barWidth = barItem.barWidth; const echelonOffset = barItem.echelonOffset; const _barValueAxisPos$i2 = (0, _slicedToArray2.default)(barValueAxisPos[i], 2); const start = _barValueAxisPos$i2[0]; const end = _barValueAxisPos$i2[1]; const labelAxisPos = barLabelAxisPos[i]; const halfWidth = barWidth / 2; const valueAxis = barItem.valueAxis.axis; const points = []; if (valueAxis === 'x') { points[0] = [end, labelAxisPos + halfWidth]; points[1] = [end, labelAxisPos - halfWidth]; points[2] = [start, labelAxisPos - halfWidth]; points[3] = [start + echelonOffset, labelAxisPos + halfWidth]; if (end - start < echelonOffset)points.splice(2, 1) } else { points[0] = [labelAxisPos + halfWidth, end]; points[1] = [labelAxisPos - halfWidth, end]; points[2] = [labelAxisPos - halfWidth, start]; points[3] = [labelAxisPos + halfWidth, start - echelonOffset]; if (start - end < echelonOffset)points.splice(2, 1) } return { points: points, close: true } } function getNormalBarShape (barItem, i) { const barValueAxisPos = barItem.barValueAxisPos; const barLabelAxisPos = barItem.barLabelAxisPos; const barWidth = barItem.barWidth; const _barValueAxisPos$i3 = (0, _slicedToArray2.default)(barValueAxisPos[i], 2); const start = _barValueAxisPos$i3[0]; const end = _barValueAxisPos$i3[1]; const labelAxisPos = barLabelAxisPos[i]; const valueAxis = barItem.valueAxis.axis; const shape = {}; if (valueAxis === 'x') { shape.x = start; shape.y = labelAxisPos - barWidth / 2; shape.w = end - start; shape.h = barWidth } else { shape.x = labelAxisPos - barWidth / 2; shape.y = end; shape.w = barWidth; shape.h = start - end } return shape } function getBarStyle (barItem, i) { const barStyle = barItem.barStyle; const gradient = barItem.gradient; const color = barItem.color; const independentColor = barItem.independentColor; const independentColors = barItem.independentColors; const fillColor = [barStyle.fill || color]; let gradientColor = (0, _util2.deepMerge)(fillColor, gradient.color); if (independentColor) { const idtColor = independentColors[i % independentColors.length]; gradientColor = idtColor instanceof Array ? idtColor : [idtColor] } if (gradientColor.length === 1)gradientColor.push(gradientColor[0]); const gradientParams = getGradientParams(barItem, i); return (0, _util2.deepMerge)({ gradientColor: gradientColor, gradientParams: gradientParams, gradientType: 'linear', gradientWith: 'fill' }, barStyle) } function getGradientParams (barItem, i) { const barValueAxisPos = barItem.barValueAxisPos; const barLabelAxisPos = barItem.barLabelAxisPos; const data = barItem.data; const _barItem$valueAxis = barItem.valueAxis; const linePosition = _barItem$valueAxis.linePosition; const axis = _barItem$valueAxis.axis; const _barValueAxisPos$i4 = (0, _slicedToArray2.default)(barValueAxisPos[i], 2); const start = _barValueAxisPos$i4[0]; const end = _barValueAxisPos$i4[1]; const labelAxisPos = barLabelAxisPos[i]; const value = data[i]; const _linePosition = (0, _slicedToArray2.default)(linePosition, 2); const lineStart = _linePosition[0]; const lineEnd = _linePosition[1]; const valueAxisIndex = axis === 'x' ? 0 : 1; let endPos = end; if (!barItem.gradient.local) { endPos = value < 0 ? lineStart[valueAxisIndex] : lineEnd[valueAxisIndex] } if (axis === 'y') { return [labelAxisPos, endPos, labelAxisPos, start] } else { return [endPos, labelAxisPos, start, labelAxisPos] } } function getStartBarConfig (barItem) { const configs = getBarConfig(barItem); const shapeType = barItem.shapeType; configs.forEach(function (config) { let shape = config.shape; if (shapeType === 'leftEchelon') { shape = getStartLeftEchelonShape(shape, barItem) } else if (shapeType === 'rightEchelon') { shape = getStartRightEchelonShape(shape, barItem) } else { shape = getStartNormalBarShape(shape, barItem) }config.shape = shape }); return configs } function getStartLeftEchelonShape (shape, barItem) { const axis = barItem.valueAxis.axis; shape = (0, _util.deepClone)(shape); const _shape = shape; const points = _shape.points; const index = axis === 'x' ? 0 : 1; const start = points[2][index]; points.forEach(function (point) { return point[index] = start }); return shape } function getStartRightEchelonShape (shape, barItem) { const axis = barItem.valueAxis.axis; shape = (0, _util.deepClone)(shape); const _shape2 = shape; const points = _shape2.points; const index = axis === 'x' ? 0 : 1; const start = points[2][index]; points.forEach(function (point) { return point[index] = start }); return shape } function getStartNormalBarShape (shape, barItem) { const axis = barItem.valueAxis.axis; const x = shape.x; let y = shape.y; let w = shape.w; let h = shape.h; if (axis === 'x') { w = 0 } else { y = y + h; h = 0 } return { x: x, y: y, w: w, h: h } } function beforeUpdateBar (graphs, barItem, i, updater) { const render = updater.chart.render; const name = getBarName(barItem); if (graphs[i] && graphs[i][0].name !== name) { graphs[i].forEach(function (g) { return render.delGraph(g) }); graphs[i] = null } } function getLabelConfig (barItem) { const animationCurve = barItem.animationCurve; const animationFrame = barItem.animationFrame; const rLevel = barItem.rLevel; const shapes = getLabelShapes(barItem); const style = getLabelStyle(barItem); return shapes.map(function (shape) { return { name: 'text', index: rLevel, visible: barItem.label.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: shape, style: style } }) } function getLabelShapes (barItem) { const contents = getFormatterLabels(barItem); const position = getLabelsPosition(barItem); return position.map(function (pos, i) { return { position: pos, content: contents[i] } }) } function getFormatterLabels (barItem) { let data = barItem.data; const label = barItem.label; const formatter = label.formatter; data = data.filter(function (d) { return typeof d === 'number' }).map(function (d) { return d.toString() }); if (!formatter) return data; const type = (0, _typeof2.default)(formatter); if (type === 'string') return data.map(function (d) { return formatter.replace('{value}', d) }); if (type === 'function') return data.map(function (d, i) { return formatter({ value: d, index: i }) }); return data } function getLabelsPosition (barItem) { const label = barItem.label; const barValueAxisPos = barItem.barValueAxisPos; const barLabelAxisPos = barItem.barLabelAxisPos; const position = label.position; const offset = label.offset; const axis = barItem.valueAxis.axis; return barValueAxisPos.map(function (_ref10, i) { const _ref11 = (0, _slicedToArray2.default)(_ref10, 2); const start = _ref11[0]; const end = _ref11[1]; const labelAxisPos = barLabelAxisPos[i]; let pos = [end, labelAxisPos]; if (position === 'bottom') { pos = [start, labelAxisPos] } if (position === 'center') { pos = [(start + end) / 2, labelAxisPos] } if (axis === 'y')pos.reverse(); return getOffsetedPoint(pos, offset) }) } function getOffsetedPoint (_ref12, _ref13) { const _ref14 = (0, _slicedToArray2.default)(_ref12, 2); const x = _ref14[0]; const y = _ref14[1]; const _ref15 = (0, _slicedToArray2.default)(_ref13, 2); const ox = _ref15[0]; const oy = _ref15[1]; return [x + ox, y + oy] } function getLabelStyle (barItem) { let color = barItem.color; let style = barItem.label.style; const gc = barItem.gradient.color; if (gc.length)color = gc[0]; style = (0, _util2.deepMerge)({ fill: color }, style); return style } }, { '../class/updater.class': 3, '../config': 9, '../util': 30, '@babel/runtime/helpers/defineProperty': 35, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42, '@babel/runtime/helpers/typeof': 43, '@jiaminghi/c-render/lib/plugin/util': 54 }], 18: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.gauge = gauge; const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _updater = require('../class/updater.class'); const _gauge = require('../config/gauge'); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _util2 = require('../util'); const _color = require('@jiaminghi/color'); function ownKeys (object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly)symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread (target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } function gauge (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; let series = option.series; if (!series)series = []; let gauges = (0, _util2.initNeedSeries)(series, _gauge.gaugeConfig, 'gauge'); gauges = calcGaugesCenter(gauges, chart); gauges = calcGaugesRadius(gauges, chart); gauges = calcGaugesDataRadiusAndLineWidth(gauges, chart); gauges = calcGaugesDataAngles(gauges, chart); gauges = calcGaugesDataGradient(gauges, chart); gauges = calcGaugesAxisTickPosition(gauges, chart); gauges = calcGaugesLabelPositionAndAlign(gauges, chart); gauges = calcGaugesLabelData(gauges, chart); gauges = calcGaugesDetailsPosition(gauges, chart); gauges = calcGaugesDetailsContent(gauges, chart); (0, _updater.doUpdate)({ chart: chart, series: gauges, key: 'gaugeAxisTick', getGraphConfig: getAxisTickConfig }); (0, _updater.doUpdate)({ chart: chart, series: gauges, key: 'gaugeAxisLabel', getGraphConfig: getAxisLabelConfig }); (0, _updater.doUpdate)({ chart: chart, series: gauges, key: 'gaugeBackgroundArc', getGraphConfig: getBackgroundArcConfig, getStartGraphConfig: getStartBackgroundArcConfig }); (0, _updater.doUpdate)({ chart: chart, series: gauges, key: 'gaugeArc', getGraphConfig: getArcConfig, getStartGraphConfig: getStartArcConfig, beforeChange: beforeChangeArc }); (0, _updater.doUpdate)({ chart: chart, series: gauges, key: 'gaugePointer', getGraphConfig: getPointerConfig, getStartGraphConfig: getStartPointerConfig }); (0, _updater.doUpdate)({ chart: chart, series: gauges, key: 'gaugeDetails', getGraphConfig: getDetailsConfig }) } function calcGaugesCenter (gauges, chart) { const area = chart.render.area; gauges.forEach(function (gaugeItem) { let center = gaugeItem.center; center = center.map(function (pos, i) { if (typeof pos === 'number') return pos; return parseInt(pos) / 100 * area[i] }); gaugeItem.center = center }); return gauges } function calcGaugesRadius (gauges, chart) { const area = chart.render.area; const maxRadius = Math.min.apply(Math, (0, _toConsumableArray2.default)(area)) / 2; gauges.forEach(function (gaugeItem) { let radius = gaugeItem.radius; if (typeof radius !== 'number') { radius = parseInt(radius) / 100 * maxRadius }gaugeItem.radius = radius }); return gauges } function calcGaugesDataRadiusAndLineWidth (gauges, chart) { const area = chart.render.area; const maxRadius = Math.min.apply(Math, (0, _toConsumableArray2.default)(area)) / 2; gauges.forEach(function (gaugeItem) { const radius = gaugeItem.radius; const data = gaugeItem.data; const arcLineWidth = gaugeItem.arcLineWidth; data.forEach(function (item) { let arcRadius = item.radius; let lineWidth = item.lineWidth; if (!arcRadius)arcRadius = radius; if (typeof arcRadius !== 'number')arcRadius = parseInt(arcRadius) / 100 * maxRadius; item.radius = arcRadius; if (!lineWidth)lineWidth = arcLineWidth; item.lineWidth = lineWidth }) }); return gauges } function calcGaugesDataAngles (gauges, chart) { gauges.forEach(function (gaugeItem) { const startAngle = gaugeItem.startAngle; const endAngle = gaugeItem.endAngle; const data = gaugeItem.data; const min = gaugeItem.min; const max = gaugeItem.max; const angleMinus = endAngle - startAngle; const valueMinus = max - min; data.forEach(function (item) { const value = item.value; const itemAngle = Math.abs((value - min) / valueMinus * angleMinus); item.startAngle = startAngle; item.endAngle = startAngle + itemAngle }) }); return gauges } function calcGaugesDataGradient (gauges, chart) { gauges.forEach(function (gaugeItem) { const data = gaugeItem.data; data.forEach(function (item) { const color = item.color; let gradient = item.gradient; if (!gradient || !gradient.length)gradient = color; if (!(gradient instanceof Array))gradient = [gradient]; item.gradient = gradient }) }); return gauges } function calcGaugesAxisTickPosition (gauges, chart) { gauges.forEach(function (gaugeItem) { const startAngle = gaugeItem.startAngle; const endAngle = gaugeItem.endAngle; const splitNum = gaugeItem.splitNum; const center = gaugeItem.center; const radius = gaugeItem.radius; const arcLineWidth = gaugeItem.arcLineWidth; const axisTick = gaugeItem.axisTick; const tickLength = axisTick.tickLength; const lineWidth = axisTick.style.lineWidth; const angles = endAngle - startAngle; const outerRadius = radius - arcLineWidth / 2; const innerRadius = outerRadius - tickLength; const angleGap = angles / (splitNum - 1); const arcLength = 2 * Math.PI * radius * angles / (Math.PI * 2); const offset = Math.ceil(lineWidth / 2) / arcLength * angles; gaugeItem.tickAngles = []; gaugeItem.tickInnerRadius = []; gaugeItem.tickPosition = new Array(splitNum).fill(0).map(function (foo, i) { let angle = startAngle + angleGap * i; if (i === 0)angle += offset; if (i === splitNum - 1)angle -= offset; gaugeItem.tickAngles[i] = angle; gaugeItem.tickInnerRadius[i] = innerRadius; return [_util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(center).concat([outerRadius, angle])), _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(center).concat([innerRadius, angle]))] }) }); return gauges } function calcGaugesLabelPositionAndAlign (gauges, chart) { gauges.forEach(function (gaugeItem) { const center = gaugeItem.center; const tickInnerRadius = gaugeItem.tickInnerRadius; const tickAngles = gaugeItem.tickAngles; const labelGap = gaugeItem.axisLabel.labelGap; const position = tickAngles.map(function (angle, i) { return _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(center).concat([tickInnerRadius[i] - labelGap, tickAngles[i]])) }); const align = position.map(function (_ref) { const _ref2 = (0, _slicedToArray2.default)(_ref, 2); const x = _ref2[0]; const y = _ref2[1]; return { textAlign: x > center[0] ? 'right' : 'left', textBaseline: y > center[1] ? 'bottom' : 'top' } }); gaugeItem.labelPosition = position; gaugeItem.labelAlign = align }); return gauges } function calcGaugesLabelData (gauges, chart) { gauges.forEach(function (gaugeItem) { const axisLabel = gaugeItem.axisLabel; const min = gaugeItem.min; const max = gaugeItem.max; const splitNum = gaugeItem.splitNum; let data = axisLabel.data; const formatter = axisLabel.formatter; const valueGap = (max - min) / (splitNum - 1); const value = new Array(splitNum).fill(0).map(function (foo, i) { return parseInt(min + valueGap * i) }); const formatterType = (0, _typeof2.default)(formatter); data = (0, _util2.deepMerge)(value, data).map(function (v, i) { let label = v; if (formatterType === 'string') { label = formatter.replace('{value}', v) } if (formatterType === 'function') { label = formatter({ value: v, index: i }) } return label }); axisLabel.data = data }); return gauges } function calcGaugesDetailsPosition (gauges, chart) { gauges.forEach(function (gaugeItem) { const data = gaugeItem.data; const details = gaugeItem.details; const center = gaugeItem.center; const position = details.position; const offset = details.offset; const detailsPosition = data.map(function (_ref3) { const startAngle = _ref3.startAngle; const endAngle = _ref3.endAngle; const radius = _ref3.radius; let point = null; if (position === 'center') { point = center } else if (position === 'start') { point = _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(center).concat([radius, startAngle])) } else if (position === 'end') { point = _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(center).concat([radius, endAngle])) } return getOffsetedPoint(point, offset) }); gaugeItem.detailsPosition = detailsPosition }); return gauges } function calcGaugesDetailsContent (gauges, chart) { gauges.forEach(function (gaugeItem) { const data = gaugeItem.data; const details = gaugeItem.details; const formatter = details.formatter; const formatterType = (0, _typeof2.default)(formatter); const contents = data.map(function (dataItem) { let content = dataItem.value; if (formatterType === 'string') { content = formatter.replace('{value}', '{nt}'); content = content.replace('{name}', dataItem.name) } if (formatterType === 'function')content = formatter(dataItem); return content.toString() }); gaugeItem.detailsContent = contents }); return gauges } function getOffsetedPoint (_ref4, _ref5) { const _ref6 = (0, _slicedToArray2.default)(_ref4, 2); const x = _ref6[0]; const y = _ref6[1]; const _ref7 = (0, _slicedToArray2.default)(_ref5, 2); const ox = _ref7[0]; const oy = _ref7[1]; return [x + ox, y + oy] } function getAxisTickConfig (gaugeItem) { const tickPosition = gaugeItem.tickPosition; const animationCurve = gaugeItem.animationCurve; const animationFrame = gaugeItem.animationFrame; const rLevel = gaugeItem.rLevel; return tickPosition.map(function (foo, i) { return { name: 'polyline', index: rLevel, visible: gaugeItem.axisTick.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getAxisTickShape(gaugeItem, i), style: getAxisTickStyle(gaugeItem, i) } }) } function getAxisTickShape (gaugeItem, i) { const tickPosition = gaugeItem.tickPosition; return { points: tickPosition[i] } } function getAxisTickStyle (gaugeItem, i) { const style = gaugeItem.axisTick.style; return style } function getAxisLabelConfig (gaugeItem) { const labelPosition = gaugeItem.labelPosition; const animationCurve = gaugeItem.animationCurve; const animationFrame = gaugeItem.animationFrame; const rLevel = gaugeItem.rLevel; return labelPosition.map(function (foo, i) { return { name: 'text', index: rLevel, visible: gaugeItem.axisLabel.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getAxisLabelShape(gaugeItem, i), style: getAxisLabelStyle(gaugeItem, i) } }) } function getAxisLabelShape (gaugeItem, i) { const labelPosition = gaugeItem.labelPosition; const data = gaugeItem.axisLabel.data; return { content: data[i].toString(), position: labelPosition[i] } } function getAxisLabelStyle (gaugeItem, i) { const labelAlign = gaugeItem.labelAlign; const axisLabel = gaugeItem.axisLabel; const style = axisLabel.style; return (0, _util2.deepMerge)(_objectSpread({}, labelAlign[i]), style) } function getBackgroundArcConfig (gaugeItem) { const animationCurve = gaugeItem.animationCurve; const animationFrame = gaugeItem.animationFrame; const rLevel = gaugeItem.rLevel; return [{ name: 'arc', index: rLevel, visible: gaugeItem.backgroundArc.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getGaugeBackgroundArcShape(gaugeItem), style: getGaugeBackgroundArcStyle(gaugeItem) }] } function getGaugeBackgroundArcShape (gaugeItem) { const startAngle = gaugeItem.startAngle; const endAngle = gaugeItem.endAngle; const center = gaugeItem.center; const radius = gaugeItem.radius; return { rx: center[0], ry: center[1], r: radius, startAngle: startAngle, endAngle: endAngle } } function getGaugeBackgroundArcStyle (gaugeItem) { const backgroundArc = gaugeItem.backgroundArc; const arcLineWidth = gaugeItem.arcLineWidth; const style = backgroundArc.style; return (0, _util2.deepMerge)({ lineWidth: arcLineWidth }, style) } function getStartBackgroundArcConfig (gaugeItem) { const config = getBackgroundArcConfig(gaugeItem)[0]; const shape = _objectSpread({}, config.shape); shape.endAngle = config.shape.startAngle; config.shape = shape; return [config] } function getArcConfig (gaugeItem) { const data = gaugeItem.data; const animationCurve = gaugeItem.animationCurve; const animationFrame = gaugeItem.animationFrame; const rLevel = gaugeItem.rLevel; return data.map(function (foo, i) { return { name: 'agArc', index: rLevel, animationCurve: animationCurve, animationFrame: animationFrame, shape: getGaugeArcShape(gaugeItem, i), style: getGaugeArcStyle(gaugeItem, i) } }) } function getGaugeArcShape (gaugeItem, i) { const data = gaugeItem.data; const center = gaugeItem.center; let gradientEndAngle = gaugeItem.endAngle; const _data$i = data[i]; const radius = _data$i.radius; const startAngle = _data$i.startAngle; const endAngle = _data$i.endAngle; const localGradient = _data$i.localGradient; if (localGradient)gradientEndAngle = endAngle; return { rx: center[0], ry: center[1], r: radius, startAngle: startAngle, endAngle: endAngle, gradientEndAngle: gradientEndAngle } } function getGaugeArcStyle (gaugeItem, i) { const data = gaugeItem.data; const dataItemStyle = gaugeItem.dataItemStyle; const _data$i2 = data[i]; const lineWidth = _data$i2.lineWidth; let gradient = _data$i2.gradient; gradient = gradient.map(function (c) { return (0, _color.getRgbaValue)(c) }); return (0, _util2.deepMerge)({ lineWidth: lineWidth, gradient: gradient }, dataItemStyle) } function getStartArcConfig (gaugeItem) { const configs = getArcConfig(gaugeItem); configs.map(function (config) { const shape = _objectSpread({}, config.shape); shape.endAngle = config.shape.startAngle; config.shape = shape }); return configs } function beforeChangeArc (graph, config) { const graphGradient = graph.style.gradient; const cacheNum = graphGradient.length; const needNum = config.style.gradient.length; if (cacheNum > needNum) { graphGradient.splice(needNum) } else { const last = graphGradient.slice(-1)[0]; graphGradient.push.apply(graphGradient, (0, _toConsumableArray2.default)(new Array(needNum - cacheNum).fill(0).map(function (foo) { return (0, _toConsumableArray2.default)(last) }))) } } function getPointerConfig (gaugeItem) { const animationCurve = gaugeItem.animationCurve; const animationFrame = gaugeItem.animationFrame; const center = gaugeItem.center; const rLevel = gaugeItem.rLevel; return [{ name: 'polyline', index: rLevel, visible: gaugeItem.pointer.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getPointerShape(gaugeItem), style: getPointerStyle(gaugeItem), setGraphCenter: function setGraphCenter (foo, graph) { graph.style.graphCenter = center } }] } function getPointerShape (gaugeItem) { const center = gaugeItem.center; return { points: getPointerPoints(center), close: true } } function getPointerStyle (gaugeItem) { const startAngle = gaugeItem.startAngle; const endAngle = gaugeItem.endAngle; const min = gaugeItem.min; const max = gaugeItem.max; const data = gaugeItem.data; const pointer = gaugeItem.pointer; const center = gaugeItem.center; const valueIndex = pointer.valueIndex; const style = pointer.style; const value = data[valueIndex] ? data[valueIndex].value : 0; const angle = (value - min) / (max - min) * (endAngle - startAngle) + startAngle + Math.PI / 2; return (0, _util2.deepMerge)({ rotate: (0, _util2.radianToAngle)(angle), scale: [1, 1], graphCenter: center }, style) } function getPointerPoints (_ref8) { const _ref9 = (0, _slicedToArray2.default)(_ref8, 2); const x = _ref9[0]; const y = _ref9[1]; const point1 = [x, y - 40]; const point2 = [x + 5, y]; const point3 = [x, y + 10]; const point4 = [x - 5, y]; return [point1, point2, point3, point4] } function getStartPointerConfig (gaugeItem) { const startAngle = gaugeItem.startAngle; const config = getPointerConfig(gaugeItem)[0]; config.style.rotate = (0, _util2.radianToAngle)(startAngle + Math.PI / 2); return [config] } function getDetailsConfig (gaugeItem) { const detailsPosition = gaugeItem.detailsPosition; const animationCurve = gaugeItem.animationCurve; const animationFrame = gaugeItem.animationFrame; const rLevel = gaugeItem.rLevel; const visible = gaugeItem.details.show; return detailsPosition.map(function (foo, i) { return { name: 'numberText', index: rLevel, visible: visible, animationCurve: animationCurve, animationFrame: animationFrame, shape: getDetailsShape(gaugeItem, i), style: getDetailsStyle(gaugeItem, i) } }) } function getDetailsShape (gaugeItem, i) { const detailsPosition = gaugeItem.detailsPosition; const detailsContent = gaugeItem.detailsContent; const data = gaugeItem.data; const details = gaugeItem.details; const position = detailsPosition[i]; const content = detailsContent[i]; const dataValue = data[i].value; const toFixed = details.valueToFixed; return { number: [dataValue], content: content, position: position, toFixed: toFixed } } function getDetailsStyle (gaugeItem, i) { const details = gaugeItem.details; const data = gaugeItem.data; const style = details.style; const color = data[i].color; return (0, _util2.deepMerge)({ fill: color }, style) } }, { '../class/updater.class': 3, '../config/gauge': 7, '../util': 30, '@babel/runtime/helpers/defineProperty': 35, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42, '@babel/runtime/helpers/typeof': 43, '@jiaminghi/c-render/lib/plugin/util': 54, '@jiaminghi/color': 56 }], 19: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.grid = grid; const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _updater = require('../class/updater.class'); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _config = require('../config'); const _util2 = require('../util'); function ownKeys (object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly)symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread (target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } function grid (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; let grid = option.grid; grid = (0, _util2.deepMerge)((0, _util.deepClone)(_config.gridConfig, true), grid || {}); (0, _updater.doUpdate)({ chart: chart, series: [grid], key: 'grid', getGraphConfig: getGridConfig }) } function getGridConfig (gridItem, updater) { const animationCurve = gridItem.animationCurve; const animationFrame = gridItem.animationFrame; const rLevel = gridItem.rLevel; const shape = getGridShape(gridItem, updater); const style = getGridStyle(gridItem); updater.chart.gridArea = _objectSpread({}, shape); return [{ name: 'rect', index: rLevel, animationCurve: animationCurve, animationFrame: animationFrame, shape: shape, style: style }] } function getGridShape (gridItem, updater) { const _updater$chart$render = (0, _slicedToArray2.default)(updater.chart.render.area, 2); const w = _updater$chart$render[0]; const h = _updater$chart$render[1]; const left = getNumberValue(gridItem.left, w); const right = getNumberValue(gridItem.right, w); const top = getNumberValue(gridItem.top, h); const bottom = getNumberValue(gridItem.bottom, h); const width = w - left - right; const height = h - top - bottom; return { x: left, y: top, w: width, h: height } } function getNumberValue (val, all) { if (typeof val === 'number') return val; if (typeof val !== 'string') return 0; return all * parseInt(val) / 100 } function getGridStyle (gridItem) { const style = gridItem.style; return style } }, { '../class/updater.class': 3, '../config': 9, '../util': 30, '@babel/runtime/helpers/defineProperty': 35, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@jiaminghi/c-render/lib/plugin/util': 54 }], 20: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); Object.defineProperty(exports, 'mergeColor', { enumerable: true, get: function get () { return _mergeColor.mergeColor } }); Object.defineProperty(exports, 'title', { enumerable: true, get: function get () { return _title.title } }); Object.defineProperty(exports, 'grid', { enumerable: true, get: function get () { return _grid.grid } }); Object.defineProperty(exports, 'axis', { enumerable: true, get: function get () { return _axis.axis } }); Object.defineProperty(exports, 'line', { enumerable: true, get: function get () { return _line.line } }); Object.defineProperty(exports, 'bar', { enumerable: true, get: function get () { return _bar.bar } }); Object.defineProperty(exports, 'pie', { enumerable: true, get: function get () { return _pie.pie } }); Object.defineProperty(exports, 'radarAxis', { enumerable: true, get: function get () { return _radarAxis.radarAxis } }); Object.defineProperty(exports, 'radar', { enumerable: true, get: function get () { return _radar.radar } }); Object.defineProperty(exports, 'gauge', { enumerable: true, get: function get () { return _gauge.gauge } }); Object.defineProperty(exports, 'legend', { enumerable: true, get: function get () { return _legend.legend } }); var _mergeColor = require('./mergeColor'); var _title = require('./title'); var _grid = require('./grid'); var _axis = require('./axis'); var _line = require('./line'); var _bar = require('./bar'); var _pie = require('./pie'); var _radarAxis = require('./radarAxis'); var _radar = require('./radar'); var _gauge = require('./gauge'); var _legend = require('./legend') }, { './axis': 16, './bar': 17, './gauge': 18, './grid': 19, './legend': 21, './line': 22, './mergeColor': 23, './pie': 24, './radar': 25, './radarAxis': 26, './title': 27 }], 21: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.legend = legend; const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _updater = require('../class/updater.class'); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _config = require('../config'); const _util2 = require('../util'); function legend (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; let legend = option.legend; if (legend) { legend = (0, _util2.deepMerge)((0, _util.deepClone)(_config.legendConfig, true), legend); legend = initLegendData(legend); legend = filterInvalidData(legend, option, chart); legend = calcLegendTextWidth(legend, chart); legend = calcLegendPosition(legend, chart); legend = [legend] } else { legend = [] }(0, _updater.doUpdate)({ chart: chart, series: legend, key: 'legendIcon', getGraphConfig: getIconConfig }); (0, _updater.doUpdate)({ chart: chart, series: legend, key: 'legendText', getGraphConfig: getTextConfig }) } function initLegendData (legend) { const data = legend.data; legend.data = data.map(function (item) { const itemType = (0, _typeof2.default)(item); if (itemType === 'string') { return { name: item } } else if (itemType === 'object') { return item } return { name: '' } }); return legend } function filterInvalidData (legend, option, chart) { const series = option.series; let legendStatus = chart.legendStatus; const data = legend.data.filter(function (item) { const name = item.name; const result = series.find(function (_ref) { const sn = _ref.name; return name === sn }); if (!result) return false; if (!item.color)item.color = result.color; if (!item.icon)item.icon = result.type; return item }); if (!legendStatus || legendStatus.length !== legend.data.length)legendStatus = new Array(legend.data.length).fill(true); data.forEach(function (item, i) { return item.status = legendStatus[i] }); legend.data = data; chart.legendStatus = legendStatus; return legend } function calcLegendTextWidth (legend, chart) { const ctx = chart.render.ctx; const data = legend.data; const textStyle = legend.textStyle; const textUnselectedStyle = legend.textUnselectedStyle; data.forEach(function (item) { const status = item.status; const name = item.name; item.textWidth = getTextWidth(ctx, name, status ? textStyle : textUnselectedStyle) }); return legend } function getTextWidth (ctx, text, style) { ctx.font = getFontConfig(style); return ctx.measureText(text).width } function getFontConfig (style) { const fontFamily = style.fontFamily; const fontSize = style.fontSize; return ''.concat(fontSize, 'px ').concat(fontFamily) } function calcLegendPosition (legend, chart) { const orient = legend.orient; if (orient === 'vertical') { calcVerticalPosition(legend, chart) } else { calcHorizontalPosition(legend, chart) } return legend } function calcHorizontalPosition (legend, chart) { const iconHeight = legend.iconHeight; const itemGap = legend.itemGap; const lines = calcDefaultHorizontalPosition(legend, chart); const xOffsets = lines.map(function (line) { return getHorizontalXOffset(line, legend, chart) }); const yOffset = getHorizontalYOffset(legend, chart); const align = { textAlign: 'left', textBaseline: 'middle' }; lines.forEach(function (line, i) { return line.forEach(function (item) { const iconPosition = item.iconPosition; const textPosition = item.textPosition; const xOffset = xOffsets[i]; const realYOffset = yOffset + i * (itemGap + iconHeight); item.iconPosition = mergeOffset(iconPosition, [xOffset, realYOffset]); item.textPosition = mergeOffset(textPosition, [xOffset, realYOffset]); item.align = align }) }) } function calcDefaultHorizontalPosition (legend, chart) { const data = legend.data; const iconWidth = legend.iconWidth; const w = chart.render.area[0]; let startIndex = 0; const lines = [[]]; data.forEach(function (item, i) { let beforeWidth = getBeforeWidth(startIndex, i, legend); const endXPos = beforeWidth + iconWidth + 5 + item.textWidth; if (endXPos >= w) { startIndex = i; beforeWidth = getBeforeWidth(startIndex, i, legend); lines.push([]) }item.iconPosition = [beforeWidth, 0]; item.textPosition = [beforeWidth + iconWidth + 5, 0]; lines.slice(-1)[0].push(item) }); return lines } function getBeforeWidth (startIndex, currentIndex, legend) { const data = legend.data; const iconWidth = legend.iconWidth; const itemGap = legend.itemGap; const beforeItem = data.slice(startIndex, currentIndex); return (0, _util2.mulAdd)(beforeItem.map(function (_ref2) { const textWidth = _ref2.textWidth; return textWidth })) + (currentIndex - startIndex) * (itemGap + 5 + iconWidth) } function getHorizontalXOffset (data, legend, chart) { const left = legend.left; let right = legend.right; const iconWidth = legend.iconWidth; const itemGap = legend.itemGap; const w = chart.render.area[0]; const dataNum = data.length; const allWidth = (0, _util2.mulAdd)(data.map(function (_ref3) { const textWidth = _ref3.textWidth; return textWidth })) + dataNum * (5 + iconWidth) + (dataNum - 1) * itemGap; const horizontal = [left, right].findIndex(function (pos) { return pos !== 'auto' }); if (horizontal === -1) { return (w - allWidth) / 2 } else if (horizontal === 0) { if (typeof left === 'number') return left; return parseInt(left) / 100 * w } else { if (typeof right !== 'number')right = parseInt(right) / 100 * w; return w - (allWidth + right) } } function getHorizontalYOffset (legend, chart) { const top = legend.top; let bottom = legend.bottom; const iconHeight = legend.iconHeight; const h = chart.render.area[1]; const vertical = [top, bottom].findIndex(function (pos) { return pos !== 'auto' }); const halfIconHeight = iconHeight / 2; if (vertical === -1) { const _chart$gridArea = chart.gridArea; const y = _chart$gridArea.y; const height = _chart$gridArea.h; return y + height + 45 - halfIconHeight } else if (vertical === 0) { if (typeof top === 'number') return top - halfIconHeight; return parseInt(top) / 100 * h - halfIconHeight } else { if (typeof bottom !== 'number')bottom = parseInt(bottom) / 100 * h; return h - bottom - halfIconHeight } } function mergeOffset (_ref4, _ref5) { const _ref6 = (0, _slicedToArray2.default)(_ref4, 2); const x = _ref6[0]; const y = _ref6[1]; const _ref7 = (0, _slicedToArray2.default)(_ref5, 2); const ox = _ref7[0]; const oy = _ref7[1]; return [x + ox, y + oy] } function calcVerticalPosition (legend, chart) { const _getVerticalXOffset = getVerticalXOffset(legend, chart); const _getVerticalXOffset2 = (0, _slicedToArray2.default)(_getVerticalXOffset, 2); const isRight = _getVerticalXOffset2[0]; const xOffset = _getVerticalXOffset2[1]; const yOffset = getVerticalYOffset(legend, chart); calcDefaultVerticalPosition(legend, isRight); const align = { textAlign: 'left', textBaseline: 'middle' }; legend.data.forEach(function (item) { const textPosition = item.textPosition; const iconPosition = item.iconPosition; item.textPosition = mergeOffset(textPosition, [xOffset, yOffset]); item.iconPosition = mergeOffset(iconPosition, [xOffset, yOffset]); item.align = align }) } function getVerticalXOffset (legend, chart) { const left = legend.left; const right = legend.right; const w = chart.render.area[0]; const horizontal = [left, right].findIndex(function (pos) { return pos !== 'auto' }); if (horizontal === -1) { return [true, w - 10] } else { let offset = [left, right][horizontal]; if (typeof offset !== 'number')offset = parseInt(offset) / 100 * w; return [Boolean(horizontal), offset] } } function getVerticalYOffset (legend, chart) { const iconHeight = legend.iconHeight; const itemGap = legend.itemGap; const data = legend.data; const top = legend.top; const bottom = legend.bottom; const h = chart.render.area[1]; const dataNum = data.length; const allHeight = dataNum * iconHeight + (dataNum - 1) * itemGap; const vertical = [top, bottom].findIndex(function (pos) { return pos !== 'auto' }); if (vertical === -1) { return (h - allHeight) / 2 } else { let offset = [top, bottom][vertical]; if (typeof offset !== 'number')offset = parseInt(offset) / 100 * h; if (vertical === 1)offset = h - offset - allHeight; return offset } } function calcDefaultVerticalPosition (legend, isRight) { const data = legend.data; const iconWidth = legend.iconWidth; const iconHeight = legend.iconHeight; const itemGap = legend.itemGap; const halfIconHeight = iconHeight / 2; data.forEach(function (item, i) { const textWidth = item.textWidth; const yPos = (iconHeight + itemGap) * i + halfIconHeight; const iconXPos = isRight ? 0 - iconWidth : 0; const textXpos = isRight ? iconXPos - 5 - textWidth : iconWidth + 5; item.iconPosition = [iconXPos, yPos]; item.textPosition = [textXpos, yPos] }) } function getIconConfig (legendItem, updater) { const data = legendItem.data; const selectAble = legendItem.selectAble; const animationCurve = legendItem.animationCurve; const animationFrame = legendItem.animationFrame; const rLevel = legendItem.rLevel; return data.map(function (item, i) { return (0, _defineProperty2.default)({ name: item.icon === 'line' ? 'lineIcon' : 'rect', index: rLevel, visible: legendItem.show, hover: selectAble, click: selectAble, animationCurve: animationCurve, animationFrame: animationFrame, shape: getIconShape(legendItem, i), style: getIconStyle(legendItem, i) }, 'click', createClickCallBack(legendItem, i, updater)) }) } function getIconShape (legendItem, i) { const data = legendItem.data; const iconWidth = legendItem.iconWidth; const iconHeight = legendItem.iconHeight; const _data$i$iconPosition = (0, _slicedToArray2.default)(data[i].iconPosition, 2); const x = _data$i$iconPosition[0]; const y = _data$i$iconPosition[1]; const halfIconHeight = iconHeight / 2; return { x: x, y: y - halfIconHeight, w: iconWidth, h: iconHeight } } function getIconStyle (legendItem, i) { const data = legendItem.data; const iconStyle = legendItem.iconStyle; const iconUnselectedStyle = legendItem.iconUnselectedStyle; const _data$i = data[i]; const status = _data$i.status; const color = _data$i.color; const style = status ? iconStyle : iconUnselectedStyle; return (0, _util2.deepMerge)({ fill: color }, style) } function getTextConfig (legendItem, updater) { const data = legendItem.data; const selectAble = legendItem.selectAble; const animationCurve = legendItem.animationCurve; const animationFrame = legendItem.animationFrame; const rLevel = legendItem.rLevel; return data.map(function (foo, i) { return { name: 'text', index: rLevel, visible: legendItem.show, hover: selectAble, animationCurve: animationCurve, animationFrame: animationFrame, hoverRect: getTextHoverRect(legendItem, i), shape: getTextShape(legendItem, i), style: getTextStyle(legendItem, i), click: createClickCallBack(legendItem, i, updater) } }) } function getTextShape (legendItem, i) { const _legendItem$data$i = legendItem.data[i]; const textPosition = _legendItem$data$i.textPosition; const name = _legendItem$data$i.name; return { content: name, position: textPosition } } function getTextStyle (legendItem, i) { const textStyle = legendItem.textStyle; const textUnselectedStyle = legendItem.textUnselectedStyle; const _legendItem$data$i2 = legendItem.data[i]; const status = _legendItem$data$i2.status; const align = _legendItem$data$i2.align; const style = status ? textStyle : textUnselectedStyle; return (0, _util2.deepMerge)((0, _util.deepClone)(style, true), align) } function getTextHoverRect (legendItem, i) { const textStyle = legendItem.textStyle; const textUnselectedStyle = legendItem.textUnselectedStyle; const _legendItem$data$i3 = legendItem.data[i]; const status = _legendItem$data$i3.status; const _legendItem$data$i3$t = (0, _slicedToArray2.default)(_legendItem$data$i3.textPosition, 2); const x = _legendItem$data$i3$t[0]; const y = _legendItem$data$i3$t[1]; const textWidth = _legendItem$data$i3.textWidth; const style = status ? textStyle : textUnselectedStyle; const fontSize = style.fontSize; return [x, y - fontSize / 2, textWidth, fontSize] } function createClickCallBack (legendItem, index, updater) { const name = legendItem.data[index].name; return function () { const _updater$chart = updater.chart; const legendStatus = _updater$chart.legendStatus; const option = _updater$chart.option; const status = !legendStatus[index]; const change = option.series.find(function (_ref9) { const sn = _ref9.name; return sn === name }); change.show = status; legendStatus[index] = status; updater.chart.setOption(option) } } }, { '../class/updater.class': 3, '../config': 9, '../util': 30, '@babel/runtime/helpers/defineProperty': 35, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/typeof': 43, '@jiaminghi/c-render/lib/plugin/util': 54 }], 22: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.line = line; const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _updater = require('../class/updater.class'); const _config = require('../config'); const _bezierCurve = _interopRequireDefault(require('@jiaminghi/bezier-curve')); const _util = require('../util'); function ownKeys (object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly)symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread (target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } const polylineToBezierCurve = _bezierCurve.default.polylineToBezierCurve; const getBezierCurveLength = _bezierCurve.default.getBezierCurveLength; function line (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; const xAxis = option.xAxis; const yAxis = option.yAxis; const series = option.series; let lines = []; if (xAxis && yAxis && series) { lines = (0, _util.initNeedSeries)(series, _config.lineConfig, 'line'); lines = calcLinesPosition(lines, chart) }(0, _updater.doUpdate)({ chart: chart, series: lines, key: 'lineArea', getGraphConfig: getLineAreaConfig, getStartGraphConfig: getStartLineAreaConfig, beforeUpdate: beforeUpdateLineAndArea, beforeChange: beforeChangeLineAndArea }); (0, _updater.doUpdate)({ chart: chart, series: lines, key: 'line', getGraphConfig: getLineConfig, getStartGraphConfig: getStartLineConfig, beforeUpdate: beforeUpdateLineAndArea, beforeChange: beforeChangeLineAndArea }); (0, _updater.doUpdate)({ chart: chart, series: lines, key: 'linePoint', getGraphConfig: getPointConfig, getStartGraphConfig: getStartPointConfig }); (0, _updater.doUpdate)({ chart: chart, series: lines, key: 'lineLabel', getGraphConfig: getLabelConfig }) } function calcLinesPosition (lines, chart) { const axisData = chart.axisData; return lines.map(function (lineItem) { let lineData = (0, _util.mergeSameStackData)(lineItem, lines); lineData = mergeNonNumber(lineItem, lineData); const lineAxis = getLineAxis(lineItem, axisData); const linePosition = getLinePosition(lineData, lineAxis); const lineFillBottomPos = getLineFillBottomPos(lineAxis); return _objectSpread({}, lineItem, { linePosition: linePosition.filter(function (p) { return p }), lineFillBottomPos: lineFillBottomPos }) }) } function mergeNonNumber (lineItem, lineData) { const data = lineItem.data; return lineData.map(function (v, i) { return typeof data[i] === 'number' ? v : null }) } function getLineAxis (line, axisData) { const xAxisIndex = line.xAxisIndex; const yAxisIndex = line.yAxisIndex; const xAxis = axisData.find(function (_ref) { const axis = _ref.axis; const index = _ref.index; return axis === 'x' && index === xAxisIndex }); const yAxis = axisData.find(function (_ref2) { const axis = _ref2.axis; const index = _ref2.index; return axis === 'y' && index === yAxisIndex }); return [xAxis, yAxis] } function getLinePosition (lineData, lineAxis) { const valueAxisIndex = lineAxis.findIndex(function (_ref3) { const data = _ref3.data; return data === 'value' }); const valueAxis = lineAxis[valueAxisIndex]; const labelAxis = lineAxis[1 - valueAxisIndex]; const linePosition = valueAxis.linePosition; const axis = valueAxis.axis; const tickPosition = labelAxis.tickPosition; const tickNum = tickPosition.length; const valueAxisPosIndex = axis === 'x' ? 0 : 1; const valueAxisStartPos = linePosition[0][valueAxisPosIndex]; const valueAxisEndPos = linePosition[1][valueAxisPosIndex]; const valueAxisPosMinus = valueAxisEndPos - valueAxisStartPos; const maxValue = valueAxis.maxValue; const minValue = valueAxis.minValue; const valueMinus = maxValue - minValue; const position = new Array(tickNum).fill(0).map(function (foo, i) { const v = lineData[i]; if (typeof v !== 'number') return null; let valuePercent = (v - minValue) / valueMinus; if (valueMinus === 0)valuePercent = 0; return valuePercent * valueAxisPosMinus + valueAxisStartPos }); return position.map(function (vPos, i) { if (i >= tickNum || typeof vPos !== 'number') return null; const pos = [vPos, tickPosition[i][1 - valueAxisPosIndex]]; if (valueAxisPosIndex === 0) return pos; pos.reverse(); return pos }) } function getLineFillBottomPos (lineAxis) { const valueAxis = lineAxis.find(function (_ref4) { const data = _ref4.data; return data === 'value' }); const axis = valueAxis.axis; const linePosition = valueAxis.linePosition; const minValue = valueAxis.minValue; const maxValue = valueAxis.maxValue; const changeIndex = axis === 'x' ? 0 : 1; let changeValue = linePosition[0][changeIndex]; if (minValue < 0 && maxValue > 0) { const valueMinus = maxValue - minValue; const posMinus = Math.abs(linePosition[0][changeIndex] - linePosition[1][changeIndex]); let offset = Math.abs(minValue) / valueMinus * posMinus; if (axis === 'y')offset *= -1; changeValue += offset } return { changeIndex: changeIndex, changeValue: changeValue } } function getLineAreaConfig (lineItem) { const animationCurve = lineItem.animationCurve; const animationFrame = lineItem.animationFrame; const lineFillBottomPos = lineItem.lineFillBottomPos; const rLevel = lineItem.rLevel; return [{ name: getLineGraphName(lineItem), index: rLevel, animationCurve: animationCurve, animationFrame: animationFrame, visible: lineItem.lineArea.show, lineFillBottomPos: lineFillBottomPos, shape: getLineAndAreaShape(lineItem), style: getLineAreaStyle(lineItem), drawed: lineAreaDrawed }] } function getLineAndAreaShape (lineItem) { const linePosition = lineItem.linePosition; return { points: linePosition } } function getLineAreaStyle (lineItem) { const lineArea = lineItem.lineArea; const color = lineItem.color; const gradient = lineArea.gradient; let style = lineArea.style; const fillColor = [style.fill || color]; const gradientColor = (0, _util.deepMerge)(fillColor, gradient); if (gradientColor.length === 1)gradientColor.push(gradientColor[0]); const gradientParams = getGradientParams(lineItem); style = _objectSpread({}, style, { stroke: 'rgba(0, 0, 0, 0)' }); return (0, _util.deepMerge)({ gradientColor: gradientColor, gradientParams: gradientParams, gradientType: 'linear', gradientWith: 'fill' }, style) } function getGradientParams (lineItem) { const lineFillBottomPos = lineItem.lineFillBottomPos; const linePosition = lineItem.linePosition; const changeIndex = lineFillBottomPos.changeIndex; const changeValue = lineFillBottomPos.changeValue; const mainPos = linePosition.map(function (p) { return p[changeIndex] }); const maxPos = Math.max.apply(Math, (0, _toConsumableArray2.default)(mainPos)); const minPos = Math.min.apply(Math, (0, _toConsumableArray2.default)(mainPos)); let beginPos = maxPos; if (changeIndex === 1)beginPos = minPos; if (changeIndex === 1) { return [0, beginPos, 0, changeValue] } else { return [beginPos, 0, changeValue, 0] } } function lineAreaDrawed (_ref5, _ref6) { const lineFillBottomPos = _ref5.lineFillBottomPos; const shape = _ref5.shape; const ctx = _ref6.ctx; const points = shape.points; const changeIndex = lineFillBottomPos.changeIndex; const changeValue = lineFillBottomPos.changeValue; const linePoint1 = (0, _toConsumableArray2.default)(points[points.length - 1]); const linePoint2 = (0, _toConsumableArray2.default)(points[0]); linePoint1[changeIndex] = changeValue; linePoint2[changeIndex] = changeValue; ctx.lineTo.apply(ctx, (0, _toConsumableArray2.default)(linePoint1)); ctx.lineTo.apply(ctx, (0, _toConsumableArray2.default)(linePoint2)); ctx.closePath(); ctx.fill() } function getStartLineAreaConfig (lineItem) { const config = getLineAreaConfig(lineItem)[0]; const style = _objectSpread({}, config.style); style.opacity = 0; config.style = style; return [config] } function beforeUpdateLineAndArea (graphs, lineItem, i, updater) { const cache = graphs[i]; if (!cache) return; const currentName = getLineGraphName(lineItem); const render = updater.chart.render; const name = cache[0].name; const delAll = currentName !== name; if (!delAll) return; cache.forEach(function (g) { return render.delGraph(g) }); graphs[i] = null } function beforeChangeLineAndArea (graph, config) { const points = config.shape.points; const graphPoints = graph.shape.points; const graphPointsNum = graphPoints.length; const pointsNum = points.length; if (pointsNum > graphPointsNum) { const lastPoint = graphPoints.slice(-1)[0]; const newAddPoints = new Array(pointsNum - graphPointsNum).fill(0).map(function (foo) { return (0, _toConsumableArray2.default)(lastPoint) }); graphPoints.push.apply(graphPoints, (0, _toConsumableArray2.default)(newAddPoints)) } else if (pointsNum < graphPointsNum) { graphPoints.splice(pointsNum) } } function getLineConfig (lineItem) { const animationCurve = lineItem.animationCurve; const animationFrame = lineItem.animationFrame; const rLevel = lineItem.rLevel; return [{ name: getLineGraphName(lineItem), index: rLevel + 1, animationCurve: animationCurve, animationFrame: animationFrame, shape: getLineAndAreaShape(lineItem), style: getLineStyle(lineItem) }] } function getLineGraphName (lineItem) { const smooth = lineItem.smooth; return smooth ? 'smoothline' : 'polyline' } function getLineStyle (lineItem) { const lineStyle = lineItem.lineStyle; const color = lineItem.color; const smooth = lineItem.smooth; const linePosition = lineItem.linePosition; const lineLength = getLineLength(linePosition, smooth); return (0, _util.deepMerge)({ stroke: color, lineDash: [lineLength, 0] }, lineStyle) } function getLineLength (points) { const smooth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; if (!smooth) return (0, _util.getPolylineLength)(points); const curve = polylineToBezierCurve(points); return getBezierCurveLength(curve) } function getStartLineConfig (lineItem) { const lineDash = lineItem.lineStyle.lineDash; const config = getLineConfig(lineItem)[0]; let realLineDash = config.style.lineDash; if (lineDash) { realLineDash = [0, 0] } else { realLineDash = (0, _toConsumableArray2.default)(realLineDash).reverse() }config.style.lineDash = realLineDash; return [config] } function getPointConfig (lineItem) { const animationCurve = lineItem.animationCurve; const animationFrame = lineItem.animationFrame; const rLevel = lineItem.rLevel; const shapes = getPointShapes(lineItem); const style = getPointStyle(lineItem); return shapes.map(function (shape) { return { name: 'circle', index: rLevel + 2, visible: lineItem.linePoint.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: shape, style: style } }) } function getPointShapes (lineItem) { const linePosition = lineItem.linePosition; const radius = lineItem.linePoint.radius; return linePosition.map(function (_ref7) { const _ref8 = (0, _slicedToArray2.default)(_ref7, 2); const rx = _ref8[0]; const ry = _ref8[1]; return { r: radius, rx: rx, ry: ry } }) } function getPointStyle (lineItem) { const color = lineItem.color; const style = lineItem.linePoint.style; return (0, _util.deepMerge)({ stroke: color }, style) } function getStartPointConfig (lineItem) { const configs = getPointConfig(lineItem); configs.forEach(function (config) { config.shape.r = 0.1 }); return configs } function getLabelConfig (lineItem) { const animationCurve = lineItem.animationCurve; const animationFrame = lineItem.animationFrame; const rLevel = lineItem.rLevel; const shapes = getLabelShapes(lineItem); const style = getLabelStyle(lineItem); return shapes.map(function (shape, i) { return { name: 'text', index: rLevel + 3, visible: lineItem.label.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: shape, style: style } }) } function getLabelShapes (lineItem) { const contents = formatterLabel(lineItem); const position = getLabelPosition(lineItem); return contents.map(function (content, i) { return { content: content, position: position[i] } }) } function getLabelPosition (lineItem) { const linePosition = lineItem.linePosition; const lineFillBottomPos = lineItem.lineFillBottomPos; const label = lineItem.label; const position = label.position; const offset = label.offset; const changeIndex = lineFillBottomPos.changeIndex; const changeValue = lineFillBottomPos.changeValue; return linePosition.map(function (pos) { if (position === 'bottom') { pos = (0, _toConsumableArray2.default)(pos); pos[changeIndex] = changeValue } if (position === 'center') { const bottom = (0, _toConsumableArray2.default)(pos); bottom[changeIndex] = changeValue; pos = getCenterLabelPoint(pos, bottom) } return getOffsetedPoint(pos, offset) }) } function getOffsetedPoint (_ref9, _ref10) { const _ref11 = (0, _slicedToArray2.default)(_ref9, 2); const x = _ref11[0]; const y = _ref11[1]; const _ref12 = (0, _slicedToArray2.default)(_ref10, 2); const ox = _ref12[0]; const oy = _ref12[1]; return [x + ox, y + oy] } function getCenterLabelPoint (_ref13, _ref14) { const _ref15 = (0, _slicedToArray2.default)(_ref13, 2); const ax = _ref15[0]; const ay = _ref15[1]; const _ref16 = (0, _slicedToArray2.default)(_ref14, 2); const bx = _ref16[0]; const by = _ref16[1]; return [(ax + bx) / 2, (ay + by) / 2] } function formatterLabel (lineItem) { let data = lineItem.data; const formatter = lineItem.label.formatter; data = data.filter(function (d) { return typeof d === 'number' }).map(function (d) { return d.toString() }); if (!formatter) return data; const type = (0, _typeof2.default)(formatter); if (type === 'string') return data.map(function (d) { return formatter.replace('{value}', d) }); if (type === 'function') return data.map(function (value, index) { return formatter({ value: value, index: index }) }); return data } function getLabelStyle (lineItem) { const color = lineItem.color; const style = lineItem.label.style; return (0, _util.deepMerge)({ fill: color }, style) } }, { '../class/updater.class': 3, '../config': 9, '../util': 30, '@babel/runtime/helpers/defineProperty': 35, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42, '@babel/runtime/helpers/typeof': 43, '@jiaminghi/bezier-curve': 47 }], 23: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.mergeColor = mergeColor; const _config = require('../config'); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _util2 = require('../util'); function mergeColor (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; const defaultColor = (0, _util.deepClone)(_config.colorConfig, true); let color = option.color; let series = option.series; if (!series)series = []; if (!color)color = []; option.color = color = (0, _util2.deepMerge)(defaultColor, color); if (!series.length) return; const colorNum = color.length; series.forEach(function (item, i) { if (item.color) return; item.color = color[i % colorNum] }); const pies = series.filter(function (_ref) { const type = _ref.type; return type === 'pie' }); pies.forEach(function (pie) { return pie.data.forEach(function (di, i) { return di.color = color[i % colorNum] }) }); const gauges = series.filter(function (_ref2) { const type = _ref2.type; return type === 'gauge' }); gauges.forEach(function (gauge) { return gauge.data.forEach(function (di, i) { return di.color = color[i % colorNum] }) }); const barWithIndependentColor = series.filter(function (_ref3) { const type = _ref3.type; const independentColor = _ref3.independentColor; return type === 'bar' && independentColor }); barWithIndependentColor.forEach(function (bar) { if (bar.independentColors) return; bar.independentColors = color }) } }, { '../config': 9, '../util': 30, '@jiaminghi/c-render/lib/plugin/util': 54 }], 24: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.pie = pie; const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _updater = require('../class/updater.class'); const _pie = require('../config/pie'); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _util2 = require('../util'); function ownKeys (object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly)symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread (target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } function pie (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; let series = option.series; if (!series)series = []; let pies = (0, _util2.initNeedSeries)(series, _pie.pieConfig, 'pie'); pies = calcPiesCenter(pies, chart); pies = calcPiesRadius(pies, chart); pies = calcRosePiesRadius(pies, chart); pies = calcPiesPercent(pies); pies = calcPiesAngle(pies, chart); pies = calcPiesInsideLabelPos(pies); pies = calcPiesEdgeCenterPos(pies); pies = calcPiesOutSideLabelPos(pies); (0, _updater.doUpdate)({ chart: chart, series: pies, key: 'pie', getGraphConfig: getPieConfig, getStartGraphConfig: getStartPieConfig, beforeChange: beforeChangePie }); (0, _updater.doUpdate)({ chart: chart, series: pies, key: 'pieInsideLabel', getGraphConfig: getInsideLabelConfig }); (0, _updater.doUpdate)({ chart: chart, series: pies, key: 'pieOutsideLabelLine', getGraphConfig: getOutsideLabelLineConfig, getStartGraphConfig: getStartOutsideLabelLineConfig }); (0, _updater.doUpdate)({ chart: chart, series: pies, key: 'pieOutsideLabel', getGraphConfig: getOutsideLabelConfig, getStartGraphConfig: getStartOutsideLabelConfig }) } function calcPiesCenter (pies, chart) { const area = chart.render.area; pies.forEach(function (pie) { let center = pie.center; center = center.map(function (pos, i) { if (typeof pos === 'number') return pos; return parseInt(pos) / 100 * area[i] }); pie.center = center }); return pies } function calcPiesRadius (pies, chart) { const maxRadius = Math.min.apply(Math, (0, _toConsumableArray2.default)(chart.render.area)) / 2; pies.forEach(function (pie) { let radius = pie.radius; const data = pie.data; radius = getNumberRadius(radius, maxRadius); data.forEach(function (item) { let itemRadius = item.radius; if (!itemRadius)itemRadius = radius; itemRadius = getNumberRadius(itemRadius, maxRadius); item.radius = itemRadius }); pie.radius = radius }); return pies } function getNumberRadius (radius, maxRadius) { if (!(radius instanceof Array))radius = [0, radius]; radius = radius.map(function (r) { if (typeof r === 'number') return r; return parseInt(r) / 100 * maxRadius }); return radius } function calcRosePiesRadius (pies, chart) { const rosePie = pies.filter(function (_ref) { const roseType = _ref.roseType; return roseType }); rosePie.forEach(function (pie) { const radius = pie.radius; let data = pie.data; const roseSort = pie.roseSort; const roseIncrement = getRoseIncrement(pie); const dataCopy = (0, _toConsumableArray2.default)(data); data = sortData(data); data.forEach(function (item, i) { item.radius[1] = radius[1] - roseIncrement * i }); if (roseSort) { data.reverse() } else { pie.data = dataCopy }pie.roseIncrement = roseIncrement }); return pies } function sortData (data) { return data.sort(function (_ref2, _ref3) { const a = _ref2.value; const b = _ref3.value; if (a === b) return 0; if (a > b) return -1; if (a < b) return 1 }) } function getRoseIncrement (pie) { const radius = pie.radius; const roseIncrement = pie.roseIncrement; if (typeof roseIncrement === 'number') return roseIncrement; if (roseIncrement === 'auto') { const data = pie.data; const allRadius = data.reduce(function (all, _ref4) { const radius = _ref4.radius; return [].concat((0, _toConsumableArray2.default)(all), (0, _toConsumableArray2.default)(radius)) }, []); const minRadius = Math.min.apply(Math, (0, _toConsumableArray2.default)(allRadius)); const maxRadius = Math.max.apply(Math, (0, _toConsumableArray2.default)(allRadius)); return (maxRadius - minRadius) * 0.6 / (data.length - 1 || 1) } return parseInt(roseIncrement) / 100 * radius[1] } function calcPiesPercent (pies) { pies.forEach(function (pie) { const data = pie.data; const percentToFixed = pie.percentToFixed; const sum = getDataSum(data); data.forEach(function (item) { const value = item.value; item.percent = toFixedNoCeil(value / sum * 100, percentToFixed) }); const percentSumNoLast = (0, _util2.mulAdd)(data.slice(0, -1).map(function (_ref5) { const percent = _ref5.percent; return percent })); data.slice(-1)[0].percent = toFixedNoCeil(100 - percentSumNoLast, percentToFixed) }); return pies } function toFixedNoCeil (number) { const toFixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; const stringNumber = number.toString(); const splitedNumber = stringNumber.split('.'); const decimal = splitedNumber[1] || '0'; const fixedDecimal = decimal.slice(0, toFixed); splitedNumber[1] = fixedDecimal; return parseFloat(splitedNumber.join('.')) } function getDataSum (data) { return (0, _util2.mulAdd)(data.map(function (_ref6) { const value = _ref6.value; return value })) } function calcPiesAngle (pies) { pies.forEach(function (pie) { const start = pie.startAngle; const data = pie.data; data.forEach(function (item, i) { const _getDataAngle = getDataAngle(data, i); const _getDataAngle2 = (0, _slicedToArray2.default)(_getDataAngle, 2); const startAngle = _getDataAngle2[0]; const endAngle = _getDataAngle2[1]; item.startAngle = start + startAngle; item.endAngle = start + endAngle }) }); return pies } function getDataAngle (data, i) { const fullAngle = Math.PI * 2; const needAddData = data.slice(0, i + 1); const percentSum = (0, _util2.mulAdd)(needAddData.map(function (_ref7) { const percent = _ref7.percent; return percent })); const percent = data[i].percent; const startPercent = percentSum - percent; return [fullAngle * startPercent / 100, fullAngle * percentSum / 100] } function calcPiesInsideLabelPos (pies) { pies.forEach(function (pieItem) { const data = pieItem.data; data.forEach(function (item) { item.insideLabelPos = getPieInsideLabelPos(pieItem, item) }) }); return pies } function getPieInsideLabelPos (pieItem, dataItem) { const center = pieItem.center; const startAngle = dataItem.startAngle; const endAngle = dataItem.endAngle; const _dataItem$radius = (0, _slicedToArray2.default)(dataItem.radius, 2); const ir = _dataItem$radius[0]; const or = _dataItem$radius[1]; const radius = (ir + or) / 2; const angle = (startAngle + endAngle) / 2; return _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(center).concat([radius, angle])) } function calcPiesEdgeCenterPos (pies) { pies.forEach(function (pie) { const data = pie.data; const center = pie.center; data.forEach(function (item) { const startAngle = item.startAngle; const endAngle = item.endAngle; const radius = item.radius; const centerAngle = (startAngle + endAngle) / 2; const pos = _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(center).concat([radius[1], centerAngle])); item.edgeCenterPos = pos }) }); return pies } function calcPiesOutSideLabelPos (pies) { pies.forEach(function (pieItem) { let leftPieDataItems = getLeftOrRightPieDataItems(pieItem); let rightPieDataItems = getLeftOrRightPieDataItems(pieItem, false); leftPieDataItems = sortPiesFromTopToBottom(leftPieDataItems); rightPieDataItems = sortPiesFromTopToBottom(rightPieDataItems); addLabelLineAndAlign(leftPieDataItems, pieItem); addLabelLineAndAlign(rightPieDataItems, pieItem, false) }); return pies } function getLabelLineBendRadius (pieItem) { let labelLineBendGap = pieItem.outsideLabel.labelLineBendGap; const maxRadius = getPieMaxRadius(pieItem); if (typeof labelLineBendGap !== 'number') { labelLineBendGap = parseInt(labelLineBendGap) / 100 * maxRadius } return labelLineBendGap + maxRadius } function getPieMaxRadius (pieItem) { const data = pieItem.data; const radius = data.map(function (_ref8) { const _ref8$radius = (0, _slicedToArray2.default)(_ref8.radius, 2); const foo = _ref8$radius[0]; const r = _ref8$radius[1]; return r }); return Math.max.apply(Math, (0, _toConsumableArray2.default)(radius)) } function getLeftOrRightPieDataItems (pieItem) { const left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true; const data = pieItem.data; const center = pieItem.center; const centerXPos = center[0]; return data.filter(function (_ref9) { const edgeCenterPos = _ref9.edgeCenterPos; const xPos = edgeCenterPos[0]; if (left) return xPos <= centerXPos; return xPos > centerXPos }) } function sortPiesFromTopToBottom (dataItem) { dataItem.sort(function (_ref10, _ref11) { const _ref10$edgeCenterPos = (0, _slicedToArray2.default)(_ref10.edgeCenterPos, 2); const t = _ref10$edgeCenterPos[0]; const ay = _ref10$edgeCenterPos[1]; const _ref11$edgeCenterPos = (0, _slicedToArray2.default)(_ref11.edgeCenterPos, 2); const tt = _ref11$edgeCenterPos[0]; const by = _ref11$edgeCenterPos[1]; if (ay > by) return 1; if (ay < by) return -1; if (ay === by) return 0 }); return dataItem } function addLabelLineAndAlign (dataItem, pieItem) { const left = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; const center = pieItem.center; const outsideLabel = pieItem.outsideLabel; const radius = getLabelLineBendRadius(pieItem); dataItem.forEach(function (item) { const edgeCenterPos = item.edgeCenterPos; const startAngle = item.startAngle; const endAngle = item.endAngle; const labelLineEndLength = outsideLabel.labelLineEndLength; const angle = (startAngle + endAngle) / 2; const bendPoint = _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(center).concat([radius, angle])); const endPoint = (0, _toConsumableArray2.default)(bendPoint); endPoint[0] += labelLineEndLength * (left ? -1 : 1); item.labelLine = [edgeCenterPos, bendPoint, endPoint]; item.labelLineLength = (0, _util2.getPolylineLength)(item.labelLine); item.align = { textAlign: 'left', textBaseline: 'middle' }; if (left)item.align.textAlign = 'right' }) } function getPieConfig (pieItem) { const data = pieItem.data; const animationCurve = pieItem.animationCurve; const animationFrame = pieItem.animationFrame; const rLevel = pieItem.rLevel; return data.map(function (foo, i) { return { name: 'pie', index: rLevel, animationCurve: animationCurve, animationFrame: animationFrame, shape: getPieShape(pieItem, i), style: getPieStyle(pieItem, i) } }) } function getStartPieConfig (pieItem) { const animationDelayGap = pieItem.animationDelayGap; const startAnimationCurve = pieItem.startAnimationCurve; const configs = getPieConfig(pieItem); configs.forEach(function (config, i) { config.animationCurve = startAnimationCurve; config.animationDelay = i * animationDelayGap; config.shape.or = config.shape.ir }); return configs } function beforeChangePie (graph) { graph.animationDelay = 0 } function getPieShape (pieItem, i) { const center = pieItem.center; const data = pieItem.data; const dataItem = data[i]; const radius = dataItem.radius; const startAngle = dataItem.startAngle; const endAngle = dataItem.endAngle; return { startAngle: startAngle, endAngle: endAngle, ir: radius[0], or: radius[1], rx: center[0], ry: center[1] } } function getPieStyle (pieItem, i) { const pieStyle = pieItem.pieStyle; const data = pieItem.data; const dataItem = data[i]; const color = dataItem.color; return (0, _util2.deepMerge)({ fill: color }, pieStyle) } function getInsideLabelConfig (pieItem) { const animationCurve = pieItem.animationCurve; const animationFrame = pieItem.animationFrame; const data = pieItem.data; const rLevel = pieItem.rLevel; return data.map(function (foo, i) { return { name: 'text', index: rLevel, visible: pieItem.insideLabel.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getInsideLabelShape(pieItem, i), style: getInsideLabelStyle(pieItem, i) } }) } function getInsideLabelShape (pieItem, i) { const insideLabel = pieItem.insideLabel; const data = pieItem.data; const formatter = insideLabel.formatter; const dataItem = data[i]; const formatterType = (0, _typeof2.default)(formatter); let label = ''; if (formatterType === 'string') { label = formatter.replace('{name}', dataItem.name); label = label.replace('{percent}', dataItem.percent); label = label.replace('{value}', dataItem.value) } if (formatterType === 'function') { label = formatter(dataItem) } return { content: label, position: dataItem.insideLabelPos } } function getInsideLabelStyle (pieItem, i) { const style = pieItem.insideLabel.style; return style } function getOutsideLabelLineConfig (pieItem) { const animationCurve = pieItem.animationCurve; const animationFrame = pieItem.animationFrame; const data = pieItem.data; const rLevel = pieItem.rLevel; return data.map(function (foo, i) { return { name: 'polyline', index: rLevel, visible: pieItem.outsideLabel.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getOutsideLabelLineShape(pieItem, i), style: getOutsideLabelLineStyle(pieItem, i) } }) } function getStartOutsideLabelLineConfig (pieItem) { const data = pieItem.data; const configs = getOutsideLabelLineConfig(pieItem); configs.forEach(function (config, i) { config.style.lineDash = [0, data[i].labelLineLength] }); return configs } function getOutsideLabelLineShape (pieItem, i) { const data = pieItem.data; const dataItem = data[i]; return { points: dataItem.labelLine } } function getOutsideLabelLineStyle (pieItem, i) { const outsideLabel = pieItem.outsideLabel; const data = pieItem.data; const labelLineStyle = outsideLabel.labelLineStyle; const color = data[i].color; return (0, _util2.deepMerge)({ stroke: color, lineDash: [data[i].labelLineLength, 0] }, labelLineStyle) } function getOutsideLabelConfig (pieItem) { const animationCurve = pieItem.animationCurve; const animationFrame = pieItem.animationFrame; const data = pieItem.data; const rLevel = pieItem.rLevel; return data.map(function (foo, i) { return { name: 'text', index: rLevel, visible: pieItem.outsideLabel.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getOutsideLabelShape(pieItem, i), style: getOutsideLabelStyle(pieItem, i) } }) } function getStartOutsideLabelConfig (pieItem) { const data = pieItem.data; const configs = getOutsideLabelConfig(pieItem); configs.forEach(function (config, i) { config.shape.position = data[i].labelLine[1] }); return configs } function getOutsideLabelShape (pieItem, i) { const outsideLabel = pieItem.outsideLabel; const data = pieItem.data; const formatter = outsideLabel.formatter; const _data$i = data[i]; const labelLine = _data$i.labelLine; const name = _data$i.name; const percent = _data$i.percent; const value = _data$i.value; const formatterType = (0, _typeof2.default)(formatter); let label = ''; if (formatterType === 'string') { label = formatter.replace('{name}', name); label = label.replace('{percent}', percent); label = label.replace('{value}', value) } if (formatterType === 'function') { label = formatter(data[i]) } return { content: label, position: labelLine[2] } } function getOutsideLabelStyle (pieItem, i) { const outsideLabel = pieItem.outsideLabel; const data = pieItem.data; const _data$i2 = data[i]; const color = _data$i2.color; const align = _data$i2.align; const style = outsideLabel.style; return (0, _util2.deepMerge)(_objectSpread({ fill: color }, align), style) } }, { '../class/updater.class': 3, '../config/pie': 12, '../util': 30, '@babel/runtime/helpers/defineProperty': 35, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42, '@babel/runtime/helpers/typeof': 43, '@jiaminghi/c-render/lib/plugin/util': 54 }], 25: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.radar = radar; const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _updater = require('../class/updater.class'); const _index = require('../config/index'); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _color = require('@jiaminghi/color'); const _util2 = require('../util'); function ownKeys (object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly)symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread (target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } function radar (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; let series = option.series; if (!series)series = []; let radars = (0, _util2.initNeedSeries)(series, _index.radarConfig, 'radar'); radars = calcRadarPosition(radars, chart); radars = calcRadarLabelPosition(radars, chart); radars = calcRadarLabelAlign(radars, chart); (0, _updater.doUpdate)({ chart: chart, series: radars, key: 'radar', getGraphConfig: getRadarConfig, getStartGraphConfig: getStartRadarConfig, beforeChange: beforeChangeRadar }); (0, _updater.doUpdate)({ chart: chart, series: radars, key: 'radarPoint', getGraphConfig: getPointConfig, getStartGraphConfig: getStartPointConfig }); (0, _updater.doUpdate)({ chart: chart, series: radars, key: 'radarLabel', getGraphConfig: getLabelConfig }) } function calcRadarPosition (radars, chart) { const radarAxis = chart.radarAxis; if (!radarAxis) return []; const indicator = radarAxis.indicator; const axisLineAngles = radarAxis.axisLineAngles; const radius = radarAxis.radius; const centerPos = radarAxis.centerPos; radars.forEach(function (radarItem) { const data = radarItem.data; radarItem.dataRadius = []; radarItem.radarPosition = indicator.map(function (_ref, i) { let max = _ref.max; let min = _ref.min; let v = data[i]; if (typeof max !== 'number')max = v; if (typeof min !== 'number')min = 0; if (typeof v !== 'number')v = min; const dataRadius = (v - min) / (max - min) * radius; radarItem.dataRadius[i] = dataRadius; return _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(centerPos).concat([dataRadius, axisLineAngles[i]])) }) }); return radars } function calcRadarLabelPosition (radars, chart) { const radarAxis = chart.radarAxis; if (!radarAxis) return []; const centerPos = radarAxis.centerPos; const axisLineAngles = radarAxis.axisLineAngles; radars.forEach(function (radarItem) { const dataRadius = radarItem.dataRadius; const label = radarItem.label; const labelGap = label.labelGap; radarItem.labelPosition = dataRadius.map(function (r, i) { return _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(centerPos).concat([r + labelGap, axisLineAngles[i]])) }) }); return radars } function calcRadarLabelAlign (radars, chart) { const radarAxis = chart.radarAxis; if (!radarAxis) return []; const _radarAxis$centerPos = (0, _slicedToArray2.default)(radarAxis.centerPos, 2); const x = _radarAxis$centerPos[0]; const y = _radarAxis$centerPos[1]; radars.forEach(function (radarItem) { const labelPosition = radarItem.labelPosition; const labelAlign = labelPosition.map(function (_ref2) { const _ref3 = (0, _slicedToArray2.default)(_ref2, 2); const lx = _ref3[0]; const ly = _ref3[1]; const textAlign = lx > x ? 'left' : 'right'; const textBaseline = ly > y ? 'top' : 'bottom'; return { textAlign: textAlign, textBaseline: textBaseline } }); radarItem.labelAlign = labelAlign }); return radars } function getRadarConfig (radarItem) { const animationCurve = radarItem.animationCurve; const animationFrame = radarItem.animationFrame; const rLevel = radarItem.rLevel; return [{ name: 'polyline', index: rLevel, animationCurve: animationCurve, animationFrame: animationFrame, shape: getRadarShape(radarItem), style: getRadarStyle(radarItem) }] } function getStartRadarConfig (radarItem, updater) { const centerPos = updater.chart.radarAxis.centerPos; const config = getRadarConfig(radarItem)[0]; const pointNum = config.shape.points.length; const points = new Array(pointNum).fill(0).map(function (foo) { return (0, _toConsumableArray2.default)(centerPos) }); config.shape.points = points; return [config] } function getRadarShape (radarItem) { const radarPosition = radarItem.radarPosition; return { points: radarPosition, close: true } } function getRadarStyle (radarItem) { const radarStyle = radarItem.radarStyle; const color = radarItem.color; const colorRgbaValue = (0, _color.getRgbaValue)(color); colorRgbaValue[3] = 0.5; const radarDefaultColor = { stroke: color, fill: (0, _color.getColorFromRgbValue)(colorRgbaValue) }; return (0, _util2.deepMerge)(radarDefaultColor, radarStyle) } function beforeChangeRadar (graph, _ref4) { const shape = _ref4.shape; const graphPoints = graph.shape.points; const graphPointsNum = graphPoints.length; const pointsNum = shape.points.length; if (pointsNum > graphPointsNum) { const lastPoint = graphPoints.slice(-1)[0]; const newAddPoints = new Array(pointsNum - graphPointsNum).fill(0).map(function (foo) { return (0, _toConsumableArray2.default)(lastPoint) }); graphPoints.push.apply(graphPoints, (0, _toConsumableArray2.default)(newAddPoints)) } else if (pointsNum < graphPointsNum) { graphPoints.splice(pointsNum) } } function getPointConfig (radarItem) { const radarPosition = radarItem.radarPosition; const animationCurve = radarItem.animationCurve; const animationFrame = radarItem.animationFrame; const rLevel = radarItem.rLevel; return radarPosition.map(function (foo, i) { return { name: 'circle', index: rLevel, animationCurve: animationCurve, animationFrame: animationFrame, visible: radarItem.point.show, shape: getPointShape(radarItem, i), style: getPointStyle(radarItem, i) } }) } function getStartPointConfig (radarItem) { const configs = getPointConfig(radarItem); configs.forEach(function (config) { return config.shape.r = 0.01 }); return configs } function getPointShape (radarItem, i) { const radarPosition = radarItem.radarPosition; const point = radarItem.point; const radius = point.radius; const position = radarPosition[i]; return { rx: position[0], ry: position[1], r: radius } } function getPointStyle (radarItem, i) { const point = radarItem.point; const color = radarItem.color; const style = point.style; return (0, _util2.deepMerge)({ stroke: color }, style) } function getLabelConfig (radarItem) { const labelPosition = radarItem.labelPosition; const animationCurve = radarItem.animationCurve; const animationFrame = radarItem.animationFrame; const rLevel = radarItem.rLevel; return labelPosition.map(function (foo, i) { return { name: 'text', index: rLevel, visible: radarItem.label.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getLabelShape(radarItem, i), style: getLabelStyle(radarItem, i) } }) } function getLabelShape (radarItem, i) { const labelPosition = radarItem.labelPosition; const label = radarItem.label; const data = radarItem.data; const offset = label.offset; const formatter = label.formatter; const position = mergePointOffset(labelPosition[i], offset); let labelText = data[i] ? data[i].toString() : '0'; const formatterType = (0, _typeof2.default)(formatter); if (formatterType === 'string')labelText = formatter.replace('{value}', labelText); if (formatterType === 'function')labelText = formatter(labelText); return { content: labelText, position: position } } function mergePointOffset (_ref5, _ref6) { const _ref7 = (0, _slicedToArray2.default)(_ref5, 2); const x = _ref7[0]; const y = _ref7[1]; const _ref8 = (0, _slicedToArray2.default)(_ref6, 2); const ox = _ref8[0]; const oy = _ref8[1]; return [x + ox, y + oy] } function getLabelStyle (radarItem, i) { const label = radarItem.label; const color = radarItem.color; const labelAlign = radarItem.labelAlign; const style = label.style; const defaultColorAndAlign = _objectSpread({ fill: color }, labelAlign[i]); return (0, _util2.deepMerge)(defaultColorAndAlign, style) } }, { '../class/updater.class': 3, '../config/index': 9, '../util': 30, '@babel/runtime/helpers/defineProperty': 35, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42, '@babel/runtime/helpers/typeof': 43, '@jiaminghi/c-render/lib/plugin/util': 54, '@jiaminghi/color': 56 }], 26: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.radarAxis = radarAxis; const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _updater = require('../class/updater.class'); const _index = require('../config/index'); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _util2 = require('../util'); function ownKeys (object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly)symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread (target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } function radarAxis (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; const radar = option.radar; let radarAxis = []; if (radar) { radarAxis = mergeRadarAxisDefaultConfig(radar); radarAxis = calcRadarAxisCenter(radarAxis, chart); radarAxis = calcRadarAxisRingRadius(radarAxis, chart); radarAxis = calcRadarAxisLinePosition(radarAxis); radarAxis = calcRadarAxisAreaRadius(radarAxis); radarAxis = calcRadarAxisLabelPosition(radarAxis); radarAxis = [radarAxis] } let radarAxisForUpdate = radarAxis; if (radarAxis.length && !radarAxis[0].show)radarAxisForUpdate = []; (0, _updater.doUpdate)({ chart: chart, series: radarAxisForUpdate, key: 'radarAxisSplitArea', getGraphConfig: getSplitAreaConfig, beforeUpdate: beforeUpdateSplitArea, beforeChange: beforeChangeSplitArea }); (0, _updater.doUpdate)({ chart: chart, series: radarAxisForUpdate, key: 'radarAxisSplitLine', getGraphConfig: getSplitLineConfig, beforeUpdate: beforeUpdateSplitLine, beforeChange: beforeChangeSplitLine }); (0, _updater.doUpdate)({ chart: chart, series: radarAxisForUpdate, key: 'radarAxisLine', getGraphConfig: getAxisLineConfig }); (0, _updater.doUpdate)({ chart: chart, series: radarAxisForUpdate, key: 'radarAxisLable', getGraphConfig: getAxisLabelConfig }); chart.radarAxis = radarAxis[0] } function mergeRadarAxisDefaultConfig (radar) { return (0, _util2.deepMerge)((0, _util.deepClone)(_index.radarAxisConfig), radar) } function calcRadarAxisCenter (radarAxis, chart) { const area = chart.render.area; const center = radarAxis.center; radarAxis.centerPos = center.map(function (v, i) { if (typeof v === 'number') return v; return parseInt(v) / 100 * area[i] }); return radarAxis } function calcRadarAxisRingRadius (radarAxis, chart) { const area = chart.render.area; const splitNum = radarAxis.splitNum; let radius = radarAxis.radius; const maxRadius = Math.min.apply(Math, (0, _toConsumableArray2.default)(area)) / 2; if (typeof radius !== 'number')radius = parseInt(radius) / 100 * maxRadius; const splitGap = radius / splitNum; radarAxis.ringRadius = new Array(splitNum).fill(0).map(function (foo, i) { return splitGap * (i + 1) }); radarAxis.radius = radius; return radarAxis } function calcRadarAxisLinePosition (radarAxis) { const indicator = radarAxis.indicator; const centerPos = radarAxis.centerPos; const radius = radarAxis.radius; const startAngle = radarAxis.startAngle; const fullAngle = Math.PI * 2; const indicatorNum = indicator.length; const indicatorGap = fullAngle / indicatorNum; const angles = new Array(indicatorNum).fill(0).map(function (foo, i) { return indicatorGap * i + startAngle }); radarAxis.axisLineAngles = angles; radarAxis.axisLinePosition = angles.map(function (g) { return _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(centerPos).concat([radius, g])) }); return radarAxis } function calcRadarAxisAreaRadius (radarAxis) { const ringRadius = radarAxis.ringRadius; const subRadius = ringRadius[0] / 2; radarAxis.areaRadius = ringRadius.map(function (r) { return r - subRadius }); return radarAxis } function calcRadarAxisLabelPosition (radarAxis) { const axisLineAngles = radarAxis.axisLineAngles; const centerPos = radarAxis.centerPos; let radius = radarAxis.radius; const axisLabel = radarAxis.axisLabel; radius += axisLabel.labelGap; radarAxis.axisLabelPosition = axisLineAngles.map(function (angle) { return _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(centerPos).concat([radius, angle])) }); return radarAxis } function getSplitAreaConfig (radarAxis) { const areaRadius = radarAxis.areaRadius; const polygon = radarAxis.polygon; const animationCurve = radarAxis.animationCurve; const animationFrame = radarAxis.animationFrame; const rLevel = radarAxis.rLevel; const name = polygon ? 'regPolygon' : 'ring'; return areaRadius.map(function (foo, i) { return { name: name, index: rLevel, visible: radarAxis.splitArea.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getSplitAreaShape(radarAxis, i), style: getSplitAreaStyle(radarAxis, i) } }) } function getSplitAreaShape (radarAxis, i) { const polygon = radarAxis.polygon; const areaRadius = radarAxis.areaRadius; const indicator = radarAxis.indicator; const centerPos = radarAxis.centerPos; const indicatorNum = indicator.length; const shape = { rx: centerPos[0], ry: centerPos[1], r: areaRadius[i] }; if (polygon)shape.side = indicatorNum; return shape } function getSplitAreaStyle (radarAxis, i) { const splitArea = radarAxis.splitArea; const ringRadius = radarAxis.ringRadius; const axisLineAngles = radarAxis.axisLineAngles; const polygon = radarAxis.polygon; const centerPos = radarAxis.centerPos; const color = splitArea.color; let style = splitArea.style; style = _objectSpread({ fill: 'rgba(0, 0, 0, 0)' }, style); let lineWidth = ringRadius[0] - 0; if (polygon) { const point1 = _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(centerPos).concat([ringRadius[0], axisLineAngles[0]])); const point2 = _util.getCircleRadianPoint.apply(void 0, (0, _toConsumableArray2.default)(centerPos).concat([ringRadius[0], axisLineAngles[1]])); lineWidth = (0, _util2.getPointToLineDistance)(centerPos, point1, point2) }style = (0, _util2.deepMerge)((0, _util.deepClone)(style, true), { lineWidth: lineWidth }); if (!color.length) return style; const colorNum = color.length; return (0, _util2.deepMerge)(style, { stroke: color[i % colorNum] }) } function beforeUpdateSplitArea (graphs, radarAxis, i, updater) { const cache = graphs[i]; if (!cache) return; const render = updater.chart.render; const polygon = radarAxis.polygon; const name = cache[0].name; const currentName = polygon ? 'regPolygon' : 'ring'; const delAll = currentName !== name; if (!delAll) return; cache.forEach(function (g) { return render.delGraph(g) }); graphs[i] = null } function beforeChangeSplitArea (graph, config) { const side = config.shape.side; if (typeof side !== 'number') return; graph.shape.side = side } function getSplitLineConfig (radarAxis) { const ringRadius = radarAxis.ringRadius; const polygon = radarAxis.polygon; const animationCurve = radarAxis.animationCurve; const animationFrame = radarAxis.animationFrame; const rLevel = radarAxis.rLevel; const name = polygon ? 'regPolygon' : 'ring'; return ringRadius.map(function (foo, i) { return { name: name, index: rLevel, animationCurve: animationCurve, animationFrame: animationFrame, visible: radarAxis.splitLine.show, shape: getSplitLineShape(radarAxis, i), style: getSplitLineStyle(radarAxis, i) } }) } function getSplitLineShape (radarAxis, i) { const ringRadius = radarAxis.ringRadius; const centerPos = radarAxis.centerPos; const indicator = radarAxis.indicator; const polygon = radarAxis.polygon; const shape = { rx: centerPos[0], ry: centerPos[1], r: ringRadius[i] }; const indicatorNum = indicator.length; if (polygon)shape.side = indicatorNum; return shape } function getSplitLineStyle (radarAxis, i) { const splitLine = radarAxis.splitLine; const color = splitLine.color; let style = splitLine.style; style = _objectSpread({ fill: 'rgba(0, 0, 0, 0)' }, style); if (!color.length) return style; const colorNum = color.length; return (0, _util2.deepMerge)(style, { stroke: color[i % colorNum] }) } function beforeUpdateSplitLine (graphs, radarAxis, i, updater) { const cache = graphs[i]; if (!cache) return; const render = updater.chart.render; const polygon = radarAxis.polygon; const name = cache[0].name; const currenName = polygon ? 'regPolygon' : 'ring'; const delAll = currenName !== name; if (!delAll) return; cache.forEach(function (g) { return render.delGraph(g) }); graphs[i] = null } function beforeChangeSplitLine (graph, config) { const side = config.shape.side; if (typeof side !== 'number') return; graph.shape.side = side } function getAxisLineConfig (radarAxis) { const axisLinePosition = radarAxis.axisLinePosition; const animationCurve = radarAxis.animationCurve; const animationFrame = radarAxis.animationFrame; const rLevel = radarAxis.rLevel; return axisLinePosition.map(function (foo, i) { return { name: 'polyline', index: rLevel, visible: radarAxis.axisLine.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getAxisLineShape(radarAxis, i), style: getAxisLineStyle(radarAxis, i) } }) } function getAxisLineShape (radarAxis, i) { const centerPos = radarAxis.centerPos; const axisLinePosition = radarAxis.axisLinePosition; const points = [centerPos, axisLinePosition[i]]; return { points: points } } function getAxisLineStyle (radarAxis, i) { const axisLine = radarAxis.axisLine; const color = axisLine.color; const style = axisLine.style; if (!color.length) return style; const colorNum = color.length; return (0, _util2.deepMerge)(style, { stroke: color[i % colorNum] }) } function getAxisLabelConfig (radarAxis) { const axisLabelPosition = radarAxis.axisLabelPosition; const animationCurve = radarAxis.animationCurve; const animationFrame = radarAxis.animationFrame; const rLevel = radarAxis.rLevel; return axisLabelPosition.map(function (foo, i) { return { name: 'text', index: rLevel, visible: radarAxis.axisLabel.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: getAxisLableShape(radarAxis, i), style: getAxisLableStyle(radarAxis, i) } }) } function getAxisLableShape (radarAxis, i) { const axisLabelPosition = radarAxis.axisLabelPosition; const indicator = radarAxis.indicator; return { content: indicator[i].name, position: axisLabelPosition[i] } } function getAxisLableStyle (radarAxis, i) { const axisLabel = radarAxis.axisLabel; const _radarAxis$centerPos = (0, _slicedToArray2.default)(radarAxis.centerPos, 2); const x = _radarAxis$centerPos[0]; const y = _radarAxis$centerPos[1]; const axisLabelPosition = radarAxis.axisLabelPosition; const color = axisLabel.color; let style = axisLabel.style; const _axisLabelPosition$i = (0, _slicedToArray2.default)(axisLabelPosition[i], 2); const labelXpos = _axisLabelPosition$i[0]; const labelYPos = _axisLabelPosition$i[1]; const textAlign = labelXpos > x ? 'left' : 'right'; const textBaseline = labelYPos > y ? 'top' : 'bottom'; style = (0, _util2.deepMerge)({ textAlign: textAlign, textBaseline: textBaseline }, style); if (!color.length) return style; const colorNum = color.length; return (0, _util2.deepMerge)(style, { fill: color[i % colorNum] }) } }, { '../class/updater.class': 3, '../config/index': 9, '../util': 30, '@babel/runtime/helpers/defineProperty': 35, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42, '@jiaminghi/c-render/lib/plugin/util': 54 }], 27: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.title = title; const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _updater = require('../class/updater.class'); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _config = require('../config'); const _util2 = require('../util'); function title (chart) { const option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; const title = []; if (option.title) { title[0] = (0, _util2.deepMerge)((0, _util.deepClone)(_config.titleConfig, true), option.title) }(0, _updater.doUpdate)({ chart: chart, series: title, key: 'title', getGraphConfig: getTitleConfig }) } function getTitleConfig (titleItem, updater) { const animationCurve = _config.titleConfig.animationCurve; const animationFrame = _config.titleConfig.animationFrame; const rLevel = _config.titleConfig.rLevel; const shape = getTitleShape(titleItem, updater); const style = getTitleStyle(titleItem); return [{ name: 'text', index: rLevel, visible: titleItem.show, animationCurve: animationCurve, animationFrame: animationFrame, shape: shape, style: style }] } function getTitleShape (titleItem, updater) { const offset = titleItem.offset; const text = titleItem.text; const _updater$chart$gridAr = updater.chart.gridArea; const x = _updater$chart$gridAr.x; const y = _updater$chart$gridAr.y; const w = _updater$chart$gridAr.w; const _offset = (0, _slicedToArray2.default)(offset, 2); const ox = _offset[0]; const oy = _offset[1]; return { content: text, position: [x + w / 2 + ox, y + oy] } } function getTitleStyle (titleItem) { const style = titleItem.style; return style } }, { '../class/updater.class': 3, '../config': 9, '../util': 30, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@jiaminghi/c-render/lib/plugin/util': 54 }], 28: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _cRender = require('@jiaminghi/c-render'); const _util = require('@jiaminghi/c-render/lib/plugin/util'); const _color = require('@jiaminghi/color'); const _index = require('../util/index'); const pie = { shape: { rx: 0, ry: 0, ir: 0, or: 0, startAngle: 0, endAngle: 0, clockWise: true }, validator: function validator (_ref) { const shape = _ref.shape; const keys = ['rx', 'ry', 'ir', 'or', 'startAngle', 'endAngle']; if (keys.find(function (key) { return typeof shape[key] !== 'number' })) { console.error('Pie shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref2, _ref3) { const ctx = _ref2.ctx; const shape = _ref3.shape; ctx.beginPath(); let rx = shape.rx; let ry = shape.ry; const ir = shape.ir; const or = shape.or; const startAngle = shape.startAngle; const endAngle = shape.endAngle; const clockWise = shape.clockWise; rx = parseInt(rx) + 0.5; ry = parseInt(ry) + 0.5; ctx.arc(rx, ry, ir > 0 ? ir : 0, startAngle, endAngle, !clockWise); const connectPoint1 = (0, _util.getCircleRadianPoint)(rx, ry, or, endAngle).map(function (p) { return parseInt(p) + 0.5 }); const connectPoint2 = (0, _util.getCircleRadianPoint)(rx, ry, ir, startAngle).map(function (p) { return parseInt(p) + 0.5 }); ctx.lineTo.apply(ctx, (0, _toConsumableArray2.default)(connectPoint1)); ctx.arc(rx, ry, or > 0 ? or : 0, endAngle, startAngle, clockWise); ctx.lineTo.apply(ctx, (0, _toConsumableArray2.default)(connectPoint2)); ctx.closePath(); ctx.stroke(); ctx.fill() } }; const agArc = { shape: { rx: 0, ry: 0, r: 0, startAngle: 0, endAngle: 0, gradientStartAngle: null, gradientEndAngle: null }, validator: function validator (_ref4) { const shape = _ref4.shape; const keys = ['rx', 'ry', 'r', 'startAngle', 'endAngle']; if (keys.find(function (key) { return typeof shape[key] !== 'number' })) { console.error('AgArc shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref5, _ref6) { const ctx = _ref5.ctx; const shape = _ref6.shape; const style = _ref6.style; let gradient = style.gradient; gradient = gradient.map(function (cv) { return (0, _color.getColorFromRgbValue)(cv) }); if (gradient.length === 1) { gradient = [gradient[0], gradient[0]] } const gradientArcNum = gradient.length - 1; let gradientStartAngle = shape.gradientStartAngle; let gradientEndAngle = shape.gradientEndAngle; const startAngle = shape.startAngle; const endAngle = shape.endAngle; const r = shape.r; const rx = shape.rx; const ry = shape.ry; if (gradientStartAngle === null)gradientStartAngle = startAngle; if (gradientEndAngle === null)gradientEndAngle = endAngle; let angleGap = (gradientEndAngle - gradientStartAngle) / gradientArcNum; if (angleGap === Math.PI * 2)angleGap = Math.PI * 2 - 0.001; for (let i = 0; i < gradientArcNum; i++) { ctx.beginPath(); const startPoint = (0, _util.getCircleRadianPoint)(rx, ry, r, startAngle + angleGap * i); const endPoint = (0, _util.getCircleRadianPoint)(rx, ry, r, startAngle + angleGap * (i + 1)); const color = (0, _index.getLinearGradientColor)(ctx, startPoint, endPoint, [gradient[i], gradient[i + 1]]); const arcStartAngle = startAngle + angleGap * i; let arcEndAngle = startAngle + angleGap * (i + 1); let doBreak = false; if (arcEndAngle > endAngle) { arcEndAngle = endAngle; doBreak = true }ctx.arc(rx, ry, r, arcStartAngle, arcEndAngle); ctx.strokeStyle = color; ctx.stroke(); if (doBreak) break } } }; const numberText = { shape: { number: [], content: '', position: [0, 0], toFixed: 0 }, validator: function validator (_ref7) { const shape = _ref7.shape; const number = shape.number; const content = shape.content; const position = shape.position; if (!(number instanceof Array) || typeof content !== 'string' || !(position instanceof Array)) { console.error('NumberText shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref8, _ref9) { const ctx = _ref8.ctx; const shape = _ref9.shape; ctx.beginPath(); const number = shape.number; const content = shape.content; const position = shape.position; const toFixed = shape.toFixed; const textSegments = content.split('{nt}'); const lastSegmentIndex = textSegments.length - 1; let textString = ''; textSegments.forEach(function (t, i) { let currentNumber = number[i]; if (i === lastSegmentIndex)currentNumber = ''; if (typeof currentNumber === 'number')currentNumber = currentNumber.toFixed(toFixed); textString += t + (currentNumber || '') }); ctx.closePath(); ctx.strokeText.apply(ctx, [textString].concat((0, _toConsumableArray2.default)(position))); ctx.fillText.apply(ctx, [textString].concat((0, _toConsumableArray2.default)(position))) } }; const lineIcon = { shape: { x: 0, y: 0, w: 0, h: 0 }, validator: function validator (_ref10) { const shape = _ref10.shape; const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; if (typeof x !== 'number' || typeof y !== 'number' || typeof w !== 'number' || typeof h !== 'number') { console.error('lineIcon shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref11, _ref12) { const ctx = _ref11.ctx; const shape = _ref12.shape; ctx.beginPath(); const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; const halfH = h / 2; ctx.strokeStyle = ctx.fillStyle; ctx.moveTo(x, y + halfH); ctx.lineTo(x + w, y + halfH); ctx.lineWidth = 1; ctx.stroke(); ctx.beginPath(); let radius = halfH - 5 * 2; if (radius <= 0)radius = 3; ctx.arc(x + w / 2, y + halfH, radius, 0, Math.PI * 2); ctx.lineWidth = 5; ctx.stroke(); ctx.fillStyle = '#fff'; ctx.fill() }, hoverCheck: function hoverCheck (position, _ref13) { const shape = _ref13.shape; const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; return (0, _util.checkPointIsInRect)(position, x, y, w, h) }, setGraphCenter: function setGraphCenter (e, _ref14) { const shape = _ref14.shape; const style = _ref14.style; const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; style.graphCenter = [x + w / 2, y + h / 2] } }; (0, _cRender.extendNewGraph)('pie', pie); (0, _cRender.extendNewGraph)('agArc', agArc); (0, _cRender.extendNewGraph)('numberText', numberText); (0, _cRender.extendNewGraph)('lineIcon', lineIcon) }, { '../util/index': 30, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/toConsumableArray': 42, '@jiaminghi/c-render': 52, '@jiaminghi/c-render/lib/plugin/util': 54, '@jiaminghi/color': 56 }], 29: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); Object.defineProperty(exports, 'changeDefaultConfig', { enumerable: true, get: function get () { return _config.changeDefaultConfig } }); exports.default = void 0; const _charts = _interopRequireDefault(require('./class/charts.class')); var _config = require('./config'); const _default = _charts.default; exports.default = _default }, { './class/charts.class': 2, './config': 9, '@babel/runtime/helpers/interopRequireDefault': 36 }], 30: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.filterNonNumber = filterNonNumber; exports.deepMerge = deepMerge; exports.mulAdd = mulAdd; exports.mergeSameStackData = mergeSameStackData; exports.getTwoPointDistance = getTwoPointDistance; exports.getLinearGradientColor = getLinearGradientColor; exports.getPolylineLength = getPolylineLength; exports.getPointToLineDistance = getPointToLineDistance; exports.initNeedSeries = initNeedSeries; exports.radianToAngle = radianToAngle; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _util = require('@jiaminghi/c-render/lib/plugin/util'); function filterNonNumber (array) { return array.filter(function (n) { return typeof n === 'number' }) } function deepMerge (target, merged) { for (const key in merged) { if (target[key] && (0, _typeof2.default)(target[key]) === 'object') { deepMerge(target[key], merged[key]); continue } if ((0, _typeof2.default)(merged[key]) === 'object') { target[key] = (0, _util.deepClone)(merged[key], true); continue }target[key] = merged[key] } return target } function mulAdd (nums) { nums = filterNonNumber(nums); return nums.reduce(function (all, num) { return all + num }, 0) } function mergeSameStackData (item, series) { const stack = item.stack; if (!stack) return (0, _toConsumableArray2.default)(item.data); const stacks = series.filter(function (_ref) { const s = _ref.stack; return s === stack }); const index = stacks.findIndex(function (_ref2) { const d = _ref2.data; return d === item.data }); const datas = stacks.splice(0, index + 1).map(function (_ref3) { const data = _ref3.data; return data }); const dataLength = datas[0].length; return new Array(dataLength).fill(0).map(function (foo, i) { return mulAdd(datas.map(function (d) { return d[i] })) }) } function getTwoPointDistance (pointOne, pointTwo) { const minusX = Math.abs(pointOne[0] - pointTwo[0]); const minusY = Math.abs(pointOne[1] - pointTwo[1]); return Math.sqrt(minusX * minusX + minusY * minusY) } function getLinearGradientColor (ctx, begin, end, color) { if (!ctx || !begin || !end || !color.length) return; let colors = color; typeof colors === 'string' && (colors = [color, color]); const linearGradientColor = ctx.createLinearGradient.apply(ctx, (0, _toConsumableArray2.default)(begin).concat((0, _toConsumableArray2.default)(end))); const colorGap = 1 / (colors.length - 1); colors.forEach(function (c, i) { return linearGradientColor.addColorStop(colorGap * i, c) }); return linearGradientColor } function getPolylineLength (points) { const lineSegments = new Array(points.length - 1).fill(0).map(function (foo, i) { return [points[i], points[i + 1]] }); const lengths = lineSegments.map(function (item) { return getTwoPointDistance.apply(void 0, (0, _toConsumableArray2.default)(item)) }); return mulAdd(lengths) } function getPointToLineDistance (point, linePointOne, linePointTwo) { const a = getTwoPointDistance(point, linePointOne); const b = getTwoPointDistance(point, linePointTwo); const c = getTwoPointDistance(linePointOne, linePointTwo); return 0.5 * Math.sqrt((a + b + c) * (a + b - c) * (a + c - b) * (b + c - a)) / c } function initNeedSeries (series, config, type) { series = series.filter(function (_ref4) { const st = _ref4.type; return st === type }); series = series.map(function (item) { return deepMerge((0, _util.deepClone)(config, true), item) }); return series.filter(function (_ref5) { const show = _ref5.show; return show }) } function radianToAngle (radian) { return radian / Math.PI * 180 } }, { '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/toConsumableArray': 42, '@babel/runtime/helpers/typeof': 43, '@jiaminghi/c-render/lib/plugin/util': 54 }], 31: [function (require, module, exports) { function _arrayWithHoles (arr) { if (Array.isArray(arr)) return arr }module.exports = _arrayWithHoles }, {}], 32: [function (require, module, exports) { function _arrayWithoutHoles (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i] } return arr2 } }module.exports = _arrayWithoutHoles }, {}], 33: [function (require, module, exports) { function asyncGeneratorStep (gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value } catch (error) { reject(error); return } if (info.done) { resolve(value) } else { Promise.resolve(value).then(_next, _throw) } } function _asyncToGenerator (fn) { return function () { const self = this; const args = arguments; return new Promise(function (resolve, reject) { const gen = fn.apply(self, args); function _next (value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value) } function _throw (err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err) }_next(undefined) }) } }module.exports = _asyncToGenerator }, {}], 34: [function (require, module, exports) { function _classCallCheck (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function') } }module.exports = _classCallCheck }, {}], 35: [function (require, module, exports) { function _defineProperty (obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }) } else { obj[key] = value } return obj }module.exports = _defineProperty }, {}], 36: [function (require, module, exports) { function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { default: obj } }module.exports = _interopRequireDefault }, {}], 37: [function (require, module, exports) { function _iterableToArray (iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === '[object Arguments]') return Array.from(iter) }module.exports = _iterableToArray }, {}], 38: [function (require, module, exports) { function _iterableToArrayLimit (arr, i) { const _arr = []; let _n = true; let _d = false; let _e; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break } } catch (err) { _d = true; _e = err } finally { try { if (!_n && _i.return != null)_i.return() } finally { if (_d) throw _e } } return _arr }module.exports = _iterableToArrayLimit }, {}], 39: [function (require, module, exports) { function _nonIterableRest () { throw new TypeError('Invalid attempt to destructure non-iterable instance') }module.exports = _nonIterableRest }, {}], 40: [function (require, module, exports) { function _nonIterableSpread () { throw new TypeError('Invalid attempt to spread non-iterable instance') }module.exports = _nonIterableSpread }, {}], 41: [function (require, module, exports) { const arrayWithHoles = require('./arrayWithHoles'); const iterableToArrayLimit = require('./iterableToArrayLimit'); const nonIterableRest = require('./nonIterableRest'); function _slicedToArray (arr, i) { return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest() }module.exports = _slicedToArray }, { './arrayWithHoles': 31, './iterableToArrayLimit': 38, './nonIterableRest': 39 }], 42: [function (require, module, exports) { const arrayWithoutHoles = require('./arrayWithoutHoles'); const iterableToArray = require('./iterableToArray'); const nonIterableSpread = require('./nonIterableSpread'); function _toConsumableArray (arr) { return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread() }module.exports = _toConsumableArray }, { './arrayWithoutHoles': 32, './iterableToArray': 37, './nonIterableSpread': 40 }], 43: [function (require, module, exports) { function _typeof2 (obj) { if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') { _typeof2 = function _typeof2 (obj) { return typeof obj } } else { _typeof2 = function _typeof2 (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj } } return _typeof2(obj) } function _typeof (obj) { if (typeof Symbol === 'function' && _typeof2(Symbol.iterator) === 'symbol') { module.exports = _typeof = function _typeof (obj) { return _typeof2(obj) } } else { module.exports = _typeof = function _typeof (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : _typeof2(obj) } } return _typeof(obj) }module.exports = _typeof }, {}], 44: [function (require, module, exports) { module.exports = require('regenerator-runtime') }, { 'regenerator-runtime': 59 }], 45: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.bezierCurveToPolyline = bezierCurveToPolyline; exports.getBezierCurveLength = getBezierCurveLength; exports.default = void 0; const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const sqrt = Math.sqrt; const pow = Math.pow; const ceil = Math.ceil; const abs = Math.abs; const defaultSegmentPointsNum = 50; function abstractBezierCurveToPolyline (bezierCurve) { const precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5; const segmentsNum = bezierCurve.length - 1; const startPoint = bezierCurve[0]; const endPoint = bezierCurve[segmentsNum][2]; const segments = bezierCurve.slice(1); const getSegmentTPointFuns = segments.map(function (seg, i) { const beginPoint = i === 0 ? startPoint : segments[i - 1][2]; return createGetBezierCurveTPointFun.apply(void 0, [beginPoint].concat((0, _toConsumableArray2.default)(seg))) }); const segmentPointsNum = new Array(segmentsNum).fill(defaultSegmentPointsNum); const segmentPoints = getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum); const result = calcUniformPointsByIteration(segmentPoints, getSegmentTPointFuns, segments, precision); result.segmentPoints.push(endPoint); return result } function createGetBezierCurveTPointFun (beginPoint, controlPoint1, controlPoint2, endPoint) { return function (t) { const tSubed1 = 1 - t; const tSubed1Pow3 = pow(tSubed1, 3); const tSubed1Pow2 = pow(tSubed1, 2); const tPow3 = pow(t, 3); const tPow2 = pow(t, 2); return [beginPoint[0] * tSubed1Pow3 + 3 * controlPoint1[0] * t * tSubed1Pow2 + 3 * controlPoint2[0] * tPow2 * tSubed1 + endPoint[0] * tPow3, beginPoint[1] * tSubed1Pow3 + 3 * controlPoint1[1] * t * tSubed1Pow2 + 3 * controlPoint2[1] * tPow2 * tSubed1 + endPoint[1] * tPow3] } } function getTwoPointDistance (_ref, _ref2) { const _ref3 = (0, _slicedToArray2.default)(_ref, 2); const ax = _ref3[0]; const ay = _ref3[1]; const _ref4 = (0, _slicedToArray2.default)(_ref2, 2); const bx = _ref4[0]; const by = _ref4[1]; return sqrt(pow(ax - bx, 2) + pow(ay - by, 2)) } function getNumsSum (nums) { return nums.reduce(function (sum, num) { return sum + num }, 0) } function getSegmentPointsDistance (segmentPoints) { return segmentPoints.map(function (points, i) { return new Array(points.length - 1).fill(0).map(function (temp, j) { return getTwoPointDistance(points[j], points[j + 1]) }) }) } function getSegmentPointsByNum (getSegmentTPointFuns, segmentPointsNum) { return getSegmentTPointFuns.map(function (getSegmentTPointFun, i) { const tGap = 1 / segmentPointsNum[i]; return new Array(segmentPointsNum[i]).fill('').map(function (foo, j) { return getSegmentTPointFun(j * tGap) }) }) } function getAllDeviations (segmentPointsDistance, avgLength) { return segmentPointsDistance.map(function (seg) { return seg.map(function (s) { return abs(s - avgLength) }) }).map(function (seg) { return getNumsSum(seg) }).reduce(function (total, v) { return total + v }, 0) } function calcUniformPointsByIteration (segmentPoints, getSegmentTPointFuns, segments, precision) { let rounds = 4; let cycles = 1; const _loop = function _loop () { let totalPointsNum = segmentPoints.reduce(function (total, seg) { return total + seg.length }, 0); segmentPoints.forEach(function (seg, i) { return seg.push(segments[i][2]) }); let segmentPointsDistance = getSegmentPointsDistance(segmentPoints); let lineSegmentNum = segmentPointsDistance.reduce(function (total, seg) { return total + seg.length }, 0); let segmentlength = segmentPointsDistance.map(function (seg) { return getNumsSum(seg) }); let totalLength = getNumsSum(segmentlength); let avgLength = totalLength / lineSegmentNum; const allDeviations = getAllDeviations(segmentPointsDistance, avgLength); if (allDeviations <= precision) return 'break'; totalPointsNum = ceil(avgLength / precision * totalPointsNum * 1.1); const segmentPointsNum = segmentlength.map(function (length) { return ceil(length / totalLength * totalPointsNum) }); segmentPoints = getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum); totalPointsNum = segmentPoints.reduce(function (total, seg) { return total + seg.length }, 0); const segmentPointsForLength = JSON.parse(JSON.stringify(segmentPoints)); segmentPointsForLength.forEach(function (seg, i) { return seg.push(segments[i][2]) }); segmentPointsDistance = getSegmentPointsDistance(segmentPointsForLength); lineSegmentNum = segmentPointsDistance.reduce(function (total, seg) { return total + seg.length }, 0); segmentlength = segmentPointsDistance.map(function (seg) { return getNumsSum(seg) }); totalLength = getNumsSum(segmentlength); avgLength = totalLength / lineSegmentNum; const stepSize = 1 / totalPointsNum / 10; getSegmentTPointFuns.forEach(function (getSegmentTPointFun, i) { const currentSegmentPointsNum = segmentPointsNum[i]; const t = new Array(currentSegmentPointsNum).fill('').map(function (foo, j) { return j / segmentPointsNum[i] }); for (let r = 0; r < rounds; r++) { const distance = getSegmentPointsDistance([segmentPoints[i]])[0]; const deviations = distance.map(function (d) { return d - avgLength }); let offset = 0; for (let j = 0; j < currentSegmentPointsNum; j++) { if (j === 0) return; offset += deviations[j - 1]; t[j] -= stepSize * offset; if (t[j] > 1)t[j] = 1; if (t[j] < 0)t[j] = 0; segmentPoints[i][j] = getSegmentTPointFun(t[j]) } } }); rounds *= 4; cycles++ }; do { const _ret = _loop(); if (_ret === 'break') break } while (rounds <= 1025); segmentPoints = segmentPoints.reduce(function (all, seg) { return all.concat(seg) }, []); return { segmentPoints: segmentPoints, cycles: cycles, rounds: rounds } } function bezierCurveToPolyline (bezierCurve) { const precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5; if (!bezierCurve) { console.error('bezierCurveToPolyline: Missing parameters!'); return false } if (!(bezierCurve instanceof Array)) { console.error('bezierCurveToPolyline: Parameter bezierCurve must be an array!'); return false } if (typeof precision !== 'number') { console.error('bezierCurveToPolyline: Parameter precision must be a number!'); return false } const _abstractBezierCurveT = abstractBezierCurveToPolyline(bezierCurve, precision); const segmentPoints = _abstractBezierCurveT.segmentPoints; return segmentPoints } function getBezierCurveLength (bezierCurve) { const precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5; if (!bezierCurve) { console.error('getBezierCurveLength: Missing parameters!'); return false } if (!(bezierCurve instanceof Array)) { console.error('getBezierCurveLength: Parameter bezierCurve must be an array!'); return false } if (typeof precision !== 'number') { console.error('getBezierCurveLength: Parameter precision must be a number!'); return false } const _abstractBezierCurveT2 = abstractBezierCurveToPolyline(bezierCurve, precision); const segmentPoints = _abstractBezierCurveT2.segmentPoints; const pointsDistance = getSegmentPointsDistance([segmentPoints])[0]; const length = getNumsSum(pointsDistance); return length } const _default = bezierCurveToPolyline; exports.default = _default }, { '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42 }], 46: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); function polylineToBezierCurve (polyline) { const close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; const offsetA = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.25; const offsetB = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.25; if (!(polyline instanceof Array)) { console.error('polylineToBezierCurve: Parameter polyline must be an array!'); return false } if (polyline.length <= 2) { console.error('polylineToBezierCurve: Converting to a curve requires at least 3 points!'); return false } const startPoint = polyline[0]; const bezierCurveLineNum = polyline.length - 1; const bezierCurvePoints = new Array(bezierCurveLineNum).fill(0).map(function (foo, i) { return [].concat((0, _toConsumableArray2.default)(getBezierCurveLineControlPoints(polyline, i, close, offsetA, offsetB)), [polyline[i + 1]]) }); if (close)closeBezierCurve(bezierCurvePoints, startPoint); bezierCurvePoints.unshift(polyline[0]); return bezierCurvePoints } function getBezierCurveLineControlPoints (polyline, index) { const close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const offsetA = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.25; const offsetB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.25; const pointNum = polyline.length; if (pointNum < 3 || index >= pointNum) return; let beforePointIndex = index - 1; if (beforePointIndex < 0)beforePointIndex = close ? pointNum + beforePointIndex : 0; let afterPointIndex = index + 1; if (afterPointIndex >= pointNum)afterPointIndex = close ? afterPointIndex - pointNum : pointNum - 1; let afterNextPointIndex = index + 2; if (afterNextPointIndex >= pointNum)afterNextPointIndex = close ? afterNextPointIndex - pointNum : pointNum - 1; const pointBefore = polyline[beforePointIndex]; const pointMiddle = polyline[index]; const pointAfter = polyline[afterPointIndex]; const pointAfterNext = polyline[afterNextPointIndex]; return [[pointMiddle[0] + offsetA * (pointAfter[0] - pointBefore[0]), pointMiddle[1] + offsetA * (pointAfter[1] - pointBefore[1])], [pointAfter[0] - offsetB * (pointAfterNext[0] - pointMiddle[0]), pointAfter[1] - offsetB * (pointAfterNext[1] - pointMiddle[1])]] } function closeBezierCurve (bezierCurve, startPoint) { const firstSubCurve = bezierCurve[0]; const lastSubCurve = bezierCurve.slice(-1)[0]; bezierCurve.push([getSymmetryPoint(lastSubCurve[1], lastSubCurve[2]), getSymmetryPoint(firstSubCurve[0], startPoint), startPoint]); return bezierCurve } function getSymmetryPoint (point, centerPoint) { const _point = (0, _slicedToArray2.default)(point, 2); const px = _point[0]; const py = _point[1]; const _centerPoint = (0, _slicedToArray2.default)(centerPoint, 2); const cx = _centerPoint[0]; const cy = _centerPoint[1]; const minusX = cx - px; const minusY = cy - py; return [cx + minusX, cy + minusY] } const _default = polylineToBezierCurve; exports.default = _default }, { '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42 }], 47: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); Object.defineProperty(exports, 'bezierCurveToPolyline', { enumerable: true, get: function get () { return _bezierCurveToPolyline.bezierCurveToPolyline } }); Object.defineProperty(exports, 'getBezierCurveLength', { enumerable: true, get: function get () { return _bezierCurveToPolyline.getBezierCurveLength } }); Object.defineProperty(exports, 'polylineToBezierCurve', { enumerable: true, get: function get () { return _polylineToBezierCurve.default } }); exports.default = void 0; var _bezierCurveToPolyline = require('./core/bezierCurveToPolyline'); var _polylineToBezierCurve = _interopRequireDefault(require('./core/polylineToBezierCurve')); const _default = { bezierCurveToPolyline: _bezierCurveToPolyline.bezierCurveToPolyline, getBezierCurveLength: _bezierCurveToPolyline.getBezierCurveLength, polylineToBezierCurve: _polylineToBezierCurve.default }; exports.default = _default }, { './core/bezierCurveToPolyline': 45, './core/polylineToBezierCurve': 46, '@babel/runtime/helpers/interopRequireDefault': 36 }], 48: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _classCallCheck2 = _interopRequireDefault(require('@babel/runtime/helpers/classCallCheck')); const _color = _interopRequireDefault(require('@jiaminghi/color')); const _bezierCurve = _interopRequireDefault(require('@jiaminghi/bezier-curve')); const _util = require('../plugin/util'); const _graphs = _interopRequireDefault(require('../config/graphs')); const _graph = _interopRequireDefault(require('./graph.class')); function ownKeys (object, enumerableOnly) { const keys = Object.keys(object); if (Object.getOwnPropertySymbols) { let symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly)symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread (target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } const CRender = function CRender (canvas) { (0, _classCallCheck2.default)(this, CRender); if (!canvas) { console.error('CRender Missing parameters!'); return } const ctx = canvas.getContext('2d'); const clientWidth = canvas.clientWidth; const clientHeight = canvas.clientHeight; const area = [clientWidth, clientHeight]; canvas.setAttribute('width', clientWidth); canvas.setAttribute('height', clientHeight); this.ctx = ctx; this.area = area; this.animationStatus = false; this.graphs = []; this.color = _color.default; this.bezierCurve = _bezierCurve.default; canvas.addEventListener('mousedown', mouseDown.bind(this)); canvas.addEventListener('mousemove', mouseMove.bind(this)); canvas.addEventListener('mouseup', mouseUp.bind(this)) }; exports.default = CRender; CRender.prototype.clearArea = function () { let _this$ctx; const area = this.area; (_this$ctx = this.ctx).clearRect.apply(_this$ctx, [0, 0].concat((0, _toConsumableArray2.default)(area))) }; CRender.prototype.add = function () { const config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; const name = config.name; if (!name) { console.error('add Missing parameters!'); return } const graphConfig = _graphs.default.get(name); if (!graphConfig) { console.warn('No corresponding graph configuration found!'); return } const graph = new _graph.default(graphConfig, config); if (!graph.validator(graph)) return; graph.render = this; this.graphs.push(graph); this.sortGraphsByIndex(); this.drawAllGraph(); return graph }; CRender.prototype.sortGraphsByIndex = function () { const graphs = this.graphs; graphs.sort(function (a, b) { if (a.index > b.index) return 1; if (a.index === b.index) return 0; if (a.index < b.index) return -1 }) }; CRender.prototype.delGraph = function (graph) { if (typeof graph.delProcessor !== 'function') return; graph.delProcessor(this); this.graphs = this.graphs.filter(function (graph) { return graph }); this.drawAllGraph() }; CRender.prototype.delAllGraph = function () { const _this = this; this.graphs.forEach(function (graph) { return graph.delProcessor(_this) }); this.graphs = this.graphs.filter(function (graph) { return graph }); this.drawAllGraph() }; CRender.prototype.drawAllGraph = function () { const _this2 = this; this.clearArea(); this.graphs.filter(function (graph) { return graph && graph.visible }).forEach(function (graph) { return graph.drawProcessor(_this2, graph) }) }; CRender.prototype.launchAnimation = function () { const _this3 = this; const animationStatus = this.animationStatus; if (animationStatus) return; this.animationStatus = true; return new Promise(function (resolve) { animation.call(_this3, function () { _this3.animationStatus = false; resolve() }, Date.now()) }) }; function animation (callback, timeStamp) { const graphs = this.graphs; if (!animationAble(graphs)) { callback(); return }graphs.forEach(function (graph) { return graph.turnNextAnimationFrame(timeStamp) }); this.drawAllGraph(); requestAnimationFrame(animation.bind(this, callback, timeStamp)) } function animationAble (graphs) { return graphs.find(function (graph) { return !graph.animationPause && graph.animationFrameState.length }) } function mouseDown (e) { const graphs = this.graphs; const hoverGraph = graphs.find(function (graph) { return graph.status === 'hover' }); if (!hoverGraph) return; hoverGraph.status = 'active' } function mouseMove (e) { const offsetX = e.offsetX; const offsetY = e.offsetY; const position = [offsetX, offsetY]; const graphs = this.graphs; const activeGraph = graphs.find(function (graph) { return graph.status === 'active' || graph.status === 'drag' }); if (activeGraph) { if (!activeGraph.drag) return; if (typeof activeGraph.move !== 'function') { console.error('No move method is provided, cannot be dragged!'); return }activeGraph.moveProcessor(e); activeGraph.status = 'drag'; return } const hoverGraph = graphs.find(function (graph) { return graph.status === 'hover' }); const hoverAbleGraphs = graphs.filter(function (graph) { return graph.hover && (typeof graph.hoverCheck === 'function' || graph.hoverRect) }); const hoveredGraph = hoverAbleGraphs.find(function (graph) { return graph.hoverCheckProcessor(position, graph) }); if (hoveredGraph) { document.body.style.cursor = hoveredGraph.style.hoverCursor } else { document.body.style.cursor = 'default' } let hoverGraphMouseOuterIsFun = false; let hoveredGraphMouseEnterIsFun = false; if (hoverGraph)hoverGraphMouseOuterIsFun = typeof hoverGraph.mouseOuter === 'function'; if (hoveredGraph)hoveredGraphMouseEnterIsFun = typeof hoveredGraph.mouseEnter === 'function'; if (!hoveredGraph && !hoverGraph) return; if (!hoveredGraph && hoverGraph) { if (hoverGraphMouseOuterIsFun)hoverGraph.mouseOuter(e, hoverGraph); hoverGraph.status = 'static'; return } if (hoveredGraph && hoveredGraph === hoverGraph) return; if (hoveredGraph && !hoverGraph) { if (hoveredGraphMouseEnterIsFun)hoveredGraph.mouseEnter(e, hoveredGraph); hoveredGraph.status = 'hover'; return } if (hoveredGraph && hoverGraph && hoveredGraph !== hoverGraph) { if (hoverGraphMouseOuterIsFun)hoverGraph.mouseOuter(e, hoverGraph); hoverGraph.status = 'static'; if (hoveredGraphMouseEnterIsFun)hoveredGraph.mouseEnter(e, hoveredGraph); hoveredGraph.status = 'hover' } } function mouseUp (e) { const graphs = this.graphs; const activeGraph = graphs.find(function (graph) { return graph.status === 'active' }); const dragGraph = graphs.find(function (graph) { return graph.status === 'drag' }); if (activeGraph && typeof activeGraph.click === 'function')activeGraph.click(e, activeGraph); graphs.forEach(function (graph) { return graph && (graph.status = 'static') }); if (activeGraph)activeGraph.status = 'hover'; if (dragGraph)dragGraph.status = 'hover' }CRender.prototype.clone = function (graph) { const style = graph.style.getStyle(); let clonedGraph = _objectSpread({}, graph, { style: style }); delete clonedGraph.render; clonedGraph = (0, _util.deepClone)(clonedGraph, true); return this.add(clonedGraph) } }, { '../config/graphs': 51, '../plugin/util': 54, './graph.class': 49, '@babel/runtime/helpers/classCallCheck': 34, '@babel/runtime/helpers/defineProperty': 35, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/toConsumableArray': 42, '@jiaminghi/bezier-curve': 47, '@jiaminghi/color': 56 }], 49: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _regenerator = _interopRequireDefault(require('@babel/runtime/regenerator')); const _asyncToGenerator2 = _interopRequireDefault(require('@babel/runtime/helpers/asyncToGenerator')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _classCallCheck2 = _interopRequireDefault(require('@babel/runtime/helpers/classCallCheck')); const _style = _interopRequireDefault(require('./style.class')); const _transition = _interopRequireDefault(require('@jiaminghi/transition')); const _util = require('../plugin/util'); const Graph = function Graph (graph, config) { (0, _classCallCheck2.default)(this, Graph); config = (0, _util.deepClone)(config, true); const defaultConfig = { visible: true, drag: false, hover: false, index: 1, animationDelay: 0, animationFrame: 30, animationCurve: 'linear', animationPause: false, hoverRect: null, mouseEnter: null, mouseOuter: null, click: null }; const configAbleNot = { status: 'static', animationRoot: [], animationKeys: [], animationFrameState: [], cache: {} }; if (!config.shape)config.shape = {}; if (!config.style)config.style = {}; const shape = Object.assign({}, graph.shape, config.shape); Object.assign(defaultConfig, config, configAbleNot); Object.assign(this, graph, defaultConfig); this.shape = shape; this.style = new _style.default(config.style); this.addedProcessor() }; exports.default = Graph; Graph.prototype.addedProcessor = function () { if (typeof this.setGraphCenter === 'function') this.setGraphCenter(null, this); if (typeof this.added === 'function') this.added(this) }; Graph.prototype.drawProcessor = function (render, graph) { const ctx = render.ctx; graph.style.initStyle(ctx); if (typeof this.beforeDraw === 'function') this.beforeDraw(this, render); graph.draw(render, graph); if (typeof this.drawed === 'function') this.drawed(this, render); graph.style.restoreTransform(ctx) }; Graph.prototype.hoverCheckProcessor = function (position, _ref) { const hoverRect = _ref.hoverRect; const style = _ref.style; const hoverCheck = _ref.hoverCheck; const graphCenter = style.graphCenter; const rotate = style.rotate; const scale = style.scale; const translate = style.translate; if (graphCenter) { if (rotate)position = (0, _util.getRotatePointPos)(-rotate, position, graphCenter); if (scale)position = (0, _util.getScalePointPos)(scale.map(function (s) { return 1 / s }), position, graphCenter); if (translate)position = (0, _util.getTranslatePointPos)(translate.map(function (v) { return v * -1 }), position) } if (hoverRect) return _util.checkPointIsInRect.apply(void 0, [position].concat((0, _toConsumableArray2.default)(hoverRect))); return hoverCheck(position, this) }; Graph.prototype.moveProcessor = function (e) { this.move(e, this); if (typeof this.beforeMove === 'function') this.beforeMove(e, this); if (typeof this.setGraphCenter === 'function') this.setGraphCenter(e, this); if (typeof this.moved === 'function') this.moved(e, this) }; Graph.prototype.attr = function (attrName) { let change = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined; if (!attrName || change === undefined) return false; const isObject = (0, _typeof2.default)(this[attrName]) === 'object'; if (isObject)change = (0, _util.deepClone)(change, true); const render = this.render; if (attrName === 'style') { this.style.update(change) } else if (isObject) { Object.assign(this[attrName], change) } else { this[attrName] = change } if (attrName === 'index')render.sortGraphsByIndex(); render.drawAllGraph() }; Graph.prototype.animation = (function () { const _ref2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2 (attrName, change) { let wait; let changeRoot; let changeKeys; let beforeState; let animationFrame; let animationCurve; let animationDelay; let animationFrameState; let render; const _args2 = arguments; return _regenerator.default.wrap(function _callee2$ (_context2) { while (1) { switch (_context2.prev = _context2.next) { case 0:wait = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false; if (!(attrName !== 'shape' && attrName !== 'style')) { _context2.next = 4; break }console.error('Only supported shape and style animation!'); return _context2.abrupt('return'); case 4:change = (0, _util.deepClone)(change, true); if (attrName === 'style') this.style.colorProcessor(change); changeRoot = this[attrName]; changeKeys = Object.keys(change); beforeState = {}; changeKeys.forEach(function (key) { return beforeState[key] = changeRoot[key] }); animationFrame = this.animationFrame, animationCurve = this.animationCurve, animationDelay = this.animationDelay; animationFrameState = (0, _transition.default)(animationCurve, beforeState, change, animationFrame, true); this.animationRoot.push(changeRoot); this.animationKeys.push(changeKeys); this.animationFrameState.push(animationFrameState); if (!wait) { _context2.next = 17; break } return _context2.abrupt('return'); case 17:if (!(animationDelay > 0)) { _context2.next = 20; break }_context2.next = 20; return delay(animationDelay); case 20:render = this.render; return _context2.abrupt('return', new Promise(function () { const _ref3 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee (resolve) { return _regenerator.default.wrap(function _callee$ (_context) { while (1) { switch (_context.prev = _context.next) { case 0:_context.next = 2; return render.launchAnimation(); case 2:resolve(); case 3:case 'end':return _context.stop() } } }, _callee) })); return function (_x3) { return _ref3.apply(this, arguments) } }())); case 22:case 'end':return _context2.stop() } } }, _callee2, this) })); return function (_x, _x2) { return _ref2.apply(this, arguments) } }()); Graph.prototype.turnNextAnimationFrame = function (timeStamp) { const animationDelay = this.animationDelay; const animationRoot = this.animationRoot; const animationKeys = this.animationKeys; const animationFrameState = this.animationFrameState; const animationPause = this.animationPause; if (animationPause) return; if (Date.now() - timeStamp < animationDelay) return; animationRoot.forEach(function (root, i) { animationKeys[i].forEach(function (key) { root[key] = animationFrameState[i][0][key] }) }); animationFrameState.forEach(function (stateItem, i) { stateItem.shift(); const noFrame = stateItem.length === 0; if (noFrame)animationRoot[i] = null; if (noFrame)animationKeys[i] = null }); this.animationFrameState = animationFrameState.filter(function (state) { return state.length }); this.animationRoot = animationRoot.filter(function (root) { return root }); this.animationKeys = animationKeys.filter(function (keys) { return keys }) }; Graph.prototype.animationEnd = function () { const animationFrameState = this.animationFrameState; const animationKeys = this.animationKeys; const animationRoot = this.animationRoot; const render = this.render; animationRoot.forEach(function (root, i) { const currentKeys = animationKeys[i]; const lastState = animationFrameState[i].pop(); currentKeys.forEach(function (key) { return root[key] = lastState[key] }) }); this.animationFrameState = []; this.animationKeys = []; this.animationRoot = []; return render.drawAllGraph() }; Graph.prototype.pauseAnimation = function () { this.attr('animationPause', true) }; Graph.prototype.playAnimation = function () { const render = this.render; this.attr('animationPause', false); return new Promise(function () { const _ref4 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3 (resolve) { return _regenerator.default.wrap(function _callee3$ (_context3) { while (1) { switch (_context3.prev = _context3.next) { case 0:_context3.next = 2; return render.launchAnimation(); case 2:resolve(); case 3:case 'end':return _context3.stop() } } }, _callee3) })); return function (_x4) { return _ref4.apply(this, arguments) } }()) }; Graph.prototype.delProcessor = function (render) { const _this = this; const graphs = render.graphs; const index = graphs.findIndex(function (graph) { return graph === _this }); if (index === -1) return; if (typeof this.beforeDelete === 'function') this.beforeDelete(this); graphs.splice(index, 1, null); if (typeof this.deleted === 'function') this.deleted(this) }; function delay (time) { return new Promise(function (resolve) { setTimeout(resolve, time) }) } }, { '../plugin/util': 54, './style.class': 50, '@babel/runtime/helpers/asyncToGenerator': 33, '@babel/runtime/helpers/classCallCheck': 34, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/toConsumableArray': 42, '@babel/runtime/helpers/typeof': 43, '@babel/runtime/regenerator': 44, '@jiaminghi/transition': 58 }], 50: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _classCallCheck2 = _interopRequireDefault(require('@babel/runtime/helpers/classCallCheck')); const _color = require('@jiaminghi/color'); const _util = require('../plugin/util'); const Style = function Style (style) { (0, _classCallCheck2.default)(this, Style); this.colorProcessor(style); const defaultStyle = { fill: [0, 0, 0, 1], stroke: [0, 0, 0, 0], opacity: 1, lineCap: null, lineJoin: null, lineDash: null, lineDashOffset: null, shadowBlur: 0, shadowColor: [0, 0, 0, 0], shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 0, graphCenter: null, scale: null, rotate: null, translate: null, hoverCursor: 'pointer', fontStyle: 'normal', fontVarient: 'normal', fontWeight: 'normal', fontSize: 10, fontFamily: 'Arial', textAlign: 'center', textBaseline: 'middle', gradientColor: null, gradientType: 'linear', gradientParams: null, gradientWith: 'stroke', gradientStops: 'auto', colors: null }; Object.assign(this, defaultStyle, style) }; exports.default = Style; Style.prototype.colorProcessor = function (style) { const reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; const processor = reverse ? _color.getColorFromRgbValue : _color.getRgbaValue; const colorProcessorKeys = ['fill', 'stroke', 'shadowColor']; const allKeys = Object.keys(style); const colorKeys = allKeys.filter(function (key) { return colorProcessorKeys.find(function (k) { return k === key }) }); colorKeys.forEach(function (key) { return style[key] = processor(style[key]) }); const gradientColor = style.gradientColor; const colors = style.colors; if (gradientColor)style.gradientColor = gradientColor.map(function (c) { return processor(c) }); if (colors) { const colorsKeys = Object.keys(colors); colorsKeys.forEach(function (key) { return colors[key] = processor(colors[key]) }) } }; Style.prototype.initStyle = function (ctx) { initTransform(ctx, this); initGraphStyle(ctx, this); initGradient(ctx, this) }; function initTransform (ctx, style) { ctx.save(); const graphCenter = style.graphCenter; const rotate = style.rotate; const scale = style.scale; const translate = style.translate; if (!(graphCenter instanceof Array)) return; ctx.translate.apply(ctx, (0, _toConsumableArray2.default)(graphCenter)); if (rotate)ctx.rotate(rotate * Math.PI / 180); if (scale instanceof Array)ctx.scale.apply(ctx, (0, _toConsumableArray2.default)(scale)); if (translate)ctx.translate.apply(ctx, (0, _toConsumableArray2.default)(translate)); ctx.translate(-graphCenter[0], -graphCenter[1]) } const autoSetStyleKeys = ['lineCap', 'lineJoin', 'lineDashOffset', 'shadowOffsetX', 'shadowOffsetY', 'lineWidth', 'textAlign', 'textBaseline']; function initGraphStyle (ctx, style) { let fill = style.fill; let stroke = style.stroke; let shadowColor = style.shadowColor; const opacity = style.opacity; autoSetStyleKeys.forEach(function (key) { if (key || typeof key === 'number')ctx[key] = style[key] }); fill = (0, _toConsumableArray2.default)(fill); stroke = (0, _toConsumableArray2.default)(stroke); shadowColor = (0, _toConsumableArray2.default)(shadowColor); fill[3] *= opacity; stroke[3] *= opacity; shadowColor[3] *= opacity; ctx.fillStyle = (0, _color.getColorFromRgbValue)(fill); ctx.strokeStyle = (0, _color.getColorFromRgbValue)(stroke); ctx.shadowColor = (0, _color.getColorFromRgbValue)(shadowColor); let lineDash = style.lineDash; const shadowBlur = style.shadowBlur; if (lineDash) { lineDash = lineDash.map(function (v) { return v >= 0 ? v : 0 }); ctx.setLineDash(lineDash) } if (typeof shadowBlur === 'number')ctx.shadowBlur = shadowBlur > 0 ? shadowBlur : 0.001; const fontStyle = style.fontStyle; const fontVarient = style.fontVarient; const fontWeight = style.fontWeight; const fontSize = style.fontSize; const fontFamily = style.fontFamily; ctx.font = fontStyle + ' ' + fontVarient + ' ' + fontWeight + ' ' + fontSize + 'px' + ' ' + fontFamily } function initGradient (ctx, style) { if (!gradientValidator(style)) return; let gradientColor = style.gradientColor; const gradientParams = style.gradientParams; const gradientType = style.gradientType; const gradientWith = style.gradientWith; let gradientStops = style.gradientStops; const opacity = style.opacity; gradientColor = gradientColor.map(function (color) { const colorOpacity = color[3] * opacity; const clonedColor = (0, _toConsumableArray2.default)(color); clonedColor[3] = colorOpacity; return clonedColor }); gradientColor = gradientColor.map(function (c) { return (0, _color.getColorFromRgbValue)(c) }); if (gradientStops === 'auto')gradientStops = getAutoColorStops(gradientColor); const gradient = ctx['create'.concat(gradientType.slice(0, 1).toUpperCase() + gradientType.slice(1), 'Gradient')].apply(ctx, (0, _toConsumableArray2.default)(gradientParams)); gradientStops.forEach(function (stop, i) { return gradient.addColorStop(stop, gradientColor[i]) }); ctx[''.concat(gradientWith, 'Style')] = gradient } function gradientValidator (style) { const gradientColor = style.gradientColor; const gradientParams = style.gradientParams; const gradientType = style.gradientType; const gradientWith = style.gradientWith; const gradientStops = style.gradientStops; if (!gradientColor || !gradientParams) return false; if (gradientColor.length === 1) { console.warn('The gradient needs to provide at least two colors'); return false } if (gradientType !== 'linear' && gradientType !== 'radial') { console.warn('GradientType only supports linear or radial, current value is ' + gradientType); return false } const gradientParamsLength = gradientParams.length; if (gradientType === 'linear' && gradientParamsLength !== 4 || gradientType === 'radial' && gradientParamsLength !== 6) { console.warn('The expected length of gradientParams is ' + (gradientType === 'linear' ? '4' : '6')); return false } if (gradientWith !== 'fill' && gradientWith !== 'stroke') { console.warn('GradientWith only supports fill or stroke, current value is ' + gradientWith); return false } if (gradientStops !== 'auto' && !(gradientStops instanceof Array)) { console.warn("gradientStops only supports 'auto' or Number Array ([0, .5, 1]), current value is " + gradientStops); return false } return true } function getAutoColorStops (color) { const stopGap = 1 / (color.length - 1); return color.map(function (foo, i) { return stopGap * i }) }Style.prototype.restoreTransform = function (ctx) { ctx.restore() }; Style.prototype.update = function (change) { this.colorProcessor(change); Object.assign(this, change) }; Style.prototype.getStyle = function () { const clonedStyle = (0, _util.deepClone)(this, true); this.colorProcessor(clonedStyle, true); return clonedStyle } }, { '../plugin/util': 54, '@babel/runtime/helpers/classCallCheck': 34, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/toConsumableArray': 42, '@jiaminghi/color': 56 }], 51: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.extendNewGraph = extendNewGraph; exports.default = exports.text = exports.bezierCurve = exports.smoothline = exports.polyline = exports.regPolygon = exports.sector = exports.arc = exports.ring = exports.rect = exports.ellipse = exports.circle = void 0; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _bezierCurve2 = _interopRequireDefault(require('@jiaminghi/bezier-curve')); const _util = require('../plugin/util'); const _canvas = require('../plugin/canvas'); const polylineToBezierCurve = _bezierCurve2.default.polylineToBezierCurve; const bezierCurveToPolyline = _bezierCurve2.default.bezierCurveToPolyline; const circle = { shape: { rx: 0, ry: 0, r: 0 }, validator: function validator (_ref) { const shape = _ref.shape; const rx = shape.rx; const ry = shape.ry; const r = shape.r; if (typeof rx !== 'number' || typeof ry !== 'number' || typeof r !== 'number') { console.error('Circle shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref2, _ref3) { const ctx = _ref2.ctx; const shape = _ref3.shape; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const r = shape.r; ctx.arc(rx, ry, r > 0 ? r : 0.01, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref4) { const shape = _ref4.shape; const rx = shape.rx; const ry = shape.ry; const r = shape.r; return (0, _util.checkPointIsInCircle)(position, rx, ry, r) }, setGraphCenter: function setGraphCenter (e, _ref5) { const shape = _ref5.shape; const style = _ref5.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref6, _ref7) { const movementX = _ref6.movementX; const movementY = _ref6.movementY; const shape = _ref7.shape; this.attr('shape', { rx: shape.rx + movementX, ry: shape.ry + movementY }) } }; exports.circle = circle; const ellipse = { shape: { rx: 0, ry: 0, hr: 0, vr: 0 }, validator: function validator (_ref8) { const shape = _ref8.shape; const rx = shape.rx; const ry = shape.ry; const hr = shape.hr; const vr = shape.vr; if (typeof rx !== 'number' || typeof ry !== 'number' || typeof hr !== 'number' || typeof vr !== 'number') { console.error('Ellipse shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref9, _ref10) { const ctx = _ref9.ctx; const shape = _ref10.shape; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const hr = shape.hr; const vr = shape.vr; ctx.ellipse(rx, ry, hr > 0 ? hr : 0.01, vr > 0 ? vr : 0.01, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref11) { const shape = _ref11.shape; const rx = shape.rx; const ry = shape.ry; const hr = shape.hr; const vr = shape.vr; const a = Math.max(hr, vr); const b = Math.min(hr, vr); const c = Math.sqrt(a * a - b * b); const leftFocusPoint = [rx - c, ry]; const rightFocusPoint = [rx + c, ry]; const distance = (0, _util.getTwoPointDistance)(position, leftFocusPoint) + (0, _util.getTwoPointDistance)(position, rightFocusPoint); return distance <= 2 * a }, setGraphCenter: function setGraphCenter (e, _ref12) { const shape = _ref12.shape; const style = _ref12.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref13, _ref14) { const movementX = _ref13.movementX; const movementY = _ref13.movementY; const shape = _ref14.shape; this.attr('shape', { rx: shape.rx + movementX, ry: shape.ry + movementY }) } }; exports.ellipse = ellipse; const rect = { shape: { x: 0, y: 0, w: 0, h: 0 }, validator: function validator (_ref15) { const shape = _ref15.shape; const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; if (typeof x !== 'number' || typeof y !== 'number' || typeof w !== 'number' || typeof h !== 'number') { console.error('Rect shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref16, _ref17) { const ctx = _ref16.ctx; const shape = _ref17.shape; ctx.beginPath(); const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; ctx.rect(x, y, w, h); ctx.fill(); ctx.stroke(); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref18) { const shape = _ref18.shape; const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; return (0, _util.checkPointIsInRect)(position, x, y, w, h) }, setGraphCenter: function setGraphCenter (e, _ref19) { const shape = _ref19.shape; const style = _ref19.style; const x = shape.x; const y = shape.y; const w = shape.w; const h = shape.h; style.graphCenter = [x + w / 2, y + h / 2] }, move: function move (_ref20, _ref21) { const movementX = _ref20.movementX; const movementY = _ref20.movementY; const shape = _ref21.shape; this.attr('shape', { x: shape.x + movementX, y: shape.y + movementY }) } }; exports.rect = rect; const ring = { shape: { rx: 0, ry: 0, r: 0 }, validator: function validator (_ref22) { const shape = _ref22.shape; const rx = shape.rx; const ry = shape.ry; const r = shape.r; if (typeof rx !== 'number' || typeof ry !== 'number' || typeof r !== 'number') { console.error('Ring shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref23, _ref24) { const ctx = _ref23.ctx; const shape = _ref24.shape; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const r = shape.r; ctx.arc(rx, ry, r > 0 ? r : 0.01, 0, Math.PI * 2); ctx.stroke(); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref25) { const shape = _ref25.shape; const style = _ref25.style; const rx = shape.rx; const ry = shape.ry; const r = shape.r; const lineWidth = style.lineWidth; const halfLineWidth = lineWidth / 2; const minDistance = r - halfLineWidth; const maxDistance = r + halfLineWidth; const distance = (0, _util.getTwoPointDistance)(position, [rx, ry]); return distance >= minDistance && distance <= maxDistance }, setGraphCenter: function setGraphCenter (e, _ref26) { const shape = _ref26.shape; const style = _ref26.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref27, _ref28) { const movementX = _ref27.movementX; const movementY = _ref27.movementY; const shape = _ref28.shape; this.attr('shape', { rx: shape.rx + movementX, ry: shape.ry + movementY }) } }; exports.ring = ring; const arc = { shape: { rx: 0, ry: 0, r: 0, startAngle: 0, endAngle: 0, clockWise: true }, validator: function validator (_ref29) { const shape = _ref29.shape; const keys = ['rx', 'ry', 'r', 'startAngle', 'endAngle']; if (keys.find(function (key) { return typeof shape[key] !== 'number' })) { console.error('Arc shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref30, _ref31) { const ctx = _ref30.ctx; const shape = _ref31.shape; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const r = shape.r; const startAngle = shape.startAngle; const endAngle = shape.endAngle; const clockWise = shape.clockWise; ctx.arc(rx, ry, r > 0 ? r : 0.001, startAngle, endAngle, !clockWise); ctx.stroke(); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref32) { const shape = _ref32.shape; const style = _ref32.style; const rx = shape.rx; const ry = shape.ry; const r = shape.r; const startAngle = shape.startAngle; const endAngle = shape.endAngle; const clockWise = shape.clockWise; const lineWidth = style.lineWidth; const halfLineWidth = lineWidth / 2; const insideRadius = r - halfLineWidth; const outsideRadius = r + halfLineWidth; return !(0, _util.checkPointIsInSector)(position, rx, ry, insideRadius, startAngle, endAngle, clockWise) && (0, _util.checkPointIsInSector)(position, rx, ry, outsideRadius, startAngle, endAngle, clockWise) }, setGraphCenter: function setGraphCenter (e, _ref33) { const shape = _ref33.shape; const style = _ref33.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref34, _ref35) { const movementX = _ref34.movementX; const movementY = _ref34.movementY; const shape = _ref35.shape; this.attr('shape', { rx: shape.rx + movementX, ry: shape.ry + movementY }) } }; exports.arc = arc; const sector = { shape: { rx: 0, ry: 0, r: 0, startAngle: 0, endAngle: 0, clockWise: true }, validator: function validator (_ref36) { const shape = _ref36.shape; const keys = ['rx', 'ry', 'r', 'startAngle', 'endAngle']; if (keys.find(function (key) { return typeof shape[key] !== 'number' })) { console.error('Sector shape configuration is abnormal!'); return false } return true }, draw: function draw (_ref37, _ref38) { const ctx = _ref37.ctx; const shape = _ref38.shape; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const r = shape.r; const startAngle = shape.startAngle; const endAngle = shape.endAngle; const clockWise = shape.clockWise; ctx.arc(rx, ry, r > 0 ? r : 0.01, startAngle, endAngle, !clockWise); ctx.lineTo(rx, ry); ctx.closePath(); ctx.stroke(); ctx.fill() }, hoverCheck: function hoverCheck (position, _ref39) { const shape = _ref39.shape; const rx = shape.rx; const ry = shape.ry; const r = shape.r; const startAngle = shape.startAngle; const endAngle = shape.endAngle; const clockWise = shape.clockWise; return (0, _util.checkPointIsInSector)(position, rx, ry, r, startAngle, endAngle, clockWise) }, setGraphCenter: function setGraphCenter (e, _ref40) { const shape = _ref40.shape; const style = _ref40.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref41, _ref42) { const movementX = _ref41.movementX; const movementY = _ref41.movementY; const shape = _ref42.shape; const rx = shape.rx; const ry = shape.ry; this.attr('shape', { rx: rx + movementX, ry: ry + movementY }) } }; exports.sector = sector; const regPolygon = { shape: { rx: 0, ry: 0, r: 0, side: 0 }, validator: function validator (_ref43) { const shape = _ref43.shape; const side = shape.side; const keys = ['rx', 'ry', 'r', 'side']; if (keys.find(function (key) { return typeof shape[key] !== 'number' })) { console.error('RegPolygon shape configuration is abnormal!'); return false } if (side < 3) { console.error('RegPolygon at least trigon!'); return false } return true }, draw: function draw (_ref44, _ref45) { const ctx = _ref44.ctx; const shape = _ref45.shape; const cache = _ref45.cache; ctx.beginPath(); const rx = shape.rx; const ry = shape.ry; const r = shape.r; const side = shape.side; if (!cache.points || cache.rx !== rx || cache.ry !== ry || cache.r !== r || cache.side !== side) { const _points = (0, _util.getRegularPolygonPoints)(rx, ry, r, side); Object.assign(cache, { points: _points, rx: rx, ry: ry, r: r, side: side }) } const points = cache.points; (0, _canvas.drawPolylinePath)(ctx, points); ctx.closePath(); ctx.stroke(); ctx.fill() }, hoverCheck: function hoverCheck (position, _ref46) { const cache = _ref46.cache; const points = cache.points; return (0, _util.checkPointIsInPolygon)(position, points) }, setGraphCenter: function setGraphCenter (e, _ref47) { const shape = _ref47.shape; const style = _ref47.style; const rx = shape.rx; const ry = shape.ry; style.graphCenter = [rx, ry] }, move: function move (_ref48, _ref49) { const movementX = _ref48.movementX; const movementY = _ref48.movementY; const shape = _ref49.shape; const cache = _ref49.cache; const rx = shape.rx; const ry = shape.ry; cache.rx += movementX; cache.ry += movementY; this.attr('shape', { rx: rx + movementX, ry: ry + movementY }); cache.points = cache.points.map(function (_ref50) { const _ref51 = (0, _slicedToArray2.default)(_ref50, 2); const x = _ref51[0]; const y = _ref51[1]; return [x + movementX, y + movementY] }) } }; exports.regPolygon = regPolygon; const polyline = { shape: { points: [], close: false }, validator: function validator (_ref52) { const shape = _ref52.shape; const points = shape.points; if (!(points instanceof Array)) { console.error('Polyline points should be an array!'); return false } return true }, draw: function draw (_ref53, _ref54) { const ctx = _ref53.ctx; const shape = _ref54.shape; const lineWidth = _ref54.style.lineWidth; ctx.beginPath(); let points = shape.points; const close = shape.close; if (lineWidth === 1)points = (0, _util.eliminateBlur)(points); (0, _canvas.drawPolylinePath)(ctx, points); if (close) { ctx.closePath(); ctx.fill(); ctx.stroke() } else { ctx.stroke() } }, hoverCheck: function hoverCheck (position, _ref55) { const shape = _ref55.shape; const style = _ref55.style; const points = shape.points; const close = shape.close; const lineWidth = style.lineWidth; if (close) { return (0, _util.checkPointIsInPolygon)(position, points) } else { return (0, _util.checkPointIsNearPolyline)(position, points, lineWidth) } }, setGraphCenter: function setGraphCenter (e, _ref56) { const shape = _ref56.shape; const style = _ref56.style; const points = shape.points; style.graphCenter = points[0] }, move: function move (_ref57, _ref58) { const movementX = _ref57.movementX; const movementY = _ref57.movementY; const shape = _ref58.shape; const points = shape.points; const moveAfterPoints = points.map(function (_ref59) { const _ref60 = (0, _slicedToArray2.default)(_ref59, 2); const x = _ref60[0]; const y = _ref60[1]; return [x + movementX, y + movementY] }); this.attr('shape', { points: moveAfterPoints }) } }; exports.polyline = polyline; const smoothline = { shape: { points: [], close: false }, validator: function validator (_ref61) { const shape = _ref61.shape; const points = shape.points; if (!(points instanceof Array)) { console.error('Smoothline points should be an array!'); return false } return true }, draw: function draw (_ref62, _ref63) { const ctx = _ref62.ctx; const shape = _ref63.shape; const cache = _ref63.cache; const points = shape.points; const close = shape.close; if (!cache.points || cache.points.toString() !== points.toString()) { const _bezierCurve = polylineToBezierCurve(points, close); const hoverPoints = bezierCurveToPolyline(_bezierCurve); Object.assign(cache, { points: (0, _util.deepClone)(points, true), bezierCurve: _bezierCurve, hoverPoints: hoverPoints }) } const bezierCurve = cache.bezierCurve; ctx.beginPath(); (0, _canvas.drawBezierCurvePath)(ctx, bezierCurve.slice(1), bezierCurve[0]); if (close) { ctx.closePath(); ctx.fill(); ctx.stroke() } else { ctx.stroke() } }, hoverCheck: function hoverCheck (position, _ref64) { const cache = _ref64.cache; const shape = _ref64.shape; const style = _ref64.style; const hoverPoints = cache.hoverPoints; const close = shape.close; const lineWidth = style.lineWidth; if (close) { return (0, _util.checkPointIsInPolygon)(position, hoverPoints) } else { return (0, _util.checkPointIsNearPolyline)(position, hoverPoints, lineWidth) } }, setGraphCenter: function setGraphCenter (e, _ref65) { const shape = _ref65.shape; const style = _ref65.style; const points = shape.points; style.graphCenter = points[0] }, move: function move (_ref66, _ref67) { const movementX = _ref66.movementX; const movementY = _ref66.movementY; const shape = _ref67.shape; const cache = _ref67.cache; const points = shape.points; const moveAfterPoints = points.map(function (_ref68) { const _ref69 = (0, _slicedToArray2.default)(_ref68, 2); const x = _ref69[0]; const y = _ref69[1]; return [x + movementX, y + movementY] }); cache.points = moveAfterPoints; const _cache$bezierCurve$ = (0, _slicedToArray2.default)(cache.bezierCurve[0], 2); const fx = _cache$bezierCurve$[0]; const fy = _cache$bezierCurve$[1]; const curves = cache.bezierCurve.slice(1); cache.bezierCurve = [[fx + movementX, fy + movementY]].concat((0, _toConsumableArray2.default)(curves.map(function (curve) { return curve.map(function (_ref70) { const _ref71 = (0, _slicedToArray2.default)(_ref70, 2); const x = _ref71[0]; const y = _ref71[1]; return [x + movementX, y + movementY] }) }))); cache.hoverPoints = cache.hoverPoints.map(function (_ref72) { const _ref73 = (0, _slicedToArray2.default)(_ref72, 2); const x = _ref73[0]; const y = _ref73[1]; return [x + movementX, y + movementY] }); this.attr('shape', { points: moveAfterPoints }) } }; exports.smoothline = smoothline; const bezierCurve = { shape: { points: [], close: false }, validator: function validator (_ref74) { const shape = _ref74.shape; const points = shape.points; if (!(points instanceof Array)) { console.error('BezierCurve points should be an array!'); return false } return true }, draw: function draw (_ref75, _ref76) { const ctx = _ref75.ctx; const shape = _ref76.shape; const cache = _ref76.cache; const points = shape.points; const close = shape.close; if (!cache.points || cache.points.toString() !== points.toString()) { const hoverPoints = bezierCurveToPolyline(points, 20); Object.assign(cache, { points: (0, _util.deepClone)(points, true), hoverPoints: hoverPoints }) }ctx.beginPath(); (0, _canvas.drawBezierCurvePath)(ctx, points.slice(1), points[0]); if (close) { ctx.closePath(); ctx.fill(); ctx.stroke() } else { ctx.stroke() } }, hoverCheck: function hoverCheck (position, _ref77) { const cache = _ref77.cache; const shape = _ref77.shape; const style = _ref77.style; const hoverPoints = cache.hoverPoints; const close = shape.close; const lineWidth = style.lineWidth; if (close) { return (0, _util.checkPointIsInPolygon)(position, hoverPoints) } else { return (0, _util.checkPointIsNearPolyline)(position, hoverPoints, lineWidth) } }, setGraphCenter: function setGraphCenter (e, _ref78) { const shape = _ref78.shape; const style = _ref78.style; const points = shape.points; style.graphCenter = points[0] }, move: function move (_ref79, _ref80) { const movementX = _ref79.movementX; const movementY = _ref79.movementY; const shape = _ref80.shape; const cache = _ref80.cache; const points = shape.points; const _points$ = (0, _slicedToArray2.default)(points[0], 2); const fx = _points$[0]; const fy = _points$[1]; const curves = points.slice(1); const bezierCurve = [[fx + movementX, fy + movementY]].concat((0, _toConsumableArray2.default)(curves.map(function (curve) { return curve.map(function (_ref81) { const _ref82 = (0, _slicedToArray2.default)(_ref81, 2); const x = _ref82[0]; const y = _ref82[1]; return [x + movementX, y + movementY] }) }))); cache.points = bezierCurve; cache.hoverPoints = cache.hoverPoints.map(function (_ref83) { const _ref84 = (0, _slicedToArray2.default)(_ref83, 2); const x = _ref84[0]; const y = _ref84[1]; return [x + movementX, y + movementY] }); this.attr('shape', { points: bezierCurve }) } }; exports.bezierCurve = bezierCurve; const text = { shape: { content: '', position: [], maxWidth: undefined, rowGap: 0 }, validator: function validator (_ref85) { const shape = _ref85.shape; const content = shape.content; const position = shape.position; const rowGap = shape.rowGap; if (typeof content !== 'string') { console.error('Text content should be a string!'); return false } if (!(position instanceof Array)) { console.error('Text position should be an array!'); return false } if (typeof rowGap !== 'number') { console.error('Text rowGap should be a number!'); return false } return true }, draw: function draw (_ref86, _ref87) { const ctx = _ref86.ctx; const shape = _ref87.shape; let content = shape.content; let position = shape.position; const maxWidth = shape.maxWidth; const rowGap = shape.rowGap; const textBaseline = ctx.textBaseline; const font = ctx.font; const fontSize = parseInt(font.replace(/\D/g, '')); const _position = position; const _position2 = (0, _slicedToArray2.default)(_position, 2); const x = _position2[0]; let y = _position2[1]; content = content.split('\n'); const rowNum = content.length; const lineHeight = fontSize + rowGap; const allHeight = rowNum * lineHeight - rowGap; let offset = 0; if (textBaseline === 'middle') { offset = allHeight / 2; y += fontSize / 2 } if (textBaseline === 'bottom') { offset = allHeight; y += fontSize }position = new Array(rowNum).fill(0).map(function (foo, i) { return [x, y + i * lineHeight - offset] }); ctx.beginPath(); content.forEach(function (text, i) { ctx.fillText.apply(ctx, [text].concat((0, _toConsumableArray2.default)(position[i]), [maxWidth])); ctx.strokeText.apply(ctx, [text].concat((0, _toConsumableArray2.default)(position[i]), [maxWidth])) }); ctx.closePath() }, hoverCheck: function hoverCheck (position, _ref88) { const shape = _ref88.shape; const style = _ref88.style; return false }, setGraphCenter: function setGraphCenter (e, _ref89) { const shape = _ref89.shape; const style = _ref89.style; const position = shape.position; style.graphCenter = (0, _toConsumableArray2.default)(position) }, move: function move (_ref90, _ref91) { const movementX = _ref90.movementX; const movementY = _ref90.movementY; const shape = _ref91.shape; const _shape$position = (0, _slicedToArray2.default)(shape.position, 2); const x = _shape$position[0]; const y = _shape$position[1]; this.attr('shape', { position: [x + movementX, y + movementY] }) } }; exports.text = text; const graphs = new Map([['circle', circle], ['ellipse', ellipse], ['rect', rect], ['ring', ring], ['arc', arc], ['sector', sector], ['regPolygon', regPolygon], ['polyline', polyline], ['smoothline', smoothline], ['bezierCurve', bezierCurve], ['text', text]]); const _default = graphs; exports.default = _default; function extendNewGraph (name, config) { if (!name || !config) { console.error('ExtendNewGraph Missing Parameters!'); return } if (!config.shape) { console.error('Required attribute of shape to extendNewGraph!'); return } if (!config.validator) { console.error('Required function of validator to extendNewGraph!'); return } if (!config.draw) { console.error('Required function of draw to extendNewGraph!'); return }graphs.set(name, config) } }, { '../plugin/canvas': 53, '../plugin/util': 54, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42, '@jiaminghi/bezier-curve': 47 }], 52: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); Object.defineProperty(exports, 'CRender', { enumerable: true, get: function get () { return _crender.default } }); Object.defineProperty(exports, 'extendNewGraph', { enumerable: true, get: function get () { return _graphs.extendNewGraph } }); exports.default = void 0; var _crender = _interopRequireDefault(require('./class/crender.class')); var _graphs = require('./config/graphs'); const _default = _crender.default; exports.default = _default }, { './class/crender.class': 48, './config/graphs': 51, '@babel/runtime/helpers/interopRequireDefault': 36 }], 53: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.drawPolylinePath = drawPolylinePath; exports.drawBezierCurvePath = drawBezierCurvePath; exports.default = void 0; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); function drawPolylinePath (ctx, points) { const beginPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const closePath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; if (!ctx || points.length < 2) return false; if (beginPath)ctx.beginPath(); points.forEach(function (point, i) { return point && (i === 0 ? ctx.moveTo.apply(ctx, (0, _toConsumableArray2.default)(point)) : ctx.lineTo.apply(ctx, (0, _toConsumableArray2.default)(point))) }); if (closePath)ctx.closePath() } function drawBezierCurvePath (ctx, points) { const moveTo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const beginPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; const closePath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; if (!ctx || !points) return false; if (beginPath)ctx.beginPath(); if (moveTo)ctx.moveTo.apply(ctx, (0, _toConsumableArray2.default)(moveTo)); points.forEach(function (item) { return item && ctx.bezierCurveTo.apply(ctx, (0, _toConsumableArray2.default)(item[0]).concat((0, _toConsumableArray2.default)(item[1]), (0, _toConsumableArray2.default)(item[2]))) }); if (closePath)ctx.closePath() } const _default = { drawPolylinePath: drawPolylinePath, drawBezierCurvePath: drawBezierCurvePath }; exports.default = _default }, { '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/toConsumableArray': 42 }], 54: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.deepClone = deepClone; exports.eliminateBlur = eliminateBlur; exports.checkPointIsInCircle = checkPointIsInCircle; exports.getTwoPointDistance = getTwoPointDistance; exports.checkPointIsInPolygon = checkPointIsInPolygon; exports.checkPointIsInSector = checkPointIsInSector; exports.checkPointIsNearPolyline = checkPointIsNearPolyline; exports.checkPointIsInRect = checkPointIsInRect; exports.getRotatePointPos = getRotatePointPos; exports.getScalePointPos = getScalePointPos; exports.getTranslatePointPos = getTranslatePointPos; exports.getDistanceBetweenPointAndLine = getDistanceBetweenPointAndLine; exports.getCircleRadianPoint = getCircleRadianPoint; exports.getRegularPolygonPoints = getRegularPolygonPoints; exports.default = void 0; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const abs = Math.abs; const sqrt = Math.sqrt; const sin = Math.sin; const cos = Math.cos; const max = Math.max; const min = Math.min; const PI = Math.PI; function deepClone (object) { const recursion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; if (!object) return object; const parse = JSON.parse; const stringify = JSON.stringify; if (!recursion) return parse(stringify(object)); const clonedObj = object instanceof Array ? [] : {}; if (object && (0, _typeof2.default)(object) === 'object') { for (const key in object) { if (object.hasOwnProperty(key)) { if (object[key] && (0, _typeof2.default)(object[key]) === 'object') { clonedObj[key] = deepClone(object[key], true) } else { clonedObj[key] = object[key] } } } } return clonedObj } function eliminateBlur (points) { return points.map(function (_ref) { const _ref2 = (0, _slicedToArray2.default)(_ref, 2); const x = _ref2[0]; const y = _ref2[1]; return [parseInt(x) + 0.5, parseInt(y) + 0.5] }) } function checkPointIsInCircle (point, rx, ry, r) { return getTwoPointDistance(point, [rx, ry]) <= r } function getTwoPointDistance (_ref3, _ref4) { const _ref5 = (0, _slicedToArray2.default)(_ref3, 2); const xa = _ref5[0]; const ya = _ref5[1]; const _ref6 = (0, _slicedToArray2.default)(_ref4, 2); const xb = _ref6[0]; const yb = _ref6[1]; const minusX = abs(xa - xb); const minusY = abs(ya - yb); return sqrt(minusX * minusX + minusY * minusY) } function checkPointIsInPolygon (point, polygon) { let counter = 0; const _point = (0, _slicedToArray2.default)(point, 2); const x = _point[0]; const y = _point[1]; const pointNum = polygon.length; for (let i = 1, p1 = polygon[0]; i <= pointNum; i++) { const p2 = polygon[i % pointNum]; if (x > min(p1[0], p2[0]) && x <= max(p1[0], p2[0])) { if (y <= max(p1[1], p2[1])) { if (p1[0] !== p2[0]) { const xinters = (x - p1[0]) * (p2[1] - p1[1]) / (p2[0] - p1[0]) + p1[1]; if (p1[1] === p2[1] || y <= xinters) { counter++ } } } }p1 = p2 } return counter % 2 === 1 } function checkPointIsInSector (point, rx, ry, r, startAngle, endAngle, clockWise) { if (!point) return false; if (getTwoPointDistance(point, [rx, ry]) > r) return false; if (!clockWise) { const _deepClone = deepClone([endAngle, startAngle]); const _deepClone2 = (0, _slicedToArray2.default)(_deepClone, 2); startAngle = _deepClone2[0]; endAngle = _deepClone2[1] } const reverseBE = startAngle > endAngle; if (reverseBE) { const _ref7 = [endAngle, startAngle]; startAngle = _ref7[0]; endAngle = _ref7[1] } const minus = endAngle - startAngle; if (minus >= PI * 2) return true; const _point2 = (0, _slicedToArray2.default)(point, 2); const x = _point2[0]; const y = _point2[1]; const _getCircleRadianPoint = getCircleRadianPoint(rx, ry, r, startAngle); const _getCircleRadianPoint2 = (0, _slicedToArray2.default)(_getCircleRadianPoint, 2); const bx = _getCircleRadianPoint2[0]; const by = _getCircleRadianPoint2[1]; const _getCircleRadianPoint3 = getCircleRadianPoint(rx, ry, r, endAngle); const _getCircleRadianPoint4 = (0, _slicedToArray2.default)(_getCircleRadianPoint3, 2); const ex = _getCircleRadianPoint4[0]; const ey = _getCircleRadianPoint4[1]; const vPoint = [x - rx, y - ry]; let vBArm = [bx - rx, by - ry]; let vEArm = [ex - rx, ey - ry]; const reverse = minus > PI; if (reverse) { const _deepClone3 = deepClone([vEArm, vBArm]); const _deepClone4 = (0, _slicedToArray2.default)(_deepClone3, 2); vBArm = _deepClone4[0]; vEArm = _deepClone4[1] } let inSector = isClockWise(vBArm, vPoint) && !isClockWise(vEArm, vPoint); if (reverse)inSector = !inSector; if (reverseBE)inSector = !inSector; return inSector } function isClockWise (vArm, vPoint) { const _vArm = (0, _slicedToArray2.default)(vArm, 2); const ax = _vArm[0]; const ay = _vArm[1]; const _vPoint = (0, _slicedToArray2.default)(vPoint, 2); const px = _vPoint[0]; const py = _vPoint[1]; return -ay * px + ax * py > 0 } function checkPointIsNearPolyline (point, polyline, lineWidth) { const halfLineWidth = lineWidth / 2; const moveUpPolyline = polyline.map(function (_ref8) { const _ref9 = (0, _slicedToArray2.default)(_ref8, 2); const x = _ref9[0]; const y = _ref9[1]; return [x, y - halfLineWidth] }); const moveDownPolyline = polyline.map(function (_ref10) { const _ref11 = (0, _slicedToArray2.default)(_ref10, 2); const x = _ref11[0]; const y = _ref11[1]; return [x, y + halfLineWidth] }); const polygon = [].concat((0, _toConsumableArray2.default)(moveUpPolyline), (0, _toConsumableArray2.default)(moveDownPolyline.reverse())); return checkPointIsInPolygon(point, polygon) } function checkPointIsInRect (_ref12, x, y, width, height) { const _ref13 = (0, _slicedToArray2.default)(_ref12, 2); const px = _ref13[0]; const py = _ref13[1]; if (px < x) return false; if (py < y) return false; if (px > x + width) return false; if (py > y + height) return false; return true } function getRotatePointPos () { let rotate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; const point = arguments.length > 1 ? arguments[1] : undefined; const origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0]; if (!point) return false; if (rotate % 360 === 0) return point; const _point3 = (0, _slicedToArray2.default)(point, 2); const x = _point3[0]; const y = _point3[1]; const _origin = (0, _slicedToArray2.default)(origin, 2); const ox = _origin[0]; const oy = _origin[1]; rotate *= PI / 180; return [(x - ox) * cos(rotate) - (y - oy) * sin(rotate) + ox, (x - ox) * sin(rotate) + (y - oy) * cos(rotate) + oy] } function getScalePointPos () { const scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [1, 1]; const point = arguments.length > 1 ? arguments[1] : undefined; const origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0]; if (!point) return false; if (scale === 1) return point; const _point4 = (0, _slicedToArray2.default)(point, 2); const x = _point4[0]; const y = _point4[1]; const _origin2 = (0, _slicedToArray2.default)(origin, 2); const ox = _origin2[0]; const oy = _origin2[1]; const _scale = (0, _slicedToArray2.default)(scale, 2); const xs = _scale[0]; const ys = _scale[1]; const relativePosX = x - ox; const relativePosY = y - oy; return [relativePosX * xs + ox, relativePosY * ys + oy] } function getTranslatePointPos (translate, point) { if (!translate || !point) return false; const _point5 = (0, _slicedToArray2.default)(point, 2); const x = _point5[0]; const y = _point5[1]; const _translate = (0, _slicedToArray2.default)(translate, 2); const tx = _translate[0]; const ty = _translate[1]; return [x + tx, y + ty] } function getDistanceBetweenPointAndLine (point, lineBegin, lineEnd) { if (!point || !lineBegin || !lineEnd) return false; const _point6 = (0, _slicedToArray2.default)(point, 2); const x = _point6[0]; const y = _point6[1]; const _lineBegin = (0, _slicedToArray2.default)(lineBegin, 2); const x1 = _lineBegin[0]; const y1 = _lineBegin[1]; const _lineEnd = (0, _slicedToArray2.default)(lineEnd, 2); const x2 = _lineEnd[0]; const y2 = _lineEnd[1]; const a = y2 - y1; const b = x1 - x2; const c = y1 * (x2 - x1) - x1 * (y2 - y1); const molecule = abs(a * x + b * y + c); const denominator = sqrt(a * a + b * b); return molecule / denominator } function getCircleRadianPoint (x, y, radius, radian) { return [x + cos(radian) * radius, y + sin(radian) * radius] } function getRegularPolygonPoints (rx, ry, r, side) { const minus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : PI * -0.5; const radianGap = PI * 2 / side; const radians = new Array(side).fill('').map(function (t, i) { return i * radianGap + minus }); return radians.map(function (radian) { return getCircleRadianPoint(rx, ry, r, radian) }) } const _default = { deepClone: deepClone, eliminateBlur: eliminateBlur, checkPointIsInCircle: checkPointIsInCircle, checkPointIsInPolygon: checkPointIsInPolygon, checkPointIsInSector: checkPointIsInSector, checkPointIsNearPolyline: checkPointIsNearPolyline, getTwoPointDistance: getTwoPointDistance, getRotatePointPos: getRotatePointPos, getScalePointPos: getScalePointPos, getTranslatePointPos: getTranslatePointPos, getCircleRadianPoint: getCircleRadianPoint, getRegularPolygonPoints: getRegularPolygonPoints, getDistanceBetweenPointAndLine: getDistanceBetweenPointAndLine }; exports.default = _default }, { '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/toConsumableArray': 42, '@babel/runtime/helpers/typeof': 43 }], 55: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _default = new Map([['transparent', 'rgba(0,0,0,0)'], ['black', '#000000'], ['silver', '#C0C0C0'], ['gray', '#808080'], ['white', '#FFFFFF'], ['maroon', '#800000'], ['red', '#FF0000'], ['purple', '#800080'], ['fuchsia', '#FF00FF'], ['green', '#008000'], ['lime', '#00FF00'], ['olive', '#808000'], ['yellow', '#FFFF00'], ['navy', '#000080'], ['blue', '#0000FF'], ['teal', '#008080'], ['aqua', '#00FFFF'], ['aliceblue', '#f0f8ff'], ['antiquewhite', '#faebd7'], ['aquamarine', '#7fffd4'], ['azure', '#f0ffff'], ['beige', '#f5f5dc'], ['bisque', '#ffe4c4'], ['blanchedalmond', '#ffebcd'], ['blueviolet', '#8a2be2'], ['brown', '#a52a2a'], ['burlywood', '#deb887'], ['cadetblue', '#5f9ea0'], ['chartreuse', '#7fff00'], ['chocolate', '#d2691e'], ['coral', '#ff7f50'], ['cornflowerblue', '#6495ed'], ['cornsilk', '#fff8dc'], ['crimson', '#dc143c'], ['cyan', '#00ffff'], ['darkblue', '#00008b'], ['darkcyan', '#008b8b'], ['darkgoldenrod', '#b8860b'], ['darkgray', '#a9a9a9'], ['darkgreen', '#006400'], ['darkgrey', '#a9a9a9'], ['darkkhaki', '#bdb76b'], ['darkmagenta', '#8b008b'], ['darkolivegreen', '#556b2f'], ['darkorange', '#ff8c00'], ['darkorchid', '#9932cc'], ['darkred', '#8b0000'], ['darksalmon', '#e9967a'], ['darkseagreen', '#8fbc8f'], ['darkslateblue', '#483d8b'], ['darkslategray', '#2f4f4f'], ['darkslategrey', '#2f4f4f'], ['darkturquoise', '#00ced1'], ['darkviolet', '#9400d3'], ['deeppink', '#ff1493'], ['deepskyblue', '#00bfff'], ['dimgray', '#696969'], ['dimgrey', '#696969'], ['dodgerblue', '#1e90ff'], ['firebrick', '#b22222'], ['floralwhite', '#fffaf0'], ['forestgreen', '#228b22'], ['gainsboro', '#dcdcdc'], ['ghostwhite', '#f8f8ff'], ['gold', '#ffd700'], ['goldenrod', '#daa520'], ['greenyellow', '#adff2f'], ['grey', '#808080'], ['honeydew', '#f0fff0'], ['hotpink', '#ff69b4'], ['indianred', '#cd5c5c'], ['indigo', '#4b0082'], ['ivory', '#fffff0'], ['khaki', '#f0e68c'], ['lavender', '#e6e6fa'], ['lavenderblush', '#fff0f5'], ['lawngreen', '#7cfc00'], ['lemonchiffon', '#fffacd'], ['lightblue', '#add8e6'], ['lightcoral', '#f08080'], ['lightcyan', '#e0ffff'], ['lightgoldenrodyellow', '#fafad2'], ['lightgray', '#d3d3d3'], ['lightgreen', '#90ee90'], ['lightgrey', '#d3d3d3'], ['lightpink', '#ffb6c1'], ['lightsalmon', '#ffa07a'], ['lightseagreen', '#20b2aa'], ['lightskyblue', '#87cefa'], ['lightslategray', '#778899'], ['lightslategrey', '#778899'], ['lightsteelblue', '#b0c4de'], ['lightyellow', '#ffffe0'], ['limegreen', '#32cd32'], ['linen', '#faf0e6'], ['magenta', '#ff00ff'], ['mediumaquamarine', '#66cdaa'], ['mediumblue', '#0000cd'], ['mediumorchid', '#ba55d3'], ['mediumpurple', '#9370db'], ['mediumseagreen', '#3cb371'], ['mediumslateblue', '#7b68ee'], ['mediumspringgreen', '#00fa9a'], ['mediumturquoise', '#48d1cc'], ['mediumvioletred', '#c71585'], ['midnightblue', '#191970'], ['mintcream', '#f5fffa'], ['mistyrose', '#ffe4e1'], ['moccasin', '#ffe4b5'], ['navajowhite', '#ffdead'], ['oldlace', '#fdf5e6'], ['olivedrab', '#6b8e23'], ['orange', '#ffa500'], ['orangered', '#ff4500'], ['orchid', '#da70d6'], ['palegoldenrod', '#eee8aa'], ['palegreen', '#98fb98'], ['paleturquoise', '#afeeee'], ['palevioletred', '#db7093'], ['papayawhip', '#ffefd5'], ['peachpuff', '#ffdab9'], ['peru', '#cd853f'], ['pink', '#ffc0cb'], ['plum', '#dda0dd'], ['powderblue', '#b0e0e6'], ['rosybrown', '#bc8f8f'], ['royalblue', '#4169e1'], ['saddlebrown', '#8b4513'], ['salmon', '#fa8072'], ['sandybrown', '#f4a460'], ['seagreen', '#2e8b57'], ['seashell', '#fff5ee'], ['sienna', '#a0522d'], ['skyblue', '#87ceeb'], ['slateblue', '#6a5acd'], ['slategray', '#708090'], ['slategrey', '#708090'], ['snow', '#fffafa'], ['springgreen', '#00ff7f'], ['steelblue', '#4682b4'], ['tan', '#d2b48c'], ['thistle', '#d8bfd8'], ['tomato', '#ff6347'], ['turquoise', '#40e0d0'], ['violet', '#ee82ee'], ['wheat', '#f5deb3'], ['whitesmoke', '#f5f5f5'], ['yellowgreen', '#9acd32']]); exports.default = _default }, {}], 56: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.getRgbValue = getRgbValue; exports.getRgbaValue = getRgbaValue; exports.getOpacity = getOpacity; exports.toRgb = toRgb; exports.toHex = toHex; exports.getColorFromRgbValue = getColorFromRgbValue; exports.darken = darken; exports.lighten = lighten; exports.fade = fade; exports.default = void 0; const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const _keywords = _interopRequireDefault(require('./config/keywords')); const hexReg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/; const rgbReg = /^(rgb|rgba|RGB|RGBA)/; const rgbaReg = /^(rgba|RGBA)/; function validator (color) { const isHex = hexReg.test(color); const isRgb = rgbReg.test(color); if (isHex || isRgb) return color; color = getColorByKeyword(color); if (!color) { console.error('Color: Invalid color!'); return false } return color } function getColorByKeyword (keyword) { if (!keyword) { console.error('getColorByKeywords: Missing parameters!'); return false } if (!_keywords.default.has(keyword)) return false; return _keywords.default.get(keyword) } function getRgbValue (color) { if (!color) { console.error('getRgbValue: Missing parameters!'); return false }color = validator(color); if (!color) return false; const isHex = hexReg.test(color); const isRgb = rgbReg.test(color); const lowerColor = color.toLowerCase(); if (isHex) return getRgbValueFromHex(lowerColor); if (isRgb) return getRgbValueFromRgb(lowerColor) } function getRgbValueFromHex (color) { color = color.replace('#', ''); if (color.length === 3)color = Array.from(color).map(function (hexNum) { return hexNum + hexNum }).join(''); color = color.split(''); return new Array(3).fill(0).map(function (t, i) { return parseInt('0x'.concat(color[i * 2]).concat(color[i * 2 + 1])) }) } function getRgbValueFromRgb (color) { return color.replace(/rgb\(|rgba\(|\)/g, '').split(',').slice(0, 3).map(function (n) { return parseInt(n) }) } function getRgbaValue (color) { if (!color) { console.error('getRgbaValue: Missing parameters!'); return false } const colorValue = getRgbValue(color); if (!colorValue) return false; colorValue.push(getOpacity(color)); return colorValue } function getOpacity (color) { if (!color) { console.error('getOpacity: Missing parameters!'); return false }color = validator(color); if (!color) return false; const isRgba = rgbaReg.test(color); if (!isRgba) return 1; color = color.toLowerCase(); return Number(color.split(',').slice(-1)[0].replace(/[)|\s]/g, '')) } function toRgb (color, opacity) { if (!color) { console.error('toRgb: Missing parameters!'); return false } const rgbValue = getRgbValue(color); if (!rgbValue) return false; const addOpacity = typeof opacity === 'number'; if (addOpacity) return 'rgba(' + rgbValue.join(',') + ','.concat(opacity, ')'); return 'rgb(' + rgbValue.join(',') + ')' } function toHex (color) { if (!color) { console.error('toHex: Missing parameters!'); return false } if (hexReg.test(color)) return color; color = getRgbValue(color); if (!color) return false; return '#' + color.map(function (n) { return Number(n).toString(16) }).map(function (n) { return n === '0' ? '00' : n }).join('') } function getColorFromRgbValue (value) { if (!value) { console.error('getColorFromRgbValue: Missing parameters!'); return false } const valueLength = value.length; if (valueLength !== 3 && valueLength !== 4) { console.error('getColorFromRgbValue: Value is illegal!'); return false } let color = valueLength === 3 ? 'rgb(' : 'rgba('; color += value.join(',') + ')'; return color } function darken (color) { const percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; if (!color) { console.error('darken: Missing parameters!'); return false } let rgbaValue = getRgbaValue(color); if (!rgbaValue) return false; rgbaValue = rgbaValue.map(function (v, i) { return i === 3 ? v : v - Math.ceil(2.55 * percent) }).map(function (v) { return v < 0 ? 0 : v }); return getColorFromRgbValue(rgbaValue) } function lighten (color) { const percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; if (!color) { console.error('lighten: Missing parameters!'); return false } let rgbaValue = getRgbaValue(color); if (!rgbaValue) return false; rgbaValue = rgbaValue.map(function (v, i) { return i === 3 ? v : v + Math.ceil(2.55 * percent) }).map(function (v) { return v > 255 ? 255 : v }); return getColorFromRgbValue(rgbaValue) } function fade (color) { const percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100; if (!color) { console.error('fade: Missing parameters!'); return false } const rgbValue = getRgbValue(color); if (!rgbValue) return false; const rgbaValue = [].concat((0, _toConsumableArray2.default)(rgbValue), [percent / 100]); return getColorFromRgbValue(rgbaValue) } const _default = { fade: fade, toHex: toHex, toRgb: toRgb, darken: darken, lighten: lighten, getOpacity: getOpacity, getRgbValue: getRgbValue, getRgbaValue: getRgbaValue, getColorFromRgbValue: getColorFromRgbValue }; exports.default = _default }, { './config/keywords': 55, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/toConsumableArray': 42 }], 57: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.default = exports.easeInOutBounce = exports.easeOutBounce = exports.easeInBounce = exports.easeInOutElastic = exports.easeOutElastic = exports.easeInElastic = exports.easeInOutBack = exports.easeOutBack = exports.easeInBack = exports.easeInOutQuint = exports.easeOutQuint = exports.easeInQuint = exports.easeInOutQuart = exports.easeOutQuart = exports.easeInQuart = exports.easeInOutCubic = exports.easeOutCubic = exports.easeInCubic = exports.easeInOutQuad = exports.easeOutQuad = exports.easeInQuad = exports.easeInOutSine = exports.easeOutSine = exports.easeInSine = exports.linear = void 0; const linear = [[[0, 1], '', [0.33, 0.67]], [[1, 0], [0.67, 0.33]]]; exports.linear = linear; const easeInSine = [[[0, 1]], [[0.538, 0.564], [0.169, 0.912], [0.88, 0.196]], [[1, 0]]]; exports.easeInSine = easeInSine; const easeOutSine = [[[0, 1]], [[0.444, 0.448], [0.169, 0.736], [0.718, 0.16]], [[1, 0]]]; exports.easeOutSine = easeOutSine; const easeInOutSine = [[[0, 1]], [[0.5, 0.5], [0.2, 1], [0.8, 0]], [[1, 0]]]; exports.easeInOutSine = easeInOutSine; const easeInQuad = [[[0, 1]], [[0.55, 0.584], [0.231, 0.904], [0.868, 0.264]], [[1, 0]]]; exports.easeInQuad = easeInQuad; const easeOutQuad = [[[0, 1]], [[0.413, 0.428], [0.065, 0.816], [0.76, 0.04]], [[1, 0]]]; exports.easeOutQuad = easeOutQuad; const easeInOutQuad = [[[0, 1]], [[0.5, 0.5], [0.3, 0.9], [0.7, 0.1]], [[1, 0]]]; exports.easeInOutQuad = easeInOutQuad; const easeInCubic = [[[0, 1]], [[0.679, 0.688], [0.366, 0.992], [0.992, 0.384]], [[1, 0]]]; exports.easeInCubic = easeInCubic; const easeOutCubic = [[[0, 1]], [[0.321, 0.312], [0.008, 0.616], [0.634, 0.008]], [[1, 0]]]; exports.easeOutCubic = easeOutCubic; const easeInOutCubic = [[[0, 1]], [[0.5, 0.5], [0.3, 1], [0.7, 0]], [[1, 0]]]; exports.easeInOutCubic = easeInOutCubic; const easeInQuart = [[[0, 1]], [[0.812, 0.74], [0.611, 0.988], [1.013, 0.492]], [[1, 0]]]; exports.easeInQuart = easeInQuart; const easeOutQuart = [[[0, 1]], [[0.152, 0.244], [0.001, 0.448], [0.285, -0.02]], [[1, 0]]]; exports.easeOutQuart = easeOutQuart; const easeInOutQuart = [[[0, 1]], [[0.5, 0.5], [0.4, 1], [0.6, 0]], [[1, 0]]]; exports.easeInOutQuart = easeInOutQuart; const easeInQuint = [[[0, 1]], [[0.857, 0.856], [0.714, 1], [1, 0.712]], [[1, 0]]]; exports.easeInQuint = easeInQuint; const easeOutQuint = [[[0, 1]], [[0.108, 0.2], [0.001, 0.4], [0.214, -0.012]], [[1, 0]]]; exports.easeOutQuint = easeOutQuint; const easeInOutQuint = [[[0, 1]], [[0.5, 0.5], [0.5, 1], [0.5, 0]], [[1, 0]]]; exports.easeInOutQuint = easeInOutQuint; const easeInBack = [[[0, 1]], [[0.667, 0.896], [0.38, 1.184], [0.955, 0.616]], [[1, 0]]]; exports.easeInBack = easeInBack; const easeOutBack = [[[0, 1]], [[0.335, 0.028], [0.061, 0.22], [0.631, -0.18]], [[1, 0]]]; exports.easeOutBack = easeOutBack; const easeInOutBack = [[[0, 1]], [[0.5, 0.5], [0.4, 1.4], [0.6, -0.4]], [[1, 0]]]; exports.easeInOutBack = easeInOutBack; const easeInElastic = [[[0, 1]], [[0.474, 0.964], [0.382, 0.988], [0.557, 0.952]], [[0.619, 1.076], [0.565, 1.088], [0.669, 1.08]], [[0.77, 0.916], [0.712, 0.924], [0.847, 0.904]], [[0.911, 1.304], [0.872, 1.316], [0.961, 1.34]], [[1, 0]]]; exports.easeInElastic = easeInElastic; const easeOutElastic = [[[0, 1]], [[0.073, -0.32], [0.034, -0.328], [0.104, -0.344]], [[0.191, 0.092], [0.11, 0.06], [0.256, 0.08]], [[0.31, -0.076], [0.26, -0.068], [0.357, -0.076]], [[0.432, 0.032], [0.362, 0.028], [0.683, -0.004]], [[1, 0]]]; exports.easeOutElastic = easeOutElastic; const easeInOutElastic = [[[0, 1]], [[0.21, 0.94], [0.167, 0.884], [0.252, 0.98]], [[0.299, 1.104], [0.256, 1.092], [0.347, 1.108]], [[0.5, 0.496], [0.451, 0.672], [0.548, 0.324]], [[0.696, -0.108], [0.652, -0.112], [0.741, -0.124]], [[0.805, 0.064], [0.756, 0.012], [0.866, 0.096]], [[1, 0]]]; exports.easeInOutElastic = easeInOutElastic; const easeInBounce = [[[0, 1]], [[0.148, 1], [0.075, 0.868], [0.193, 0.848]], [[0.326, 1], [0.276, 0.836], [0.405, 0.712]], [[0.6, 1], [0.511, 0.708], [0.671, 0.348]], [[1, 0]]]; exports.easeInBounce = easeInBounce; const easeOutBounce = [[[0, 1]], [[0.357, 0.004], [0.27, 0.592], [0.376, 0.252]], [[0.604, -0.004], [0.548, 0.312], [0.669, 0.184]], [[0.82, 0], [0.749, 0.184], [0.905, 0.132]], [[1, 0]]]; exports.easeOutBounce = easeOutBounce; const easeInOutBounce = [[[0, 1]], [[0.102, 1], [0.05, 0.864], [0.117, 0.86]], [[0.216, 0.996], [0.208, 0.844], [0.227, 0.808]], [[0.347, 0.996], [0.343, 0.8], [0.48, 0.292]], [[0.635, 0.004], [0.511, 0.676], [0.656, 0.208]], [[0.787, 0], [0.76, 0.2], [0.795, 0.144]], [[0.905, -0.004], [0.899, 0.164], [0.944, 0.144]], [[1, 0]]]; exports.easeInOutBounce = easeInOutBounce; const _default = new Map([['linear', linear], ['easeInSine', easeInSine], ['easeOutSine', easeOutSine], ['easeInOutSine', easeInOutSine], ['easeInQuad', easeInQuad], ['easeOutQuad', easeOutQuad], ['easeInOutQuad', easeInOutQuad], ['easeInCubic', easeInCubic], ['easeOutCubic', easeOutCubic], ['easeInOutCubic', easeInOutCubic], ['easeInQuart', easeInQuart], ['easeOutQuart', easeOutQuart], ['easeInOutQuart', easeInOutQuart], ['easeInQuint', easeInQuint], ['easeOutQuint', easeOutQuint], ['easeInOutQuint', easeInOutQuint], ['easeInBack', easeInBack], ['easeOutBack', easeOutBack], ['easeInOutBack', easeInOutBack], ['easeInElastic', easeInElastic], ['easeOutElastic', easeOutElastic], ['easeInOutElastic', easeInOutElastic], ['easeInBounce', easeInBounce], ['easeOutBounce', easeOutBounce], ['easeInOutBounce', easeInOutBounce]]); exports.default = _default }, {}], 58: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.transition = transition; exports.injectNewCurve = injectNewCurve; exports.default = void 0; const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _curves = _interopRequireDefault(require('./config/curves')); const defaultTransitionBC = 'linear'; function transition (tBC) { const startState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; const endState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null; const frameNum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30; const deep = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; if (!checkParams.apply(void 0, arguments)) return false; try { const bezierCurve = getBezierCurve(tBC); const frameStateProgress = getFrameStateProgress(bezierCurve, frameNum); if (!deep || typeof endState === 'number') return getTransitionState(startState, endState, frameStateProgress); return recursionTransitionState(startState, endState, frameStateProgress) } catch (_unused) { console.warn('Transition parameter may be abnormal!'); return [endState] } } function checkParams (tBC) { const startState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; const endState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const frameNum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30; if (!tBC || startState === false || endState === false || !frameNum) { console.error('transition: Missing Parameters!'); return false } if ((0, _typeof2.default)(startState) !== (0, _typeof2.default)(endState)) { console.error('transition: Inconsistent Status Types!'); return false } const stateType = (0, _typeof2.default)(endState); if (stateType === 'string' || stateType === 'boolean' || !tBC.length) { console.error('transition: Unsupported Data Type of State!'); return false } if (!_curves.default.has(tBC) && !(tBC instanceof Array)) { console.warn('transition: Transition curve not found, default curve will be used!') } return true } function getBezierCurve (tBC) { let bezierCurve = ''; if (_curves.default.has(tBC)) { bezierCurve = _curves.default.get(tBC) } else if (tBC instanceof Array) { bezierCurve = tBC } else { bezierCurve = _curves.default.get(defaultTransitionBC) } return bezierCurve } function getFrameStateProgress (bezierCurve, frameNum) { const tMinus = 1 / (frameNum - 1); const tState = new Array(frameNum).fill(0).map(function (t, i) { return i * tMinus }); const frameState = tState.map(function (t) { return getFrameStateFromT(bezierCurve, t) }); return frameState } function getFrameStateFromT (bezierCurve, t) { const tBezierCurvePoint = getBezierCurvePointFromT(bezierCurve, t); const bezierCurvePointT = getBezierCurvePointTFromReT(tBezierCurvePoint, t); return getBezierCurveTState(tBezierCurvePoint, bezierCurvePointT) } function getBezierCurvePointFromT (bezierCurve, t) { const lastIndex = bezierCurve.length - 1; let begin = ''; let end = ''; bezierCurve.findIndex(function (item, i) { if (i === lastIndex) return; begin = item; end = bezierCurve[i + 1]; const currentMainPointX = begin[0][0]; const nextMainPointX = end[0][0]; return t >= currentMainPointX && t < nextMainPointX }); const p0 = begin[0]; const p1 = begin[2] || begin[0]; const p2 = end[1] || end[0]; const p3 = end[0]; return [p0, p1, p2, p3] } function getBezierCurvePointTFromReT (bezierCurve, t) { const reBeginX = bezierCurve[0][0]; const reEndX = bezierCurve[3][0]; const xMinus = reEndX - reBeginX; const tMinus = t - reBeginX; return tMinus / xMinus } function getBezierCurveTState (_ref, t) { const _ref2 = (0, _slicedToArray2.default)(_ref, 4); const _ref2$ = (0, _slicedToArray2.default)(_ref2[0], 2); const p0 = _ref2$[1]; const _ref2$2 = (0, _slicedToArray2.default)(_ref2[1], 2); const p1 = _ref2$2[1]; const _ref2$3 = (0, _slicedToArray2.default)(_ref2[2], 2); const p2 = _ref2$3[1]; const _ref2$4 = (0, _slicedToArray2.default)(_ref2[3], 2); const p3 = _ref2$4[1]; const pow = Math.pow; const tMinus = 1 - t; const result1 = p0 * pow(tMinus, 3); const result2 = 3 * p1 * t * pow(tMinus, 2); const result3 = 3 * p2 * pow(t, 2) * tMinus; const result4 = p3 * pow(t, 3); return 1 - (result1 + result2 + result3 + result4) } function getTransitionState (begin, end, frameState) { let stateType = 'object'; if (typeof begin === 'number')stateType = 'number'; if (begin instanceof Array)stateType = 'array'; if (stateType === 'number') return getNumberTransitionState(begin, end, frameState); if (stateType === 'array') return getArrayTransitionState(begin, end, frameState); if (stateType === 'object') return getObjectTransitionState(begin, end, frameState); return frameState.map(function (t) { return end }) } function getNumberTransitionState (begin, end, frameState) { const minus = end - begin; return frameState.map(function (s) { return begin + minus * s }) } function getArrayTransitionState (begin, end, frameState) { const minus = end.map(function (v, i) { if (typeof v !== 'number') return false; return v - begin[i] }); return frameState.map(function (s) { return minus.map(function (v, i) { if (v === false) return end[i]; return begin[i] + v * s }) }) } function getObjectTransitionState (begin, end, frameState) { const keys = Object.keys(end); const beginValue = keys.map(function (k) { return begin[k] }); const endValue = keys.map(function (k) { return end[k] }); const arrayState = getArrayTransitionState(beginValue, endValue, frameState); return arrayState.map(function (item) { const frameData = {}; item.forEach(function (v, i) { return frameData[keys[i]] = v }); return frameData }) } function recursionTransitionState (begin, end, frameState) { const state = getTransitionState(begin, end, frameState); const _loop = function _loop (key) { const bTemp = begin[key]; const eTemp = end[key]; if ((0, _typeof2.default)(eTemp) !== 'object') return 'continue'; const data = recursionTransitionState(bTemp, eTemp, frameState); state.forEach(function (fs, i) { return fs[key] = data[i] }) }; for (const key in end) { const _ret = _loop(key); if (_ret === 'continue') continue } return state } function injectNewCurve (key, curve) { if (!key || !curve) { console.error('InjectNewCurve Missing Parameters!'); return }_curves.default.set(key, curve) } const _default = transition; exports.default = _default }, { './config/curves': 57, '@babel/runtime/helpers/interopRequireDefault': 36, '@babel/runtime/helpers/slicedToArray': 41, '@babel/runtime/helpers/typeof': 43 }], 59: [function (require, module, exports) { const runtime = (function (exports) { 'use strict'; const Op = Object.prototype; const hasOwn = Op.hasOwnProperty; let undefined; const $Symbol = typeof Symbol === 'function' ? Symbol : {}; const iteratorSymbol = $Symbol.iterator || '@@iterator'; const asyncIteratorSymbol = $Symbol.asyncIterator || '@@asyncIterator'; const toStringTagSymbol = $Symbol.toStringTag || '@@toStringTag'; function wrap (innerFn, outerFn, self, tryLocsList) { const protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator; const generator = Object.create(protoGenerator.prototype); const context = new Context(tryLocsList || []); generator._invoke = makeInvokeMethod(innerFn, self, context); return generator }exports.wrap = wrap; function tryCatch (fn, obj, arg) { try { return { type: 'normal', arg: fn.call(obj, arg) } } catch (err) { return { type: 'throw', arg: err } } } const GenStateSuspendedStart = 'suspendedStart'; const GenStateSuspendedYield = 'suspendedYield'; const GenStateExecuting = 'executing'; const GenStateCompleted = 'completed'; const ContinueSentinel = {}; function Generator () {} function GeneratorFunction () {} function GeneratorFunctionPrototype () {} let IteratorPrototype = {}; IteratorPrototype[iteratorSymbol] = function () { return this }; const getProto = Object.getPrototypeOf; const NativeIteratorPrototype = getProto && getProto(getProto(values([]))); if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) { IteratorPrototype = NativeIteratorPrototype } const Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = 'GeneratorFunction'; function defineIteratorMethods (prototype) { ['next', 'throw', 'return'].forEach(function (method) { prototype[method] = function (arg) { return this._invoke(method, arg) } }) }exports.isGeneratorFunction = function (genFun) { const ctor = typeof genFun === 'function' && genFun.constructor; return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === 'GeneratorFunction' : false }; exports.mark = function (genFun) { if (Object.setPrototypeOf) { Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) } else { genFun.__proto__ = GeneratorFunctionPrototype; if (!(toStringTagSymbol in genFun)) { genFun[toStringTagSymbol] = 'GeneratorFunction' } }genFun.prototype = Object.create(Gp); return genFun }; exports.awrap = function (arg) { return { __await: arg } }; function AsyncIterator (generator) { function invoke (method, arg, resolve, reject) { const record = tryCatch(generator[method], generator, arg); if (record.type === 'throw') { reject(record.arg) } else { const result = record.arg; const value = result.value; if (value && typeof value === 'object' && hasOwn.call(value, '__await')) { return Promise.resolve(value.__await).then(function (value) { invoke('next', value, resolve, reject) }, function (err) { invoke('throw', err, resolve, reject) }) } return Promise.resolve(value).then(function (unwrapped) { result.value = unwrapped; resolve(result) }, function (error) { return invoke('throw', error, resolve, reject) }) } } let previousPromise; function enqueue (method, arg) { function callInvokeWithMethodAndArg () { return new Promise(function (resolve, reject) { invoke(method, arg, resolve, reject) }) } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg() } this._invoke = enqueue }defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () { return this }; exports.AsyncIterator = AsyncIterator; exports.async = function (innerFn, outerFn, self, tryLocsList) { const iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList)); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next() }) }; function makeInvokeMethod (innerFn, self, context) { let state = GenStateSuspendedStart; return function invoke (method, arg) { if (state === GenStateExecuting) { throw new Error('Generator is already running') } if (state === GenStateCompleted) { if (method === 'throw') { throw arg } return doneResult() }context.method = method; context.arg = arg; while (true) { const delegate = context.delegate; if (delegate) { const delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult } } if (context.method === 'next') { context.sent = context._sent = context.arg } else if (context.method === 'throw') { if (state === GenStateSuspendedStart) { state = GenStateCompleted; throw context.arg }context.dispatchException(context.arg) } else if (context.method === 'return') { context.abrupt('return', context.arg) }state = GenStateExecuting; const record = tryCatch(innerFn, self, context); if (record.type === 'normal') { state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) { continue } return { value: record.arg, done: context.done } } else if (record.type === 'throw') { state = GenStateCompleted; context.method = 'throw'; context.arg = record.arg } } } } function maybeInvokeDelegate (delegate, context) { const method = delegate.iterator[context.method]; if (method === undefined) { context.delegate = null; if (context.method === 'throw') { if (delegate.iterator.return) { context.method = 'return'; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === 'throw') { return ContinueSentinel } }context.method = 'throw'; context.arg = new TypeError("The iterator does not provide a 'throw' method") } return ContinueSentinel } const record = tryCatch(method, delegate.iterator, context.arg); if (record.type === 'throw') { context.method = 'throw'; context.arg = record.arg; context.delegate = null; return ContinueSentinel } const info = record.arg; if (!info) { context.method = 'throw'; context.arg = new TypeError('iterator result is not an object'); context.delegate = null; return ContinueSentinel } if (info.done) { context[delegate.resultName] = info.value; context.next = delegate.nextLoc; if (context.method !== 'return') { context.method = 'next'; context.arg = undefined } } else { return info }context.delegate = null; return ContinueSentinel }defineIteratorMethods(Gp); Gp[toStringTagSymbol] = 'Generator'; Gp[iteratorSymbol] = function () { return this }; Gp.toString = function () { return '[object Generator]' }; function pushTryEntry (locs) { const entry = { tryLoc: locs[0] }; if (1 in locs) { entry.catchLoc = locs[1] } if (2 in locs) { entry.finallyLoc = locs[2]; entry.afterLoc = locs[3] } this.tryEntries.push(entry) } function resetTryEntry (entry) { const record = entry.completion || {}; record.type = 'normal'; delete record.arg; entry.completion = record } function Context (tryLocsList) { this.tryEntries = [{ tryLoc: 'root' }]; tryLocsList.forEach(pushTryEntry, this); this.reset(true) }exports.keys = function (object) { const keys = []; for (const key in object) { keys.push(key) }keys.reverse(); return function next () { while (keys.length) { const key = keys.pop(); if (key in object) { next.value = key; next.done = false; return next } }next.done = true; return next } }; function values (iterable) { if (iterable) { const iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) { return iteratorMethod.call(iterable) } if (typeof iterable.next === 'function') { return iterable } if (!isNaN(iterable.length)) { let i = -1; const next = function next () { while (++i < iterable.length) { if (hasOwn.call(iterable, i)) { next.value = iterable[i]; next.done = false; return next } }next.value = undefined; next.done = true; return next }; return next.next = next } } return { next: doneResult } }exports.values = values; function doneResult () { return { value: undefined, done: true } }Context.prototype = { constructor: Context, reset: function (skipTempReset) { this.prev = 0; this.next = 0; this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = 'next'; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) { for (const name in this) { if (name.charAt(0) === 't' && hasOwn.call(this, name) && !isNaN(+name.slice(1))) { this[name] = undefined } } } }, stop: function () { this.done = true; const rootEntry = this.tryEntries[0]; const rootRecord = rootEntry.completion; if (rootRecord.type === 'throw') { throw rootRecord.arg } return this.rval }, dispatchException: function (exception) { if (this.done) { throw exception } const context = this; function handle (loc, caught) { record.type = 'throw'; record.arg = exception; context.next = loc; if (caught) { context.method = 'next'; context.arg = undefined } return !!caught } for (let i = this.tryEntries.length - 1; i >= 0; --i) { const entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === 'root') { return handle('end') } if (entry.tryLoc <= this.prev) { const hasCatch = hasOwn.call(entry, 'catchLoc'); const hasFinally = hasOwn.call(entry, 'finallyLoc'); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) { return handle(entry.catchLoc, true) } else if (this.prev < entry.finallyLoc) { return handle(entry.finallyLoc) } } else if (hasCatch) { if (this.prev < entry.catchLoc) { return handle(entry.catchLoc, true) } } else if (hasFinally) { if (this.prev < entry.finallyLoc) { return handle(entry.finallyLoc) } } else { throw new Error('try statement without catch or finally') } } } }, abrupt: function (type, arg) { for (let i = this.tryEntries.length - 1; i >= 0; --i) { const entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, 'finallyLoc') && this.prev < entry.finallyLoc) { var finallyEntry = entry; break } } if (finallyEntry && (type === 'break' || type === 'continue') && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) { finallyEntry = null } const record = finallyEntry ? finallyEntry.completion : {}; record.type = type; record.arg = arg; if (finallyEntry) { this.method = 'next'; this.next = finallyEntry.finallyLoc; return ContinueSentinel } return this.complete(record) }, complete: function (record, afterLoc) { if (record.type === 'throw') { throw record.arg } if (record.type === 'break' || record.type === 'continue') { this.next = record.arg } else if (record.type === 'return') { this.rval = this.arg = record.arg; this.method = 'return'; this.next = 'end' } else if (record.type === 'normal' && afterLoc) { this.next = afterLoc } return ContinueSentinel }, finish: function (finallyLoc) { for (let i = this.tryEntries.length - 1; i >= 0; --i) { const entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) { this.complete(entry.completion, entry.afterLoc); resetTryEntry(entry); return ContinueSentinel } } }, catch: function (tryLoc) { for (let i = this.tryEntries.length - 1; i >= 0; --i) { const entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { const record = entry.completion; if (record.type === 'throw') { var thrown = record.arg; resetTryEntry(entry) } return thrown } } throw new Error('illegal catch attempt') }, delegateYield: function (iterable, resultName, nextLoc) { this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }; if (this.method === 'next') { this.arg = undefined } return ContinueSentinel } }; return exports }(typeof module === 'object' ? module.exports : {})); try { regeneratorRuntime = runtime } catch (accidentalStrictMode) { Function('r', 'regeneratorRuntime = r')(runtime) } }, {}] }, {}, [1])
