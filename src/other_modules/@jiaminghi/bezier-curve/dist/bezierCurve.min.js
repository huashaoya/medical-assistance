(function () { function r (e, n, t) { function o (i, f) { if (!n[i]) { if (!e[i]) { const c = typeof require === 'function' && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); const a = new Error("Cannot find module '" + i + "'"); throw a.code = 'MODULE_NOT_FOUND', a } const p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { const n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = typeof require === 'function' && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({ 1: [function (require, module, exports) { const bezierCurve = require('../lib/index'); window.bezierCurve = bezierCurve }, { '../lib/index': 4 }], 2: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.bezierCurveToPolyline = bezierCurveToPolyline; exports.getBezierCurveLength = getBezierCurveLength; exports.default = void 0; const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); const sqrt = Math.sqrt; const pow = Math.pow; const ceil = Math.ceil; const abs = Math.abs; const defaultSegmentPointsNum = 50; function abstractBezierCurveToPolyline (bezierCurve) { const precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5; const segmentsNum = bezierCurve.length - 1; const startPoint = bezierCurve[0]; const endPoint = bezierCurve[segmentsNum][2]; const segments = bezierCurve.slice(1); const getSegmentTPointFuns = segments.map(function (seg, i) { const beginPoint = i === 0 ? startPoint : segments[i - 1][2]; return createGetBezierCurveTPointFun.apply(void 0, [beginPoint].concat((0, _toConsumableArray2.default)(seg))) }); const segmentPointsNum = new Array(segmentsNum).fill(defaultSegmentPointsNum); const segmentPoints = getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum); const result = calcUniformPointsByIteration(segmentPoints, getSegmentTPointFuns, segments, precision); result.segmentPoints.push(endPoint); return result } function createGetBezierCurveTPointFun (beginPoint, controlPoint1, controlPoint2, endPoint) { return function (t) { const tSubed1 = 1 - t; const tSubed1Pow3 = pow(tSubed1, 3); const tSubed1Pow2 = pow(tSubed1, 2); const tPow3 = pow(t, 3); const tPow2 = pow(t, 2); return [beginPoint[0] * tSubed1Pow3 + 3 * controlPoint1[0] * t * tSubed1Pow2 + 3 * controlPoint2[0] * tPow2 * tSubed1 + endPoint[0] * tPow3, beginPoint[1] * tSubed1Pow3 + 3 * controlPoint1[1] * t * tSubed1Pow2 + 3 * controlPoint2[1] * tPow2 * tSubed1 + endPoint[1] * tPow3] } } function getTwoPointDistance (_ref, _ref2) { const _ref3 = (0, _slicedToArray2.default)(_ref, 2); const ax = _ref3[0]; const ay = _ref3[1]; const _ref4 = (0, _slicedToArray2.default)(_ref2, 2); const bx = _ref4[0]; const by = _ref4[1]; return sqrt(pow(ax - bx, 2) + pow(ay - by, 2)) } function getNumsSum (nums) { return nums.reduce(function (sum, num) { return sum + num }, 0) } function getSegmentPointsDistance (segmentPoints) { return segmentPoints.map(function (points, i) { return new Array(points.length - 1).fill(0).map(function (temp, j) { return getTwoPointDistance(points[j], points[j + 1]) }) }) } function getSegmentPointsByNum (getSegmentTPointFuns, segmentPointsNum) { return getSegmentTPointFuns.map(function (getSegmentTPointFun, i) { const tGap = 1 / segmentPointsNum[i]; return new Array(segmentPointsNum[i]).fill('').map(function (foo, j) { return getSegmentTPointFun(j * tGap) }) }) } function getAllDeviations (segmentPointsDistance, avgLength) { return segmentPointsDistance.map(function (seg) { return seg.map(function (s) { return abs(s - avgLength) }) }).map(function (seg) { return getNumsSum(seg) }).reduce(function (total, v) { return total + v }, 0) } function calcUniformPointsByIteration (segmentPoints, getSegmentTPointFuns, segments, precision) { let rounds = 4; let cycles = 1; const _loop = function _loop () { let totalPointsNum = segmentPoints.reduce(function (total, seg) { return total + seg.length }, 0); segmentPoints.forEach(function (seg, i) { return seg.push(segments[i][2]) }); let segmentPointsDistance = getSegmentPointsDistance(segmentPoints); let lineSegmentNum = segmentPointsDistance.reduce(function (total, seg) { return total + seg.length }, 0); let segmentlength = segmentPointsDistance.map(function (seg) { return getNumsSum(seg) }); let totalLength = getNumsSum(segmentlength); let avgLength = totalLength / lineSegmentNum; const allDeviations = getAllDeviations(segmentPointsDistance, avgLength); if (allDeviations <= precision) return 'break'; totalPointsNum = ceil(avgLength / precision * totalPointsNum * 1.1); const segmentPointsNum = segmentlength.map(function (length) { return ceil(length / totalLength * totalPointsNum) }); segmentPoints = getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum); totalPointsNum = segmentPoints.reduce(function (total, seg) { return total + seg.length }, 0); const segmentPointsForLength = JSON.parse(JSON.stringify(segmentPoints)); segmentPointsForLength.forEach(function (seg, i) { return seg.push(segments[i][2]) }); segmentPointsDistance = getSegmentPointsDistance(segmentPointsForLength); lineSegmentNum = segmentPointsDistance.reduce(function (total, seg) { return total + seg.length }, 0); segmentlength = segmentPointsDistance.map(function (seg) { return getNumsSum(seg) }); totalLength = getNumsSum(segmentlength); avgLength = totalLength / lineSegmentNum; const stepSize = 1 / totalPointsNum / 10; getSegmentTPointFuns.forEach(function (getSegmentTPointFun, i) { const currentSegmentPointsNum = segmentPointsNum[i]; const t = new Array(currentSegmentPointsNum).fill('').map(function (foo, j) { return j / segmentPointsNum[i] }); for (let r = 0; r < rounds; r++) { const distance = getSegmentPointsDistance([segmentPoints[i]])[0]; const deviations = distance.map(function (d) { return d - avgLength }); let offset = 0; for (let j = 0; j < currentSegmentPointsNum; j++) { if (j === 0) return; offset += deviations[j - 1]; t[j] -= stepSize * offset; if (t[j] > 1)t[j] = 1; if (t[j] < 0)t[j] = 0; segmentPoints[i][j] = getSegmentTPointFun(t[j]) } } }); rounds *= 4; cycles++ }; do { const _ret = _loop(); if (_ret === 'break') break } while (rounds <= 1025); segmentPoints = segmentPoints.reduce(function (all, seg) { return all.concat(seg) }, []); return { segmentPoints: segmentPoints, cycles: cycles, rounds: rounds } } function bezierCurveToPolyline (bezierCurve) { const precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5; if (!bezierCurve) { console.error('bezierCurveToPolyline: Missing parameters!'); return false } if (!(bezierCurve instanceof Array)) { console.error('bezierCurveToPolyline: Parameter bezierCurve must be an array!'); return false } if (typeof precision !== 'number') { console.error('bezierCurveToPolyline: Parameter precision must be a number!'); return false } const _abstractBezierCurveT = abstractBezierCurveToPolyline(bezierCurve, precision); const segmentPoints = _abstractBezierCurveT.segmentPoints; return segmentPoints } function getBezierCurveLength (bezierCurve) { const precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5; if (!bezierCurve) { console.error('getBezierCurveLength: Missing parameters!'); return false } if (!(bezierCurve instanceof Array)) { console.error('getBezierCurveLength: Parameter bezierCurve must be an array!'); return false } if (typeof precision !== 'number') { console.error('getBezierCurveLength: Parameter precision must be a number!'); return false } const _abstractBezierCurveT2 = abstractBezierCurveToPolyline(bezierCurve, precision); const segmentPoints = _abstractBezierCurveT2.segmentPoints; const pointsDistance = getSegmentPointsDistance([segmentPoints])[0]; const length = getNumsSum(pointsDistance); return length } const _default = bezierCurveToPolyline; exports.default = _default }, { '@babel/runtime/helpers/interopRequireDefault': 7, '@babel/runtime/helpers/slicedToArray': 12, '@babel/runtime/helpers/toConsumableArray': 13 }], 3: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _toConsumableArray2 = _interopRequireDefault(require('@babel/runtime/helpers/toConsumableArray')); function polylineToBezierCurve (polyline) { const close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; const offsetA = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.25; const offsetB = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.25; if (!(polyline instanceof Array)) { console.error('polylineToBezierCurve: Parameter polyline must be an array!'); return false } if (polyline.length <= 2) { console.error('polylineToBezierCurve: Converting to a curve requires at least 3 points!'); return false } const startPoint = polyline[0]; const bezierCurveLineNum = polyline.length - 1; const bezierCurvePoints = new Array(bezierCurveLineNum).fill(0).map(function (foo, i) { return [].concat((0, _toConsumableArray2.default)(getBezierCurveLineControlPoints(polyline, i, close, offsetA, offsetB)), [polyline[i + 1]]) }); if (close)closeBezierCurve(bezierCurvePoints, startPoint); bezierCurvePoints.unshift(polyline[0]); return bezierCurvePoints } function getBezierCurveLineControlPoints (polyline, index) { const close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const offsetA = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.25; const offsetB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.25; const pointNum = polyline.length; if (pointNum < 3 || index >= pointNum) return; let beforePointIndex = index - 1; if (beforePointIndex < 0)beforePointIndex = close ? pointNum + beforePointIndex : 0; let afterPointIndex = index + 1; if (afterPointIndex >= pointNum)afterPointIndex = close ? afterPointIndex - pointNum : pointNum - 1; let afterNextPointIndex = index + 2; if (afterNextPointIndex >= pointNum)afterNextPointIndex = close ? afterNextPointIndex - pointNum : pointNum - 1; const pointBefore = polyline[beforePointIndex]; const pointMiddle = polyline[index]; const pointAfter = polyline[afterPointIndex]; const pointAfterNext = polyline[afterNextPointIndex]; return [[pointMiddle[0] + offsetA * (pointAfter[0] - pointBefore[0]), pointMiddle[1] + offsetA * (pointAfter[1] - pointBefore[1])], [pointAfter[0] - offsetB * (pointAfterNext[0] - pointMiddle[0]), pointAfter[1] - offsetB * (pointAfterNext[1] - pointMiddle[1])]] } function closeBezierCurve (bezierCurve, startPoint) { const firstSubCurve = bezierCurve[0]; const lastSubCurve = bezierCurve.slice(-1)[0]; bezierCurve.push([getSymmetryPoint(lastSubCurve[1], lastSubCurve[2]), getSymmetryPoint(firstSubCurve[0], startPoint), startPoint]); return bezierCurve } function getSymmetryPoint (point, centerPoint) { const _point = (0, _slicedToArray2.default)(point, 2); const px = _point[0]; const py = _point[1]; const _centerPoint = (0, _slicedToArray2.default)(centerPoint, 2); const cx = _centerPoint[0]; const cy = _centerPoint[1]; const minusX = cx - px; const minusY = cy - py; return [cx + minusX, cy + minusY] } const _default = polylineToBezierCurve; exports.default = _default }, { '@babel/runtime/helpers/interopRequireDefault': 7, '@babel/runtime/helpers/slicedToArray': 12, '@babel/runtime/helpers/toConsumableArray': 13 }], 4: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); Object.defineProperty(exports, 'bezierCurveToPolyline', { enumerable: true, get: function get () { return _bezierCurveToPolyline.bezierCurveToPolyline } }); Object.defineProperty(exports, 'getBezierCurveLength', { enumerable: true, get: function get () { return _bezierCurveToPolyline.getBezierCurveLength } }); Object.defineProperty(exports, 'polylineToBezierCurve', { enumerable: true, get: function get () { return _polylineToBezierCurve.default } }); exports.default = void 0; var _bezierCurveToPolyline = require('./core/bezierCurveToPolyline'); var _polylineToBezierCurve = _interopRequireDefault(require('./core/polylineToBezierCurve')); const _default = { bezierCurveToPolyline: _bezierCurveToPolyline.bezierCurveToPolyline, getBezierCurveLength: _bezierCurveToPolyline.getBezierCurveLength, polylineToBezierCurve: _polylineToBezierCurve.default }; exports.default = _default }, { './core/bezierCurveToPolyline': 2, './core/polylineToBezierCurve': 3, '@babel/runtime/helpers/interopRequireDefault': 7 }], 5: [function (require, module, exports) { function _arrayWithHoles (arr) { if (Array.isArray(arr)) return arr }module.exports = _arrayWithHoles }, {}], 6: [function (require, module, exports) { function _arrayWithoutHoles (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i] } return arr2 } }module.exports = _arrayWithoutHoles }, {}], 7: [function (require, module, exports) { function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { default: obj } }module.exports = _interopRequireDefault }, {}], 8: [function (require, module, exports) { function _iterableToArray (iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === '[object Arguments]') return Array.from(iter) }module.exports = _iterableToArray }, {}], 9: [function (require, module, exports) { function _iterableToArrayLimit (arr, i) { const _arr = []; let _n = true; let _d = false; let _e; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break } } catch (err) { _d = true; _e = err } finally { try { if (!_n && _i.return != null)_i.return() } finally { if (_d) throw _e } } return _arr }module.exports = _iterableToArrayLimit }, {}], 10: [function (require, module, exports) { function _nonIterableRest () { throw new TypeError('Invalid attempt to destructure non-iterable instance') }module.exports = _nonIterableRest }, {}], 11: [function (require, module, exports) { function _nonIterableSpread () { throw new TypeError('Invalid attempt to spread non-iterable instance') }module.exports = _nonIterableSpread }, {}], 12: [function (require, module, exports) { const arrayWithHoles = require('./arrayWithHoles'); const iterableToArrayLimit = require('./iterableToArrayLimit'); const nonIterableRest = require('./nonIterableRest'); function _slicedToArray (arr, i) { return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest() }module.exports = _slicedToArray }, { './arrayWithHoles': 5, './iterableToArrayLimit': 9, './nonIterableRest': 10 }], 13: [function (require, module, exports) { const arrayWithoutHoles = require('./arrayWithoutHoles'); const iterableToArray = require('./iterableToArray'); const nonIterableSpread = require('./nonIterableSpread'); function _toConsumableArray (arr) { return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread() }module.exports = _toConsumableArray }, { './arrayWithoutHoles': 6, './iterableToArray': 8, './nonIterableSpread': 11 }] }, {}, [1])
