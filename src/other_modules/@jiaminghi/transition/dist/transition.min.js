(function () { function r (e, n, t) { function o (i, f) { if (!n[i]) { if (!e[i]) { const c = typeof require === 'function' && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); const a = new Error("Cannot find module '" + i + "'"); throw a.code = 'MODULE_NOT_FOUND', a } const p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { const n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = typeof require === 'function' && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({ 1: [function (require, module, exports) { const transition = require('../lib/index'); window.transition = transition }, { '../lib/index': 3 }], 2: [function (require, module, exports) { 'use strict'; Object.defineProperty(exports, '__esModule', { value: true }); exports.default = exports.easeInOutBounce = exports.easeOutBounce = exports.easeInBounce = exports.easeInOutElastic = exports.easeOutElastic = exports.easeInElastic = exports.easeInOutBack = exports.easeOutBack = exports.easeInBack = exports.easeInOutQuint = exports.easeOutQuint = exports.easeInQuint = exports.easeInOutQuart = exports.easeOutQuart = exports.easeInQuart = exports.easeInOutCubic = exports.easeOutCubic = exports.easeInCubic = exports.easeInOutQuad = exports.easeOutQuad = exports.easeInQuad = exports.easeInOutSine = exports.easeOutSine = exports.easeInSine = exports.linear = void 0; const linear = [[[0, 1], '', [0.33, 0.67]], [[1, 0], [0.67, 0.33]]]; exports.linear = linear; const easeInSine = [[[0, 1]], [[0.538, 0.564], [0.169, 0.912], [0.88, 0.196]], [[1, 0]]]; exports.easeInSine = easeInSine; const easeOutSine = [[[0, 1]], [[0.444, 0.448], [0.169, 0.736], [0.718, 0.16]], [[1, 0]]]; exports.easeOutSine = easeOutSine; const easeInOutSine = [[[0, 1]], [[0.5, 0.5], [0.2, 1], [0.8, 0]], [[1, 0]]]; exports.easeInOutSine = easeInOutSine; const easeInQuad = [[[0, 1]], [[0.55, 0.584], [0.231, 0.904], [0.868, 0.264]], [[1, 0]]]; exports.easeInQuad = easeInQuad; const easeOutQuad = [[[0, 1]], [[0.413, 0.428], [0.065, 0.816], [0.76, 0.04]], [[1, 0]]]; exports.easeOutQuad = easeOutQuad; const easeInOutQuad = [[[0, 1]], [[0.5, 0.5], [0.3, 0.9], [0.7, 0.1]], [[1, 0]]]; exports.easeInOutQuad = easeInOutQuad; const easeInCubic = [[[0, 1]], [[0.679, 0.688], [0.366, 0.992], [0.992, 0.384]], [[1, 0]]]; exports.easeInCubic = easeInCubic; const easeOutCubic = [[[0, 1]], [[0.321, 0.312], [0.008, 0.616], [0.634, 0.008]], [[1, 0]]]; exports.easeOutCubic = easeOutCubic; const easeInOutCubic = [[[0, 1]], [[0.5, 0.5], [0.3, 1], [0.7, 0]], [[1, 0]]]; exports.easeInOutCubic = easeInOutCubic; const easeInQuart = [[[0, 1]], [[0.812, 0.74], [0.611, 0.988], [1.013, 0.492]], [[1, 0]]]; exports.easeInQuart = easeInQuart; const easeOutQuart = [[[0, 1]], [[0.152, 0.244], [0.001, 0.448], [0.285, -0.02]], [[1, 0]]]; exports.easeOutQuart = easeOutQuart; const easeInOutQuart = [[[0, 1]], [[0.5, 0.5], [0.4, 1], [0.6, 0]], [[1, 0]]]; exports.easeInOutQuart = easeInOutQuart; const easeInQuint = [[[0, 1]], [[0.857, 0.856], [0.714, 1], [1, 0.712]], [[1, 0]]]; exports.easeInQuint = easeInQuint; const easeOutQuint = [[[0, 1]], [[0.108, 0.2], [0.001, 0.4], [0.214, -0.012]], [[1, 0]]]; exports.easeOutQuint = easeOutQuint; const easeInOutQuint = [[[0, 1]], [[0.5, 0.5], [0.5, 1], [0.5, 0]], [[1, 0]]]; exports.easeInOutQuint = easeInOutQuint; const easeInBack = [[[0, 1]], [[0.667, 0.896], [0.38, 1.184], [0.955, 0.616]], [[1, 0]]]; exports.easeInBack = easeInBack; const easeOutBack = [[[0, 1]], [[0.335, 0.028], [0.061, 0.22], [0.631, -0.18]], [[1, 0]]]; exports.easeOutBack = easeOutBack; const easeInOutBack = [[[0, 1]], [[0.5, 0.5], [0.4, 1.4], [0.6, -0.4]], [[1, 0]]]; exports.easeInOutBack = easeInOutBack; const easeInElastic = [[[0, 1]], [[0.474, 0.964], [0.382, 0.988], [0.557, 0.952]], [[0.619, 1.076], [0.565, 1.088], [0.669, 1.08]], [[0.77, 0.916], [0.712, 0.924], [0.847, 0.904]], [[0.911, 1.304], [0.872, 1.316], [0.961, 1.34]], [[1, 0]]]; exports.easeInElastic = easeInElastic; const easeOutElastic = [[[0, 1]], [[0.073, -0.32], [0.034, -0.328], [0.104, -0.344]], [[0.191, 0.092], [0.11, 0.06], [0.256, 0.08]], [[0.31, -0.076], [0.26, -0.068], [0.357, -0.076]], [[0.432, 0.032], [0.362, 0.028], [0.683, -0.004]], [[1, 0]]]; exports.easeOutElastic = easeOutElastic; const easeInOutElastic = [[[0, 1]], [[0.21, 0.94], [0.167, 0.884], [0.252, 0.98]], [[0.299, 1.104], [0.256, 1.092], [0.347, 1.108]], [[0.5, 0.496], [0.451, 0.672], [0.548, 0.324]], [[0.696, -0.108], [0.652, -0.112], [0.741, -0.124]], [[0.805, 0.064], [0.756, 0.012], [0.866, 0.096]], [[1, 0]]]; exports.easeInOutElastic = easeInOutElastic; const easeInBounce = [[[0, 1]], [[0.148, 1], [0.075, 0.868], [0.193, 0.848]], [[0.326, 1], [0.276, 0.836], [0.405, 0.712]], [[0.6, 1], [0.511, 0.708], [0.671, 0.348]], [[1, 0]]]; exports.easeInBounce = easeInBounce; const easeOutBounce = [[[0, 1]], [[0.357, 0.004], [0.27, 0.592], [0.376, 0.252]], [[0.604, -0.004], [0.548, 0.312], [0.669, 0.184]], [[0.82, 0], [0.749, 0.184], [0.905, 0.132]], [[1, 0]]]; exports.easeOutBounce = easeOutBounce; const easeInOutBounce = [[[0, 1]], [[0.102, 1], [0.05, 0.864], [0.117, 0.86]], [[0.216, 0.996], [0.208, 0.844], [0.227, 0.808]], [[0.347, 0.996], [0.343, 0.8], [0.48, 0.292]], [[0.635, 0.004], [0.511, 0.676], [0.656, 0.208]], [[0.787, 0], [0.76, 0.2], [0.795, 0.144]], [[0.905, -0.004], [0.899, 0.164], [0.944, 0.144]], [[1, 0]]]; exports.easeInOutBounce = easeInOutBounce; const _default = new Map([['linear', linear], ['easeInSine', easeInSine], ['easeOutSine', easeOutSine], ['easeInOutSine', easeInOutSine], ['easeInQuad', easeInQuad], ['easeOutQuad', easeOutQuad], ['easeInOutQuad', easeInOutQuad], ['easeInCubic', easeInCubic], ['easeOutCubic', easeOutCubic], ['easeInOutCubic', easeInOutCubic], ['easeInQuart', easeInQuart], ['easeOutQuart', easeOutQuart], ['easeInOutQuart', easeInOutQuart], ['easeInQuint', easeInQuint], ['easeOutQuint', easeOutQuint], ['easeInOutQuint', easeInOutQuint], ['easeInBack', easeInBack], ['easeOutBack', easeOutBack], ['easeInOutBack', easeInOutBack], ['easeInElastic', easeInElastic], ['easeOutElastic', easeOutElastic], ['easeInOutElastic', easeInOutElastic], ['easeInBounce', easeInBounce], ['easeOutBounce', easeOutBounce], ['easeInOutBounce', easeInOutBounce]]); exports.default = _default }, {}], 3: [function (require, module, exports) { 'use strict'; const _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault'); Object.defineProperty(exports, '__esModule', { value: true }); exports.transition = transition; exports.injectNewCurve = injectNewCurve; exports.default = void 0; const _slicedToArray2 = _interopRequireDefault(require('@babel/runtime/helpers/slicedToArray')); const _typeof2 = _interopRequireDefault(require('@babel/runtime/helpers/typeof')); const _curves = _interopRequireDefault(require('./config/curves')); const defaultTransitionBC = 'linear'; function transition (tBC) { const startState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; const endState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null; const frameNum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30; const deep = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; if (!checkParams.apply(void 0, arguments)) return false; try { const bezierCurve = getBezierCurve(tBC); const frameStateProgress = getFrameStateProgress(bezierCurve, frameNum); if (!deep || typeof endState === 'number') return getTransitionState(startState, endState, frameStateProgress); return recursionTransitionState(startState, endState, frameStateProgress) } catch (_unused) { console.warn('Transition parameter may be abnormal!'); return [endState] } } function checkParams (tBC) { const startState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; const endState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const frameNum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30; if (!tBC || startState === false || endState === false || !frameNum) { console.error('transition: Missing Parameters!'); return false } if ((0, _typeof2.default)(startState) !== (0, _typeof2.default)(endState)) { console.error('transition: Inconsistent Status Types!'); return false } const stateType = (0, _typeof2.default)(endState); if (stateType === 'string' || stateType === 'boolean' || !tBC.length) { console.error('transition: Unsupported Data Type of State!'); return false } if (!_curves.default.has(tBC) && !(tBC instanceof Array)) { console.warn('transition: Transition curve not found, default curve will be used!') } return true } function getBezierCurve (tBC) { let bezierCurve = ''; if (_curves.default.has(tBC)) { bezierCurve = _curves.default.get(tBC) } else if (tBC instanceof Array) { bezierCurve = tBC } else { bezierCurve = _curves.default.get(defaultTransitionBC) } return bezierCurve } function getFrameStateProgress (bezierCurve, frameNum) { const tMinus = 1 / (frameNum - 1); const tState = new Array(frameNum).fill(0).map(function (t, i) { return i * tMinus }); const frameState = tState.map(function (t) { return getFrameStateFromT(bezierCurve, t) }); return frameState } function getFrameStateFromT (bezierCurve, t) { const tBezierCurvePoint = getBezierCurvePointFromT(bezierCurve, t); const bezierCurvePointT = getBezierCurvePointTFromReT(tBezierCurvePoint, t); return getBezierCurveTState(tBezierCurvePoint, bezierCurvePointT) } function getBezierCurvePointFromT (bezierCurve, t) { const lastIndex = bezierCurve.length - 1; let begin = ''; let end = ''; bezierCurve.findIndex(function (item, i) { if (i === lastIndex) return; begin = item; end = bezierCurve[i + 1]; const currentMainPointX = begin[0][0]; const nextMainPointX = end[0][0]; return t >= currentMainPointX && t < nextMainPointX }); const p0 = begin[0]; const p1 = begin[2] || begin[0]; const p2 = end[1] || end[0]; const p3 = end[0]; return [p0, p1, p2, p3] } function getBezierCurvePointTFromReT (bezierCurve, t) { const reBeginX = bezierCurve[0][0]; const reEndX = bezierCurve[3][0]; const xMinus = reEndX - reBeginX; const tMinus = t - reBeginX; return tMinus / xMinus } function getBezierCurveTState (_ref, t) { const _ref2 = (0, _slicedToArray2.default)(_ref, 4); const _ref2$ = (0, _slicedToArray2.default)(_ref2[0], 2); const p0 = _ref2$[1]; const _ref2$2 = (0, _slicedToArray2.default)(_ref2[1], 2); const p1 = _ref2$2[1]; const _ref2$3 = (0, _slicedToArray2.default)(_ref2[2], 2); const p2 = _ref2$3[1]; const _ref2$4 = (0, _slicedToArray2.default)(_ref2[3], 2); const p3 = _ref2$4[1]; const pow = Math.pow; const tMinus = 1 - t; const result1 = p0 * pow(tMinus, 3); const result2 = 3 * p1 * t * pow(tMinus, 2); const result3 = 3 * p2 * pow(t, 2) * tMinus; const result4 = p3 * pow(t, 3); return 1 - (result1 + result2 + result3 + result4) } function getTransitionState (begin, end, frameState) { let stateType = 'object'; if (typeof begin === 'number')stateType = 'number'; if (begin instanceof Array)stateType = 'array'; if (stateType === 'number') return getNumberTransitionState(begin, end, frameState); if (stateType === 'array') return getArrayTransitionState(begin, end, frameState); if (stateType === 'object') return getObjectTransitionState(begin, end, frameState); return frameState.map(function (t) { return end }) } function getNumberTransitionState (begin, end, frameState) { const minus = end - begin; return frameState.map(function (s) { return begin + minus * s }) } function getArrayTransitionState (begin, end, frameState) { const minus = end.map(function (v, i) { if (typeof v !== 'number') return false; return v - begin[i] }); return frameState.map(function (s) { return minus.map(function (v, i) { if (v === false) return end[i]; return begin[i] + v * s }) }) } function getObjectTransitionState (begin, end, frameState) { const keys = Object.keys(end); const beginValue = keys.map(function (k) { return begin[k] }); const endValue = keys.map(function (k) { return end[k] }); const arrayState = getArrayTransitionState(beginValue, endValue, frameState); return arrayState.map(function (item) { const frameData = {}; item.forEach(function (v, i) { return frameData[keys[i]] = v }); return frameData }) } function recursionTransitionState (begin, end, frameState) { const state = getTransitionState(begin, end, frameState); const _loop = function _loop (key) { const bTemp = begin[key]; const eTemp = end[key]; if ((0, _typeof2.default)(eTemp) !== 'object') return 'continue'; const data = recursionTransitionState(bTemp, eTemp, frameState); state.forEach(function (fs, i) { return fs[key] = data[i] }) }; for (const key in end) { const _ret = _loop(key); if (_ret === 'continue') continue } return state } function injectNewCurve (key, curve) { if (!key || !curve) { console.error('InjectNewCurve Missing Parameters!'); return }_curves.default.set(key, curve) } const _default = transition; exports.default = _default }, { './config/curves': 2, '@babel/runtime/helpers/interopRequireDefault': 5, '@babel/runtime/helpers/slicedToArray': 8, '@babel/runtime/helpers/typeof': 9 }], 4: [function (require, module, exports) { function _arrayWithHoles (arr) { if (Array.isArray(arr)) return arr }module.exports = _arrayWithHoles }, {}], 5: [function (require, module, exports) { function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { default: obj } }module.exports = _interopRequireDefault }, {}], 6: [function (require, module, exports) { function _iterableToArrayLimit (arr, i) { const _arr = []; let _n = true; let _d = false; let _e; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break } } catch (err) { _d = true; _e = err } finally { try { if (!_n && _i.return != null)_i.return() } finally { if (_d) throw _e } } return _arr }module.exports = _iterableToArrayLimit }, {}], 7: [function (require, module, exports) { function _nonIterableRest () { throw new TypeError('Invalid attempt to destructure non-iterable instance') }module.exports = _nonIterableRest }, {}], 8: [function (require, module, exports) { const arrayWithHoles = require('./arrayWithHoles'); const iterableToArrayLimit = require('./iterableToArrayLimit'); const nonIterableRest = require('./nonIterableRest'); function _slicedToArray (arr, i) { return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest() }module.exports = _slicedToArray }, { './arrayWithHoles': 4, './iterableToArrayLimit': 6, './nonIterableRest': 7 }], 9: [function (require, module, exports) { function _typeof2 (obj) { if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') { _typeof2 = function _typeof2 (obj) { return typeof obj } } else { _typeof2 = function _typeof2 (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj } } return _typeof2(obj) } function _typeof (obj) { if (typeof Symbol === 'function' && _typeof2(Symbol.iterator) === 'symbol') { module.exports = _typeof = function _typeof (obj) { return _typeof2(obj) } } else { module.exports = _typeof = function _typeof (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : _typeof2(obj) } } return _typeof(obj) }module.exports = _typeof }, {}] }, {}, [1])
